<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三点水</title>
  
  <subtitle>假装自己是人类</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lotabout.github.io/"/>
  <updated>2018-01-30T13:53:38.951Z</updated>
  <id>http://lotabout.github.io/</id>
  
  <author>
    <name>Mark Wallace</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉索引树</title>
    <link href="http://lotabout.github.io/2018/binary-indexed-tree/"/>
    <id>http://lotabout.github.io/2018/binary-indexed-tree/</id>
    <published>2018-01-29T18:08:18.000Z</published>
    <updated>2018-01-30T13:53:38.951Z</updated>
    
    <content type="html"><![CDATA[<p>二叉索引树(Binary Indexed Tree) 也称为 <a href="https://en.wikipedia.org/wiki/Fenwick_tree" target="_blank" rel="noopener">Fenwicktree</a>，中文也称树状数组。它可以在O(log n) 的时间内得到数组的前缀和(A[1] + A[2] + … + A[i])，且在 O(log n) 时间内支持动态修改数组的值。</p><h2 id="使用场景"><a class="header-anchor" href="#使用场景">#</a>使用场景</h2><p>首先我们考虑一个数组 A，想求 $A_i, A_{i+1}, …, A_j$ 的和，如果只求一次，很自然地把这些数相加即可，时间复杂度为 $O(n)$。但现在如果我们经常要求 A 中第<code>i</code> 到第 <code>j</code> 个元素的和，则最好事先做个索引。</p><p>做法也简单，我们新建一个数组 C，数组 C 中的元素 $C_i = A_0 + A_1 + … +A_i$。于是如果我们要求 $A_i$ 到 $A_j$ 的和，则有 $Q(i, j) = A_i + … + A_j =C_j - C_{i-1}$。即通过访问数组 C，我们只需要 $O(1)$ 的时间即可。</p><p>但如果 A 中的元素 $A_i$ 的值有变化呢？这时，我们需要更新 $C_i$ 之后的所有数据，需要 $O(n)$ 的时间。</p><p>于是索引 C 需要空间 $O(n)$，访问 $O(1)$，修改 $O(n)$。</p><h2 id="二叉索引树"><a class="header-anchor" href="#二叉索引树">#</a>二叉索引树</h2><p>有时我们需要平衡索引的访问和修改时间，二叉索引数 (binary indexed tree) 可以让我们用 $O(\log n)$ 的时间复杂度进行访问，用 $O(\log n)$完成修改。虽然称为&quot;树&quot;，但其实是用数组实现的。</p><h3 id="lowbit"><a class="header-anchor" href="#lowbit">#</a>Lowbit</h3><p>首先，我们来看一个完全二叉树：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                   lowbit</span><br><span class="line"></span><br><span class="line">                o                ├ 1000 = 8</span><br><span class="line">        ┌───────┴───────┐        │</span><br><span class="line">        o               o        ├ 100  = 4</span><br><span class="line">    ┌───┴───┐       ┌───┴───┐    │</span><br><span class="line">    o       o       o       o    ├ 10   = 2</span><br><span class="line">  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐  │</span><br><span class="line">  o   o   o   o   o   o   o   o  ├ 1    = 1</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5  │</span><br></pre></td></tr></table></figure><p>我们看到二叉树不同层数二叉结尾是有规律的。例如第一层：1, 3, 5, 7, …，这些数的二进制分别是 <code>1</code>, <code>11</code>, <code>101</code>, <code>111</code>, …，最后一位都是 <code>1</code>。同理，第二层的数都以 <code>10</code> 结尾。现在我们定义一个新的函数 <code>lowbit(n)</code>，它的作用是在 <code>n</code> 的二进制上从右往左数，数到第一个 1 为止。例如数字 6 的二进制是 <code>110</code>，向右数到第一个 1，得到 <code>10</code>，得到 <code>lowbit(6) = b10 = 2</code>，同理 <code>lowbit(12) = 4</code>。</p><p>那么 <code>lowbit</code> 有什么用呢？如果当前节点是父节点的右子树，则 <code>n - lowbit(n)</code>正好是父节点。再例如 <code>12</code>，<code>12 - lowbit(12) = 12 - 4 = 8</code> 正好是 <code>12</code>的父节点 <code>8</code>。而如果当前节点是父节点的左子树，则 <code>n - lowbit(n)</code>代表了它的第一个&quot;左祖父节点&quot;，例如节点 <code>10</code>，<code>10 - lowbit(10) = 10 - 2 = 8</code>，是 10 的左祖父节点。</p><p>同理， <code>n + lowbit(n)</code> 是“右”祖父节点。例如 <code>4</code>，<code>4 + lowbit(4) = 4 + 4 = 8</code>是 <code>4</code> 的父节点；而 <code>6 + lowbit(6) = 6 + 2 = 8</code> 则对应于 6 的右祖父节点。</p><p>同时可以看到 <code>n - lowbit(n) + 1</code> 在完全二叉数上对应的节点，就是从数字 n对应的节点开始，不断取节点的左子节点直到第一层的那个节点。例如 <code>12</code>所在的结点，不断取左子节点，最终得到的是 <code>9</code>，而 <code>9 = 12 - 4 + 1 = 12 - lowbit(12) + 1</code>。</p><p>有了 <code>lowbit</code>，我们就能在完全二叉树里快速地定位：</p><ul><li><code>n - lowbit(bit)</code> 为左祖父/父节点</li><li><code>n + lowbit(bit)</code> 为右祖父/父节点</li><li><code>n - lowbit(bit) + 1</code> 为左子树的底层节点</li></ul><p>从编程的角度上， <code>lowbit</code> 可以由位运算完成 (C++)：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="建立索引"><a class="header-anchor" href="#建立索引">#</a>建立索引</h3><p>我们知道，索引的本质就是预先存储一些信息，现在我们来看如何从原数组 A 来构建我们的二叉索引数 BIT 。我们定义：</p><p>$$BIT_i = \sum_{j = i - lowbit(i) + 1}^{i} A_j$$</p><p>看公式好像很复杂，我们拆解一下。看到下标 <code>i - lowbit(i) + 1</code>，我们知道代表了<code>i</code> 所在节点左子树的底层节点。我们用图来说明如何计算 <code>BIT[12]</code> (图中标 <code>x</code>)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                o</span><br><span class="line">        ┌───────┴───────┐</span><br><span class="line">        o               x</span><br><span class="line">    ┌───┴───┐       ┌───┴───┐</span><br><span class="line">    o       o       x       o</span><br><span class="line">  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐</span><br><span class="line">  o   o   o   o   x   x   o   o</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5</span><br><span class="line">A:                2 1 3 1</span><br><span class="line">BIT:                   (7)</span><br></pre></td></tr></table></figure><p>可以看到 <code>12 - lowbit(12) + 1 = 12-4+1=9</code>，因此 <code>BIT[12] = A[9] + A[10] + A[11] + A[12]</code>。同理，如果要计算 <code>BIT[8]</code>，则需要计算 <code>A[1] + ... + A[8]</code>，因为 <code>8 - lowbit(8) + 1 = 1</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                x</span><br><span class="line">        ┌───────┴───────┐</span><br><span class="line">        x               o</span><br><span class="line">    ┌───┴───┐       ┌───┴───┐</span><br><span class="line">    x       x       o       o</span><br><span class="line">  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐</span><br><span class="line">  x   x   x   x   o   o   o   o</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5</span><br></pre></td></tr></table></figure><p>具体如何构建二叉索引树我们下面再说。</p><h3 id="sum"><a class="header-anchor" href="#sum">#</a>Sum</h3><p>我们定义二叉查找树的查找操作为 <code>sum(k) = A[1] + ... + A[k]</code>，有了 BIT之后，就可以这么求：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &gt; <span class="number">0</span>; i = i-lowbit(i))</span><br><span class="line">        ans += BIT[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得 <code>n - lowbit(n)</code> 代表什么吗？代表的是 n 节点的左祖父/父节点。因此为了求<code>sum(k)</code> 我们只需要将 <code>k</code> 及 <code>k</code> 的所有左祖父/父节点相加即可。因此复杂度是$O(\log n)$。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                   lowbit</span><br><span class="line"></span><br><span class="line">                o                ├ 1000 = 8</span><br><span class="line">        ┌───────┴───────┐        │</span><br><span class="line">        o               o        ├ 100  = 4</span><br><span class="line">    ┌───┴───┐       ┌───┴───┐    │</span><br><span class="line">    o       o       o       o    ├ 10   = 2</span><br><span class="line">  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐  │</span><br><span class="line">  o   o   o   o   o   o   o   o  ├ 1    = 1</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5  │</span><br></pre></td></tr></table></figure><p>我们以 <code>6</code> 为例，<code>BIT[6]</code> 相当于 <code>A[5] + A[6]</code>，但我们要计算 <code>A[1] + ... + A[6]</code>，因此还要计算 <code>A[1] + ... + A[4]</code>，而在 BIT 中，这正好对应于 <code>BIT[4]</code>。再以 <code>14</code> 为例，<code>BIT[14] = A[13] + a[14]</code>，还差 <code>A[1] + ... + A[12]</code>，于是找到<code>14 - lowbit(14) = 14 - 2 = 12</code>，而由于 <code>BIT[12] = BIT[9] + ... + BIT[12]</code>，因此还差 <code>A[1] + ... + A[8]</code>，正好对应于 <code>BIT[8]</code>，而又有 <code>12 - lowbit(12) = 12 - 4 = 8</code> 。</p><p>所以说 <code>sum(k)</code> 操作就是求节点 <code>k</code> 及它的父节点的和。</p><h3 id="更新节点"><a class="header-anchor" href="#更新节点">#</a>更新节点</h3><p>如果 <code>A[k]</code> 的值发生变化了怎么办？从 BIT 的定义可知，<code>A[k]</code> 的值会影响 <code>k</code> 的所有右祖父/父节点。而这可以通过 <code>k + lowbit(k)</code> 来得到。例如 <code>A[9]</code>发生了变化，根据定义，我们需要更新 <code>BIT[9], BIT[10], BIT[12]</code>。代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= MAX_N; j = j+lowbit(j))</span><br><span class="line">        BIT[j] += delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，和 <code>sum</code> 类似，也是不断寻找祖父/父节点的过程，因此也是 $O(\log n)$。</p><h3 id="初始化"><a class="header-anchor" href="#初始化">#</a>初始化</h3><p>可以有多种方式初始化，每种的复杂度不同。</p><p>先假设初始数组 A 全为 0，之后调用节点更新函数 <code>edit</code> 来更新数组中的每个元素，复杂度为 $O(n \log n)$。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=MAX_N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        edit(i, A[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然初始化操作是可以达到 $O(n)$ 的。方法是像开头说的，先创建一个累加数组，于是只需要用 $O(1)$ 时间即可求得 <code>A[j] - A[i]</code>。</p><p>但这么做意义不是特别大。因为当我们采用 BIT 时，其实就意味着我们想利用它更新时间为 $O(\log n)$ 的特性，这意味着更新操作不会少。于是可以大胆猜测会有 $O(n)$个更新操作，这样整体的算法复杂度就要大于 $O(n \log n)$，那么强行用 $O(n)$ 来初始化 BIT 也没有太大的意义。</p><h2 id="参考文章"><a class="header-anchor" href="#参考文章">#</a>参考文章</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/树状数组</a></li><li><a href="http://www.cnblogs.com/pengzhen/p/4373491.html" target="_blank" rel="noopener">http://www.cnblogs.com/pengzhen/p/4373491.html</a></li><li><a href="http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/07/26/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B4%A2%E5%BC%95%E6%A0%91(%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84).html" target="_blank" rel="noopener">http://novoland.github.io/算法/2014/07/26/二进制索引树(树状数组).html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二叉索引树(Binary Indexed Tree) 也称为 &lt;a href=&quot;https://en.wikipedia.org/wiki/Fenwick_tree&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Fenwick
tree&lt;/a&gt;，中文也称树
      
    
    </summary>
    
      <category term="Knowledge" scheme="http://lotabout.github.io/categories/Knowledge/"/>
    
    
      <category term="Data Structure" scheme="http://lotabout.github.io/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>Git: merge vs rebase</title>
    <link href="http://lotabout.github.io/2018/Git-merge-vs-rebase/"/>
    <id>http://lotabout.github.io/2018/Git-merge-vs-rebase/</id>
    <published>2018-01-18T17:02:51.000Z</published>
    <updated>2018-01-30T13:53:38.923Z</updated>
    
    <content type="html"><![CDATA[<p>Merge 还是 Rebase，这是一个问题。网上有许多教程说明二者的区别，之前我写的一个<a href="https://docs.google.com/presentation/d/18b-ehlVjU82_PzU64lkbVwkzPsK3T2yENmjwwL7FVfM/edit" target="_blank" rel="noopener">关于 Git 的 PPT</a>里也说过两者的区别。这篇文章里，我们从分支图的角度，看看两种策略下产生的分支图有什么区别。</p><h2 id="理想的分支图"><a class="header-anchor" href="#理想的分支图">#</a>理想的分支图</h2><p>这里我们要说明的是， Git 是用来解决多人协作的代码管理，尽管也可以“单机”使用，但它的一些优势或是缺点要在多人使用时才会显露出来。</p><p>现在假设我们独自开发一个产品，一个个往上加功能，那么最终的 git 分支图会像这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">│</span><br><span class="line">M─┐ Merge branch &apos;feature-2&apos;</span><br><span class="line">│ o [feature-2] commit #3</span><br><span class="line">│ o [feature-2] commit #2</span><br><span class="line">│ o [feature-2] commit #1</span><br><span class="line">M─┤ Merge branch &apos;feature-1&apos;</span><br><span class="line">│ o [feature-1] commit #4</span><br><span class="line">│ o [feature-1] commit #3</span><br><span class="line">│ o [feature-1] commit #2</span><br><span class="line">│ o [feature-1] commit #1</span><br><span class="line">I─┘ Initial commit</span><br></pre></td></tr></table></figure><p>这里采用的是 <a href="https://github.com/jonas/tig" target="_blank" rel="noopener">tig</a> 的分支图符号。可以看到的是每个功能都用了几个 commit，开发后合并到 <code>master</code> 分支中，再基于最新的代码继续开发下一个功能。清晰明白。</p><p>但如果多个人一起开发，或者有多个并行开发的功能，那么事情就开始变复杂了。</p><h2 id="merge"><a class="header-anchor" href="#merge">#</a>Merge</h2><p>现在我们考虑多人开发多个 feature，那么最幸运的情况是像这样的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">M─────┐ Merge branch &apos;feature-2&apos;</span><br><span class="line">│     o [Feature-2] commit 2</span><br><span class="line">│     o [Feature-2] commit 1</span><br><span class="line">M───┐ │ Merge branch &apos;feature-2&apos;</span><br><span class="line">│   o │ [Feature-2] commit 2</span><br><span class="line">│   o │ [Feature-2] commit 1</span><br><span class="line">M─┐ │ │ Merge branch &apos;feature-1&apos;</span><br><span class="line">│ o │ │ [Feature-1] commit 2</span><br><span class="line">│ o │ │ [Feature-1] commit 1</span><br><span class="line">o─┴─┴─┘ base commit for all features</span><br></pre></td></tr></table></figure><p>可以看到有多列，代表不同的 <code>feature</code> 分支，它们最终都合到 <code>master</code> 里。这就是采用 merge 策略最常见的分支结构。一般同时开发的分支越多，列数越多。</p><p>上面这个图像是理想的并行版本，它要求所有 <code>feature</code> 基于同一个 commit，且每个commit 的时间是线性的，所以现实中基本不可能满足这种情况。</p><p>如果每个 commit 的时间不同，分支的线就会开始交叉：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">M─┐     Merge feature-1</span><br><span class="line">M─│───┐ Merge feature-3</span><br><span class="line">│ o   │ [1] Commit 2</span><br><span class="line">│ │   o [3] Commit 2</span><br><span class="line">M─│─┐ │ Merge feature-2</span><br><span class="line">│ │ │ o [3] commit 1</span><br><span class="line">│ │ o │ [2] commit 2</span><br><span class="line">│ │ o │ [2] commit 1</span><br><span class="line">│ o │ │ [1] commit 1</span><br><span class="line">o─┴─┴─┘ base commit for all features</span><br></pre></td></tr></table></figure><p>上面这个图追踪起来就比较麻烦了，如果考虑到 commit 数量多的话，情况就更糟糕了。我们这里所有子分支是从同一个 base commit 开始的，如果各个分支的起始 commit 不同，分支图就会变得特别乱了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">M─┐     merge feature-1</span><br><span class="line">│ o     [1] commit 2</span><br><span class="line">M─│───┐ merge feature-3</span><br><span class="line">│ │   o [3] commit 2</span><br><span class="line">M─│─┐ │ merge feature-2</span><br><span class="line">│ │ o │ [2] commit 2</span><br><span class="line">│ │ │ o [3] commit 1</span><br><span class="line">│ │ o │ [2] commit 1</span><br><span class="line">o─│─│─┘ base commit 2</span><br><span class="line">│ o │   [1] commit 1</span><br><span class="line">o─┴─┘   base commit 1</span><br></pre></td></tr></table></figure><p>上面的救命图可能还相对容易看懂，这是因此 commit 数量少，分支数也少，另外各个feature 分支上都没有 merge commit，否则会更复杂。</p><p>综上，在分支图上，merge 会导致分支图的列增多，且依据分支的初始 commit 不同及commit 的时间不同，会使分支图有更多的交叉，导致历史难以追踪。</p><h2 id="rebase"><a class="header-anchor" href="#rebase">#</a>rebase</h2><p>其实大家使用 rebase 的一个重要特点是 rebase 能产生线性的分支历史。考虑这样一个分支图：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(master)</span><br><span class="line">│ (feature-1)</span><br><span class="line">o │ c</span><br><span class="line">│ o b</span><br><span class="line">│ o a</span><br><span class="line">o─┘</span><br></pre></td></tr></table></figure><p>如果我们此时在 master 分支执行 <code>git merge feature-1</code>，则和之前 merge 一样，结果会变成：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">M─┐</span><br><span class="line">o │ c</span><br><span class="line">│ o b</span><br><span class="line">│ o a</span><br><span class="line">o─┘</span><br></pre></td></tr></table></figure><p>但如果我们在 feature-1 上执行 <code>git rebase master</code>，则会产生下面的图形。注意的是 rebase 是会产生新的 commit 的，<code>a</code> 变成了 <code>a'</code>，如果用 <code>git show</code> 看其中的内容，可以发现虽然 commit message 相同，但 diff 已经是不同了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(master)</span><br><span class="line">│ (feature-1)</span><br><span class="line">│ o b&apos;</span><br><span class="line">│ o a&apos;</span><br><span class="line">o─┘ c</span><br><span class="line">o</span><br></pre></td></tr></table></figure><p>可以看到，分支 <code>feature-1</code> 的初始 commit 变成了 <code>c</code>。这时候取决于 merge 的方式，会有不同的效果。一是在 <code>master</code> 上执行 <code>git merge feature-1</code>，这时 git 会判断可以 fast-forward；二是通过 gitlab 或 github 等提交 Merge/Pull request，它们依旧会创建一个 Merge commit，如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local merge                 gitlab/github</span><br><span class="line">(master, feature-1)         (master)</span><br><span class="line">│                           M─┐ m</span><br><span class="line">o b&apos;                        │ o b&apos;</span><br><span class="line">o a&apos;                        │ o a&apos;</span><br><span class="line">o c                         o─┘ c</span><br><span class="line">o                           o</span><br></pre></td></tr></table></figure><p>但注意到即使 gitlab 会创建新的 merge commit <code>m</code>，在 master 的 <code>c</code> 与 <code>m</code> 之间也不会有任何“插队”的其它 commit。突出一个清晰明了。</p><p>这时考虑多个 feature 同时开发，大家在合并前都先 rebase 最新的代码，就能做成“线性”的图形：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(master)           (master)           (master)              (master)</span><br><span class="line">│ (feature-1)      │   (feature-2)    │ (feature-2)         │</span><br><span class="line">│ │ (feature-2)    │   │              │ │                   M─┐ merge feature 2</span><br><span class="line">│ │ │              │   o              │ o                   │ o</span><br><span class="line">│ │ o   ====&gt;      │   o    ====&gt;     │ o        ====&gt;      │ o</span><br><span class="line">│ │ o              M─┐ │              M─┤                   M─┤ merge feature 1</span><br><span class="line">│ o │              │ o │              │ o                   │ o</span><br><span class="line">│ o │              │ o │              │ o                   │ o</span><br><span class="line">o─┴─┘              o─┴─┘              o─┘                   o─┘</span><br><span class="line"></span><br><span class="line">   (merge feature-1)   (rebase master)   (merge feature-2)</span><br></pre></td></tr></table></figure><p>但在实际的团队开发中，要达到上面的要求需要“串行”提交代码，即上一个人的代码合并之后，下一个人再 rebase 最新代码并提交新的 Merge/Pull request。这是不现实的。经常的情况是所有人都在 deadline 临近时一起提交，是一个“并行”提交的过程。并且现在大家一般在 merge 前都会有一些 CI 的检查，如果串行，这些检查也得串行地执行，太耗时间了。也因此， rebase 比较合适使用在“内部”分支上。例如一个 feature 有多个 task，那么 task 分支合并到 feature 分支时，使用 rebase 比较合适。</p><p>一些情形下，我们会发现有一些 commit 出现了多次，假设现在我们开发一个 feature，包含两个子任务，这两个子任务是在 feature 开发了一定时间后开始的，于是出现这样的分支图：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(master)</span><br><span class="line">│ (feature)</span><br><span class="line">│ │ (task-1)</span><br><span class="line">│ │ │ (task-2)</span><br><span class="line">o │ │ │ c</span><br><span class="line">│ │ │ o t2</span><br><span class="line">│ │ o │ t1</span><br><span class="line">│ o─┴─┘ b</span><br><span class="line">│ o     a</span><br><span class="line">o─┘     base commit</span><br></pre></td></tr></table></figure><p>现在，两个 task 前后完成了开发，于是向 master 发起了 Merge/Pull request。在发之前，先 rebase 了 <code>master</code>，于是产生了如下的分支图：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(master)</span><br><span class="line">│ (feature)</span><br><span class="line">│ │ (task-1)</span><br><span class="line">│ │ │ (task-2)</span><br><span class="line">│ │ │ │</span><br><span class="line">│ │ │ o t2</span><br><span class="line">│ │ │ o b&quot;</span><br><span class="line">│ │ │ o a&quot;</span><br><span class="line">│ │ o │ t1</span><br><span class="line">│ │ o │ b&apos;</span><br><span class="line">│ │ o │ a&apos;</span><br><span class="line">│ o │ │ b</span><br><span class="line">│ o │ │ a</span><br><span class="line">o─┴─┴─┘ c</span><br><span class="line">o       base commit</span><br></pre></td></tr></table></figure><p>可以看到，rebase 过后，<code>task-1</code> <code>task-2</code> 分别生成了自己对应的 commit <code>a</code> <code>b</code>的复本。那么当 <code>task-1</code> <code>task-2</code> 独立被合并到 master 时，这些复本都会被保留：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(master)</span><br><span class="line">M───┐</span><br><span class="line">│   o t2</span><br><span class="line">│   o b&quot;</span><br><span class="line">│   o a&quot;</span><br><span class="line">M─┐ │</span><br><span class="line">│ o │ t1</span><br><span class="line">│ o │ b&apos;</span><br><span class="line">│ o │ a&apos;</span><br><span class="line">o─┴─┘ c</span><br><span class="line">o     base commit</span><br></pre></td></tr></table></figure><p>所以，此时如果在 <code>master</code> 分支上用 <code>git log</code> 查看历史，会看到有两个 a(<code>a'</code><code>a&quot;</code>) 两个 b(<code>b'</code> <code>b&quot;</code>)。这是用 rebase 容易产生的问题之一，其它需要注意的这里就不深入了。</p><p>综上，从分支图的角度上，使用 rebase 能使分支图更“直”，但如果使用不当，也容易出现一个 commit 被提交了多次的情况。</p><h2 id="一些建议"><a class="header-anchor" href="#一些建议">#</a>一些建议</h2><p>结合上面我们看到的情况，管理分支时，我的建议是“从哪来，回哪去”。</p><p>例如一个 <code>task</code> 分支是从 <code>feature</code> 分支出来的，那么最好合并回 <code>feature</code> 分支，而不要直接合并到其它的分支（如 <code>master</code>）。这样能防止 commit 被提交多份。在“回哪去”的过程中，尽量使用 <code>rebase</code>，最大程度保证分支图的“线性”结构。</p><p>当然最重要的还是明白背后的原理，这样才能灵活使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Merge 还是 Rebase，这是一个问题。网上有许多教程说明二者的区别，之前我写的一个
&lt;a href=&quot;https://docs.google.com/presentation/d/18b-ehlVjU82_PzU64lkbVwkzPsK3T2yENmjwwL7FVf
      
    
    </summary>
    
      <category term="Knowledge" scheme="http://lotabout.github.io/categories/Knowledge/"/>
    
    
      <category term="Git" scheme="http://lotabout.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>不要轻易使用元编程</title>
    <link href="http://lotabout.github.io/2018/think-twice-before-utilizing-meta-programming/"/>
    <id>http://lotabout.github.io/2018/think-twice-before-utilizing-meta-programming/</id>
    <published>2018-01-07T12:01:55.000Z</published>
    <updated>2018-01-30T13:53:38.967Z</updated>
    
    <content type="html"><![CDATA[<p>元编程就像核弹，自己梦寐以求，却不希望别人拥有。</p><p>一般说元编程分为两类，一类是宏，在编译时期生成代码；另一类是运行时修改代码的行为。而不论是哪一类，我的建议是在决定使用之前要慎重考虑。元编程能让我们扩展语言本身，是十足的黑魔法；但用好不易，容易造成团队/社区在意见是实现上的分裂。（另外这篇文章里主要是对元编程的一些吐糟，并不包含基础知识的介绍。）</p><a id="more"></a><h2 id="光明与黑暗"><a class="header-anchor" href="#光明与黑暗">#</a>光明与黑暗</h2><p>一上来，我们先看 Common Lisp 里的 <code>loop</code> 宏就。一方面，它体现了宏的强大；另一方面，它展现了宏能给我们带来的复杂。</p><p>熟悉 C/Java 语言都知道循环是语言本身提供的关键字，一般是 <code>for</code>。但 Lisp 语言特别精简，它认为循环只是递归的一个特殊形式，语言本身也不包含任何的循环关键字。于是有人用宏实现了 <code>loop</code> ，它让我们能以近乎英语的方式在 Lisp 里写循环语句，这里从 <a href="http://www.ai.sri.com/pkarp/loop.html" target="_blank" rel="noopener">这里</a> 摘抄一个例子：</p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">loop</span> for x in '(a b c d e)</span><br><span class="line">      for y from <span class="number">1</span></span><br><span class="line"></span><br><span class="line">      if (<span class="name">&gt;</span> y <span class="number">1</span>)</span><br><span class="line">      do (<span class="name">format</span> <span class="literal">t</span> <span class="string">", ~A"</span> x)</span><br><span class="line">      else do (<span class="name">format</span> <span class="literal">t</span> <span class="string">"~A"</span> x)</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><p>你不需要了解这段代码的含义，重要的是了解像 <code>for .. in ..</code>, <code>if ... do ... else ... do</code> 这样的语法并不是 Lisp 提供的，而是 loop 宏实现的，这些语法离开了<code>loop</code> 也就不再合法。</p><p>我们看到 loop 宏让我们能在 Lisp 语言不支持的情况下享受到近乎现代语言中才包含的<code>for ... in ...</code> 语法。要知道在 Java 中有两种 for 语句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Element: "</span> + array[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String element : array) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Element: "</span> + element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而第二种直到 JDK 1.5 才加入。在这之前，广大的 Java 程序员即使已经认识到了第二种写法的优越性，却也只能无奈等到语言支持才行。而 Lisp 程序员很快就能通过宏来实现自己理想中的语法。</p><p>然而光明与黑暗共生，宏给我们带来极大自由的同时，也意味着分裂。每个程序员心中理想的语法各不相同，这就意味着一千个程序员会有一千种语法。在 Lisp 中宏是非常容易编写的（不代表容易正确编写），意味着真的会存在一千种语法，大家谁也不服谁，因此造成分裂；但在 C/Java 中，没有宏的支持，虽然有一千种想法，但大家都写不出编译器，于是只能集中讨论，统一语法了，再靠大牛们实现了。</p><p>而现实就是如此，Common Lisp 尝试标准化 Lisp，但依旧有人不认同这种理念，例如Scheme，Common Lisp 标准化的 <code>loop</code> 宏在 Scheme 中就被抛弃了。</p><h2 id="照进现实"><a class="header-anchor" href="#照进现实">#</a>照进现实</h2><p>前车之鉴，后事之师。Lisp 强大的功能，反面导致了语言的分裂，最终使 Lisp 也慢慢退出历史舞台（主流地位），这也被称为 <a href="http://www.winestockwebdesign.com/Essays/Lisp_Curse.html" target="_blank" rel="noopener">The LispCurse</a>。而现实中我们也常常会被元编程的强大和便捷诱惑，我认为使用元编程之前最好考虑会不会造成更多的分裂。最基本的就是不应该自己造语法（DSL）。</p><p>当然，我的出发点是多人团队，较大的项目，考虑的是整体的发展。如果是个人学习，或者小团队等，元编程或许能成为你出众的秘密武器。但大的项目讲求的是合作，DSL 造成的分裂实在是得不偿失，尤其是作者离开后，维护的工作经常后继无人。</p><p>近两年接触到的 rust 也是提供了宏的支持，虽然不像 Lisp 宏一样容易编写，但从功能的角度上依旧特别强大，而且模板宏写起来也很容易，于是有人想写一个类似 Python 的<a href="https://gist.github.com/waynenilsen/0c7a9e42fbc8581592c2" target="_blank" rel="noopener">dict 语法</a>：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = dict!(</span><br><span class="line">    <span class="string">"hello"</span> =&gt; <span class="string">"world"</span></span><br><span class="line">    ,<span class="string">"hello2"</span> =&gt; <span class="string">"world2"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>但我个人并不喜欢这种语法，我认为 Clojure 似的语法更简洁 <code>dict!(&quot;hello&quot;: &quot;world&quot;)</code>。那在团队里引入这两个宏就会引起代码的分裂，后来人在看代码时就会很困惑。不利于团队的建设。</p><p>最后分享在 <a href="https://www.zhihu.com/question/19875500/answer/120828859" target="_blank" rel="noopener">知乎</a> 上看到的引用：</p><blockquote><p>Hygienic Macros and Compile-Time Evaluation: A first-class macro system, orsupport for compile-time code execution in general, is something we mayconsider in future releases. We don’t want the existence of a macro system tobe a workaround that reduces the incentive for making the core language great.</p><footer><strong>https://github.com/apple/swift-evolution/tree/104cdde1c374a95a7eaf4768960578db3b9971b7</strong></footer></blockquote><p>Swift 表示不希望用宏来解决语言本身的缺陷。</p><p>而我的理解是当我们希望用宏（或其它元编程手段）时，很可能是我们使用的语言缺少了某些特性，例如 Java 的 lombok 提供的 <code>@Getter/@Setter</code> 等注解，就是因为 Java没有相应的语言层面的支持，看看 Kotlin 的支持你就会明白的。</p><p>但即便有了宏（或元编程）的支持，你有信心能做出让整个团队都信服的设计吗？如果没有，最好还是慎重为之。</p><h2 id="写在最后"><a class="header-anchor" href="#写在最后">#</a>写在最后</h2><p>虽然是吐糟，但这篇之间重写了三次。想表达的内容很多，最终还是把其它的东西删去，Lisp curse 还是我想真正表达的东西吧，其它的基础知识，有缘人自然会从其它地方学会。</p><p>年轻人容易崇拜力量，我们也别忘了阳光还有影子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;元编程就像核弹，自己梦寐以求，却不希望别人拥有。&lt;/p&gt;
&lt;p&gt;一般说元编程分为两类，一类是宏，在编译时期生成代码；另一类是运行时修改代码的行
为。而不论是哪一类，我的建议是在决定使用之前要慎重考虑。元编程能让我们扩展语言
本身，是十足的黑魔法；但用好不易，容易造成团队/社区在意见是实现上的分裂。（另
外这篇文章里主要是对元编程的一些吐糟，并不包含基础知识的介绍。）&lt;/p&gt;
    
    </summary>
    
      <category term="Comment" scheme="http://lotabout.github.io/categories/Comment/"/>
    
    
      <category term="meta-programming" scheme="http://lotabout.github.io/tags/meta-programming/"/>
    
      <category term="macro" scheme="http://lotabout.github.io/tags/macro/"/>
    
  </entry>
  
  <entry>
    <title>DIP vs IoC vs DI</title>
    <link href="http://lotabout.github.io/2018/Dependency-Inversion-Principle/"/>
    <id>http://lotabout.github.io/2018/Dependency-Inversion-Principle/</id>
    <published>2018-01-03T09:51:55.000Z</published>
    <updated>2018-01-30T13:53:38.923Z</updated>
    
    <content type="html"><![CDATA[<p>你听过 SOLID 设计原则吗？你了解 Spring 里的控制反转（IoC）吗？你知道依赖注入（Dependency Injection）和它们有什么区别吗？虽然它们的形式多样，但内核却是简单的概念。我们就来看看它们到底是什么。</p><h2 id="tldr"><a class="header-anchor" href="#tldr">#</a>TLDR;</h2><p><img src="http://www.tutorialsteacher.com/Content/images/ioc/principles-and-patterns.png" alt="IoC Principle and patterns"></p><p>（图片来源： <a href="http://www.tutorialsteacher.com/ioc/introduction%EF%BC%89" target="_blank" rel="noopener">http://www.tutorialsteacher.com/ioc/introduction）</a></p><blockquote><p>DI is about wiring, IoC is about direction, and DIP is about shape.</p></blockquote><ul><li>DIP 是一种思想，它认为上层代码不应该依赖下层的具体实现，而应该提供接口让下层实现。</li><li>IoC 也是一种思想，它认为代码本职之外的其它工作都应该由某个第三方（框架）完成。</li><li>DI 是一种技术，将依赖通过“注入”的方式提供给需要的类，是是 DIP 和 IoC思想的具体表现。</li></ul><p>这些思想的目的都是解耦，使程序能更好地模块化，同时也使各个模块更容易测试。</p><h2 id="依赖反转原则-dependency-inversion-principle"><a class="header-anchor" href="#依赖反转原则-dependency-inversion-principle">#</a>依赖反转原则（Dependency Inversion Principle）</h2><p>它是 SOLID 原则中的“D”，根据 <a href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">维基百科</a>：</p><blockquote><p>在面向对象编程领域中，依赖反转原则（Dependency inversion principle，DIP）是指一种特定的解耦（传统的依赖关系创建在高层次上，而具体的策略设置则应用在低层次的模块上）形式，使得高层次的模块不依赖于低层次的模块的实现细节，依赖关系被颠倒（反转），从而使得低层次模块依赖于高层次模块的需求抽象。</p></blockquote><p>从上面的描述我们可以看它的目的是 <strong>解耦</strong> ，而手段是 “高层次的模块不依赖于低层次的模块的实现细节”。具体有两个原则：</p><blockquote><ol><li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。</li><li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。</li></ol></blockquote><p>例如下面的代码中，Service 的实现依赖于 DAO 的具体实现。如图：</p><img src="/2018/Dependency-Inversion-Principle/DIP-dao-normal.png" title="Dependency of Service"><p>上图中， 高层的 XXXService 依赖于 DAO 的实现细节，如果 DAO 是对 SQL 数据库进行操作，那也就决定了 XXXService 也只适用于 SQL 数据库，之后如果添加了 NOSQL数据库，想再复用 XXXService 的逻辑就十分困难了。这是耦合的带来的弊端之一。</p><p>有 Java 经验的同学肯定会觉得解决方案很简单啊，不要用 <code>DAO</code> 类啊，先实现一个<code>DAO</code> 接口，再实现一个实现类不就搞定了嘛。是的，这个习惯似乎已经成了一种铁律，但没错，DIP 的实践告诉我们 XXXService 应该创建一个 <code>DAO</code> 接口，而具体的实现类则负责实现这个接口，如下：</p><img src="/2018/Dependency-Inversion-Principle/DIP-dao-dip.png" title="DIP of DAO"><p>上面这张图有两点要注意的地方：</p><ol><li><code>DAO</code> 接口是和 <code>XXXService</code> （调用方）在同一层而不是和 <code>SQLDao</code> （实现方）在一层的，这是大家容易忽略的点。</li><li><code>XXXService</code> 依赖同一层的接口，在下层的 <code>SQLDao</code> 实现了上一层的接口。</li></ol><p>因此依赖反转， <strong>“反转”的是上下层的依赖，由之前的上层依赖下层的实现，反转成下层依赖上层的接口</strong>。</p><p>而在实现上也很容易理解：不要在一个类里显示 <code>new</code> 另一个类（当然一般来说这个类是 Service 或 Component，而不是普通的数据类）。</p><h2 id="控制反转-inversion-of-control"><a class="header-anchor" href="#控制反转-inversion-of-control">#</a>控制反转（Inversion of Control）</h2><p>那么什么是控制反转呢？我认为 <a href="http://www.tutorialsteacher.com/ioc/introduction" target="_blank" rel="noopener">这篇文章</a> 讲得特别清晰：</p><blockquote><p>IoC is a design principle which recommends inversion of different kinds ofcontrols in object oriented design to achieve loose coupling between theapplication classes. Here, the control means any additional responsibilitiesa class has other than its main responsibility, such as control over theflow of an application, control over the dependent object creation andbinding</p></blockquote><p>IoC 是一个 <strong>设计原则</strong>，它提倡我们反转面向对象设计中的各种控制，以达到各个类之间的解耦。这里“控制”的含义是除了一个类本职之外的其它所有工作，如整个软件流程的控制，依赖或绑定的创建等。关于 IoC 的各种学习材料里，经常会说它和“好莱坞原则”一致：</p><blockquote><p>Don’t call me, I’ll call you.</p></blockquote><p>但一般和依赖注入相关的例子我认为并不贴切，反而是 <a href="https://en.wikipedia.org/wiki/Inversion_of_control#Overview" target="_blank" rel="noopener">维基百科</a> 的例子更合适：</p><p>例如写传统的命令行程序，我们需要展示给用户一些菜单，然后根据用户的选择做相应的操作，于是我们写了一个菜单类，这个菜单类会调用底层的“显示类”来显示菜单内容，监听并返回用户的选择。考虑到之后如果我们将代码移植到图形界面，于是有了一个“GUI显示类”，此时就需要我们修改菜单类来适应之种修改。这是菜单类于显示类间的耦合。</p><p>控制反转认为菜单类的本职工作是提供“菜单”，如何显示，用户选择等不应该该是它的职责（单一职责原则）。因此，最好有一个框架专门管理这种流程，即框架知道显示类的存在，也知晓软件的流程，在需要显示菜单类的时候，它向菜单类索要菜单的内容，向显示类发现显示的指令，得到用户的选择，并调用相关的类来处理。也就是说框架把流程都定好，各个类要做的就是“填空”就行了，菜单类提供菜单内容，显示类提供显示逻辑等等。</p><p>控制反转是把不属于类的职责抽离出来，让一个专门的“第三方”来做处理这些事。所以它的外延其实是很广的，我们常说的 IoC 容器只是一个专门的“第三方”用来处理依赖罢了。</p><h2 id="依赖注入-dependency-injection"><a class="header-anchor" href="#依赖注入-dependency-injection">#</a>依赖注入（Dependency Injection）</h2><p>由于在实际使用和讨论中，大家滥用了 IoC 这个词，因此 Martin Fowler 等人在讨论后确定使用“依赖注入”这个词来代码其中一项具体的技术。而背后的原因是：</p><ol><li>为了保证 DIP 原则，一个类应该只依赖抽象接口。</li><li>于是具体的实现需要由某种方式“注入”到这个类。</li><li>那么依据控制反转的思想，最好是由第三方（容器）来完成。</li></ol><p>而具体又有几种方式：</p><ol><li>constructor injection ，依赖通过构造函数传入</li><li>setter injection，依赖通过一个个 setter 传入</li><li>interface injection，类显示实现一个 setter interface。</li></ol><p>对实现细节感兴趣的话可以看 <a href="https://en.wikipedia.org/wiki/Dependency_injection#Three_types_of_dependency_injection" target="_blank" rel="noopener">维基百科</a>的例子。</p><p>要明白的是依赖注入只是“注入”依赖的其中一种方式（使用最广吧），还有一些其它的方式，例如“依赖查找”（Dependency Lookup），这里就不深入了。</p><p>注意的是依赖注入是只明确 <strong>如何将</strong> 依赖“注入”一个类，而由谁来做并不是 DI 处理的问题，例如在 Python 等其它语言里，我们依旧可以贯彻 DIP，也可以用constructor injection，但与 Java 中使用 IoC 容器来管理不同，Python 中大家很少使用甚至听说 IoC 容器。</p><h2 id="现实中的应用"><a class="header-anchor" href="#现实中的应用">#</a>现实中的应用</h2><p>这部分是看了陈浩的 <a href="https://coolshell.cn/articles/9949.html" target="_blank" rel="noopener">IOC/DIP其实是一种管理思想</a> 后想到的。其实计算机中的许多概念在现实中也是有对应的，按我的理解：</p><ul><li>DIP 相当于“标准化”产品</li><li>IoC 相当于“流水线”化环节</li></ul><p>就比如说一家餐厅用的海鲜全是某个供应商供应的，后来由于店面扩大，想换一家更大供应商，但发现供应商能供应的种类和质量都和之前不同，因此换供应商的同时就要让改菜单，大厨们对一些食材要特殊处理。可见餐厅和之前的供应商耦合太高。</p><p>DIP 告诉我们，餐厅不应该直接依赖某个供应商，而应该规定供应商的标准。要成为自己的供应商，必须能提供什么种类的食材，食材要达到什么标准，这样即使想换供应商，餐厅自己也不需要有任何变化。这时餐厅不是依赖于具体的供应商，而是依赖于制定的供应商标准。</p><p>再比如还是这家餐厅，但它是连锁餐厅，尽管不同的供应商都满足了标准，但每家子餐厅还是自己挑选供应商，而现在总公司决定缩减成本，选择价格更低的供应商，由于每家子餐厅都是自己选择，要实施这个命令就很困难。</p><p>而 IoC 认为餐厅的职责应该是生产食品，而原料的供应、定单的接收乃至食物的配送都不应该是餐厅（或者应该称为厨房）负责的。于是总公司就专门成立一个管理部门，负责管理整个流程，它为每个步骤都创建一个具体的部分，统筹规划。采购部分负责选择供应商，管理部门把得到的原料和定单交给餐厅，餐厅只专注生产。相当于建立了一个流水线，每一个部分都成了流水线的一个步骤，都专注于自己的职责。另一方面，流水线的管理也专注于流程的管理。</p><h2 id="写在最后"><a class="header-anchor" href="#写在最后">#</a>写在最后</h2><p>最后还是想说所有的设计都是在做 trade-off。例如模块化能使软件更容易变化，模块之间能替换，但实际生产中，有多少软件会换自己的数据库呢？再比如说 IoC 其实也要看个度，如果所有的控制流都反转了，那管理起来也会过于复杂。</p><p>吐糟下似乎 Java 的开发者都特别喜欢上来先写个接口，然后写一个实现类。写起来不容易，读起来也费劲，但你要是问起来，大家会说这样有得写单元测试，并且如果需要替换实现类也会更方便。可是实际上，几乎 95% 以上（随便说的数字，实际中一次都没看见过）的类都不会有两个或以上的实现，而测试其实也可以通过生成子类之类的方式来做。</p><p>因此，我想说学习的时候还是要搞懂它要解决什么问题，有什么好处和缺点，这样才能具体问题具体分析。世上没有银弹。</p><h2 id="reference"><a class="header-anchor" href="#reference">#</a>Reference</h2><ul><li><a href="https://www.martinfowler.com/articles/injection.html" target="_blank" rel="noopener">Inversion of Control Containers and the Dependency Injection pattern</a> by Martin Fowler.</li><li><a href="https://martinfowler.com/articles/dipInTheWild.html" target="_blank" rel="noopener">DIP in the wild</a> by Martin Fowler.</li><li><a href="http://www.tutorialsteacher.com/ioc/introduction" target="_blank" rel="noopener">IoC Introduction</a> 对各种概念简短但精辟的解释。</li><li><a href="https://coolshell.cn/articles/9949.html" target="_blank" rel="noopener">IOC/DIP其实是一种管理思想</a> 可以认为是这些思想在现实世界的体现</li><li><a href="https://softwareengineering.stackexchange.com/questions/135971/when-is-it-not-appropriate-to-use-the-dependency-injection-pattern" target="_blank" rel="noopener">When is it not appropriate to use the dependency injection pattern?</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你听过 SOLID 设计原则吗？你了解 Spring 里的控制反转（IoC）吗？你知道依赖注入（Dependency Injection）和它们有什么区别吗？虽然它们的形式多样，但内核却是简单的概念。我们就来看看它们到底是什么。&lt;/p&gt;
&lt;h2 id=&quot;tldr&quot;&gt;&lt;a c
      
    
    </summary>
    
      <category term="Notes" scheme="http://lotabout.github.io/categories/Notes/"/>
    
    
      <category term="SOLID" scheme="http://lotabout.github.io/tags/SOLID/"/>
    
      <category term="Dependency Inversion Principle" scheme="http://lotabout.github.io/tags/Dependency-Inversion-Principle/"/>
    
      <category term="Dependency Injection" scheme="http://lotabout.github.io/tags/Dependency-Injection/"/>
    
      <category term="Inversion of Control" scheme="http://lotabout.github.io/tags/Inversion-of-Control/"/>
    
  </entry>
  
  <entry>
    <title>Java Annotation Processor 小记</title>
    <link href="http://lotabout.github.io/2017/Notes-on-Java-Annotation-Processor/"/>
    <id>http://lotabout.github.io/2017/Notes-on-Java-Annotation-Processor/</id>
    <published>2017-12-31T20:33:19.000Z</published>
    <updated>2018-01-30T13:53:38.939Z</updated>
    
    <content type="html"><![CDATA[<p>最近基于工作上的需求调研了下 Java Annotation Processor 的使用方式，开篇博客记录下学习过程中遇到的坑。可以由于平时用到 Annotation 的场景特别少，因此能搜索到的教程特别有限，也希望文章在某种程度上填补部分空白吧。</p><h2 id="认识-java-annotation"><a class="header-anchor" href="#认识-java-annotation">#</a>认识 Java Annotation</h2><p>Java 里的 Annotation （注解）相信大家都不陌生，从内置的 <code>@Override</code> 到 junit里的 <code>@Test</code> ，再到 lombok 里的 <code>@Getter</code>, <code>@Setter</code> 都是大家常用的注解。之所以叫作“注解”，是因为它就像是我们对代码加上的一种“注解”一般。一般注解可以出现在类、方法、变量、参数及包名上。在编译期或运行时，我们就能找到并使用这些“注解”，并做一些操作。</p><p>这里我以实际的需求为例，代码可以在 Github 上找到：<a href="https://github.com/lotabout/transformer-playground" target="_blank" rel="noopener">transformer-playground</a>。</p><p>在开发中，我们会重复一些代码，例如写一份领域模型 BO (business object)，包括了模型的属性及方法 (OOP)。由于这个模型的信息可能需要发送给其它的领域，而又希望领域模型和具体的表示能隔离，因此常常会创建一份 POJO(Plain Old Java Object)，它的字段和 BO 几乎一致。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicantBo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;EducationVo&gt; educationList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// don't want to go public</span></span><br><span class="line">    <span class="keyword">private</span> ZonedDateTime lastUpdate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicantPojo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;EducationPojo&gt; educationList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此经常需要写一些转换代码，把 BO 转成 Pojo 或者反过来。这时候想起 Java的注解是能实现代码的自动生成的，于是希望能像下面这样的方式来写代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transformer</span>(to = ApplicantPojo.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicantBo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>期待加了这个注解之后，能自动生成一些代码，而不用自己写转换类。这里要说明两个内容：</p><ol><li>一般的 Annotation Processor 能生成新的类，但不能修改现有的类。像 lombok 这种能为类生成新方法的工具其实是直接修改 byte code 实现的。</li><li>Annotation Processor 的一大好处是如果原始的代码发生变化，可以防止自己忘记修改一些对应的类。如 lombok 的 <code>@Getter</code> 可以防止新加字段后忘记加相应的Getter，而上面说的 <code>@Transformer</code> 更可以防止忘记为新字段添加转换逻辑。</li></ol><p>当然，Annotation 的好处还有很多，总的来说，Annotation 赋予了我们更强的表达能力，使我们代码最更少，模块化更高，理解更容易（总得吹一波）。</p><h2 id="项目搭建"><a class="header-anchor" href="#项目搭建">#</a>项目搭建</h2><p>关于 Annotation Processor ，网上已经有相当好的入门教程了，这里我推荐两个：</p><ol><li><a href="https://academy.realm.io/posts/360andev-ryan-harter-eliminate-boilerplate/" target="_blank" rel="noopener">@Eliminate(“Boilerplate”)</a></li><li><a href="http://hannesdorfmann.com/annotation-processing/annotationprocessing101" target="_blank" rel="noopener">ANNOTATION PROCESSING 101</a></li></ol><p>第一个是演讲，基本上能对 Annotation Processor 的基本工作原理能有大概的理解，第二篇则是一个很详细的具体示例。这里我会为自己简要记录下要点。</p><h3 id="目录结构"><a class="header-anchor" href="#目录结构">#</a>目录结构</h3><p>也不知道谁规定的，看到的目标一般都是分两个子模块，一个是 <code>annotation</code> 存放annotation 的定义，另一个是 <code>processor</code>，存放具体生成代码的逻辑。如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── pom.xml</span><br><span class="line">├── transformer-annotations</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src/main/java</span><br><span class="line">│               └── me.lotabout.annotation</span><br><span class="line">│                   └── Transformer.java</span><br><span class="line">└── transformer-processors</span><br><span class="line">    ├── pom.xml</span><br><span class="line">    └── src/main</span><br><span class="line">            ├── java</span><br><span class="line">            │   └── me.lotabout.processor</span><br><span class="line">            │       └── TransformerProcessor.java</span><br><span class="line">            └── resources</span><br><span class="line">                └── META-INF</span><br><span class="line">                    └── services</span><br><span class="line">                        └── javax.annotation.processing.Processor</span><br></pre></td></tr></table></figure><p>其中， <code>javax.annotation.processing.Processor</code> 这个文件的文件名是固定的，我们需要把我们实现了的 Processor （本例中 <code>TransformerProcessor</code>）写到文件里，这样则 javac 在编译过程中才能找到对应的 Processor。文件里每行写一个 Processor 的全限定名。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat javax.annotation.processing.Processor</span><br><span class="line">me.lotabout.processor.TransformerProcessor</span><br></pre></td></tr></table></figure><h3 id="pom-注意点"><a class="header-anchor" href="#pom-注意点">#</a>pom 注意点</h3><p>正常情况下，如果完成了项目的搭建，编译后会报错：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project transformer-processors: Compilation failure</span><br><span class="line">[ERROR] Bad service configuration file, or exception thrown while constructing Processor object: javax.annotation.processing.Processor: Provider me.lotabout.processor.TransformerProcessor not found</span><br><span class="line">[ERROR] -&gt; [Help 1]</span><br></pre></td></tr></table></figure><p>这是因为 javac 在编译时，会用 <code>javax.annotation.processing.Processor</code> 里指定的类去处理源代码，因此 javac 预期在 classpath 里能找到一个编译好的 processor，但这显然是不可能的。要解决这个问题，我们需要显示告诉 javac 为当前项目忽略annotation processing。如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">compilerArgument</span>&gt;</span>-proc:none<span class="tag">&lt;/<span class="name">compilerArgument</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意 <code>-proc:none</code>。参考 <a href="https://stackoverflow.com/questions/36248959/bad-service-configuration-file-or-exception-thrown-while-constructing-processor" target="_blank" rel="noopener">StackOverflow</a>。</p><h3 id="文件内容"><a class="header-anchor" href="#文件内容">#</a>文件内容</h3><p>定义新的注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transformer &#123;</span><br><span class="line">    Class&lt;?&gt;[] from() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;?&gt;[] to() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>用 <code>@interface</code> 定义注解</li><li><code>@Target()</code> 来指定注解允许出现的位置，这里指定 <code>ElementType.TYPE</code> 限制能出现在类型定义上，如 interface, class 上。</li><li><code>@Retention</code> 用于指定注解的保留情况，如 <code>RetentionPolicy.SOURCE</code> 代表这个注解是源代码级别的，编译之后生成 byte code 时注解就会被移除。有一些注解是可以保留到运行时的。</li></ol><p>Annotation Processor 的定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformerProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (SourceVersion.latest().compareTo(SourceVersion.RELEASE_8) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> SourceVersion.latest();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> SourceVersion.RELEASE_8;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ImmutableSet.of(Transformer.class.getCanonicalName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三件套是必须的：</p><ol><li><code>getSupportedSourceVersion</code> 返回支持的版本</li><li><code>getSupportedAnnotationTypes</code> 返回该 Processor 支持的所有注解。换句话说，这里返回的内容将作为 <code>process</code> 函数的第一个参数返回。</li><li><code>process</code> 函数，在这里写代码生成的逻辑。</li></ol><p>最后注意到 <code>extends AbstractProcessor</code>，嗯，这么做就对了。</p><h2 id="model-api"><a class="header-anchor" href="#model-api">#</a>Model API</h2><p>最头疼的莫过于 <code>java.lang.model</code> 的相关 API 了，完全找不到全面的文档。这里记录几个用到的：</p><h3 id="从-typeelement-中获取所有字段或方法"><a class="header-anchor" href="#从-typeelement-中获取所有字段或方法">#</a>从 TypeElement 中获取所有字段或方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;VariableElement&gt; <span class="title">getAllFields</span><span class="params">(TypeElement type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ElementFilter.fieldsIn(type.getEnclosedElements())</span><br><span class="line">            .stream()</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MethodEntry&gt; <span class="title">getAllMethods</span><span class="params">(TypeElement type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ElementFilter.methodsIn(type.getEnclosedElements())</span><br><span class="line">            .stream()</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取字段的类型"><a class="header-anchor" href="#获取字段的类型">#</a>获取字段的类型</h3><p><code>VariableElement</code> 用来表示一个字段，那么如何获取字段的类型呢？</p><p>一个字段的类型可能是基本类型如 <code>int</code>, <code>boolean</code> 之类的，也可能是类如<code>String</code>，还可能包括一 些泛型的类如 <code>List&lt;String&gt;</code>。而 <code>TypeElement</code> 保存的是类型本身的信息，例如，如是一个 <code>TypeElement</code> 表示 <code>List&lt;String&gt;</code>，它其实保存的是 <code>List&lt;T&gt;</code> 的信息，没有办法获取 <code>String</code> 这个具体类型的。</p><p>其实 Java 是用 <code>TypeMirror</code> 来代表一个具体类型的：</p><ol><li><code>variable.asType()</code> 可以获得 <code>variable</code> 的具体类型。</li><li><code>typeMirror.getKind()</code> 可以获知类型的信息，如 <code>int</code> 则是 <code>TypeKind.INT</code>，而所有的类者属于 <code>TypeKind.DECLARED</code>。</li><li><code>(TypeElement)((DeclaredType)typeMirror).asElement()</code> 可以将 TypeMirror 转换为 <code>TypeElement</code>。但如果不是 <code>DECLARED</code> 类型则会出异常。</li><li>如果是泛型，可以通过 <code>((DeclaredType)typeMirror).getTypeArguments()</code> 来得到具体的类型信息。如 <code>List&lt;String&gt;</code> 可以得到 <code>String</code>。</li><li>如果是数组类型，想得到具体的类型信息，如 <code>String[]</code> 想得到 <code>String</code>，则需要通过 <code>((ArrayType)typeMirror).getComponentType()</code> 来获取。</li></ol><h3 id="获取注解中的类"><a class="header-anchor" href="#获取注解中的类">#</a>获取注解中的类</h3><p>例如我们定义的 Transformer 类，它的参数都是 <code>Class[]</code> 类型的。但在编译期间，我们是得不到 <code>Class</code> 信息的，因为这个时候还只有关于源代码的信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transformer &#123;</span><br><span class="line">    Class&lt;?&gt;[] from() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;?&gt;[] to() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，正常情况下我们可能想通过下面的操作来得到 <code>from</code> 的类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Element e : roundEnv.getElementsAnnotatedWith(Transformer.class)) &#123;</span><br><span class="line">        Transformer transformer = e.getAnnotation(Transformer.class);</span><br><span class="line">        Class[] from = transformer.from();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但会有如下错误：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javax.lang.model.type.MirroredTypeException: Attempt to access Class object for TypeMirror java.lang.Runnable</span><br></pre></td></tr></table></figure><p>所以我们只能曲线救国：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;AnnotationMirror&gt; <span class="title">getAnnotationMirror</span><span class="params">(TypeElement element, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    String clazzName = clazz.getName();</span><br><span class="line">    <span class="keyword">for</span>(AnnotationMirror m : element.getAnnotationMirrors()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(m.getAnnotationType().toString().equals(clazzName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.ofNullable(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;AnnotationValue&gt; <span class="title">getAnnotationValue</span><span class="params">(AnnotationMirror annotationMirror, String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; entry : annotationMirror.getElementValues().entrySet() ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(entry.getKey().getSimpleName().toString().equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.ofNullable(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;TypeMirror&gt; <span class="title">getTransformerClasses</span><span class="params">(TypeElement clazz, String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getAnnotationMirror(clazz, Transformer.class)</span><br><span class="line">            .flatMap(annotation -&gt; TypeEntry.getAnnotationValue(annotation, key))</span><br><span class="line">            <span class="comment">// ^ note that annotation value here corresponds to Class[],</span></span><br><span class="line">            .map(annotation -&gt; (List&lt;AnnotationValue&gt;)annotation.getValue())</span><br><span class="line">            .map(fromClasses -&gt; fromClasses.stream()</span><br><span class="line">                    .map(fromClass -&gt; (TypeMirror)fromClass.getValue())</span><br><span class="line">                    .collect(Collectors.toList()))</span><br><span class="line">            .orElse(ImmutableList.of());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题在 <a href="https://area-51.blog/2009/02/13/getting-class-values-from-annotations-in-an-annotationprocessor/" target="_blank" rel="noopener">这篇文章</a> 中有很详细的描述。</p><h2 id="代码生成"><a class="header-anchor" href="#代码生成">#</a>代码生成</h2><p>最后一个内容是代码生成，其实 Annotation Processor 最后是生成 Java 代码，这意味着不论采用任何形式，最终只要把一些字符（Java 源码）写入到一个文件就可以了。实际中有两种方式，各有优缺点。</p><h3 id="模板引擎"><a class="header-anchor" href="#模板引擎">#</a>模板引擎</h3><p>如 <a href="http://velocity.apache.org/" target="_blank" rel="noopener">velocity</a> 或<a href="https://mustache.github.io/" target="_blank" rel="noopener">Mustache</a>。其中 velocity 也是 Intellij 的代码生成功能使用的模板引擎。</p><p>使用模板引擎的好处是代码的结构比较可控，看模板就能大概看出生成的代码长什么样。但一个重要缺点是需要自己导入代码中用到的包，而在 Java 文件中，导入包和实际的代码是在两个区域，这对于生成代码来说很不方面（要是用到了就会有同感了）。另一个小总是是空格处理麻烦，为了保证输出的源代码格式好看，通常需要小心处理模板中的空格（velocity），导致模板很乱。</p><h3 id="javapoet"><a class="header-anchor" href="#javapoet">#</a>JavaPoet</h3><p><a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a> 是各大教程中都提到的 Java 代码生成库，它对常用的 Java 概念（如类，方法，变量等）做了建模，因此我们就能像写代码一样一部分一部分生成 Java 代码。如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MethodSpec main = MethodSpec.methodBuilder(<span class="string">"main"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">    .returns(<span class="keyword">void</span>.class)</span><br><span class="line">    .addParameter(String[].class, <span class="string">"args"</span>)</span><br><span class="line">    .addStatement(<span class="string">"$T.out.println($S)"</span>, System.class, <span class="string">"Hello, JavaPoet!"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">    .addMethod(main)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">JavaFile javaFile = JavaFile.builder(<span class="string">"com.example.helloworld"</span>, helloWorld)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">javaFile.writeTo(System.out);</span><br></pre></td></tr></table></figure><p>会生成下面的代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.example.helloworld;</span><br><span class="line"></span><br><span class="line">public final class HelloWorld &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(&quot;Hello, JavaPoet!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我认为它的主要好处就是自动 import，其它我真不觉得有什么超过模板引擎的地方。但自动 import 这个功能就足以让我在写 <code>@Transformer</code> 的时候使用它而不是 velocity。</p><p>另外注意要使用它的自动 import 功能，需要我们在生成代码时使用 <code>addStatement</code> 并使用 <code>$T</code> 语法来提供类型信息，否则是它是没办法识别文本中的包的。</p><h2 id="写在最后"><a class="header-anchor" href="#写在最后">#</a>写在最后</h2><p>我个人的背景是 C + Lisp 开始的，所以对于元编程(meta-programming) 是有一定执着的，想比于 Lisp，Java 的 Annotation Processor 实在是太蹩脚了。但与此同时，不得不说 Java 的源码结构比 Lisp 的无限括号还是更方便阅读的，并且我自己也很喜欢Annotation 这样的“无入侵”的编程风格的。</p><p>另外元编程也许有点“屠龙之术”吧，不过如果现实中真的有“龙”出现的时候，不要犹豫，祭出“屠龙宝刀”吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近基于工作上的需求调研了下 Java Annotation Processor 的使用方式，开篇博客记录下学习过程中遇到的坑。可以由于平时用到 Annotation 的场景特别少，因此能搜索到的教程特别有限，也希望文章在某种程度上填补部分空白吧。&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="Notes" scheme="http://lotabout.github.io/categories/Notes/"/>
    
    
      <category term="Java" scheme="http://lotabout.github.io/tags/Java/"/>
    
      <category term="Annotation" scheme="http://lotabout.github.io/tags/Annotation/"/>
    
  </entry>
  
  <entry>
    <title>及时获取反馈以提升工作效率</title>
    <link href="http://lotabout.github.io/2017/Shorten-Feedback-Loop/"/>
    <id>http://lotabout.github.io/2017/Shorten-Feedback-Loop/</id>
    <published>2017-11-19T11:27:15.000Z</published>
    <updated>2018-01-30T13:53:38.939Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现自己及整个团队的开发效率低下，思前想后认为跟反馈链太长脱不了干系，于是思考及时反馈的重要性，以及它如何影响我们的效率。这里做一个小结。</p><h2 id="及时反馈为何重要"><a class="header-anchor" href="#及时反馈为何重要">#</a>及时反馈为何重要</h2><ol><li>能减少返工的成本</li><li>能减少等待的时间</li></ol><p>一般情况下，我们并不知道自己前进的方向是否正确，而及时的反馈能让我们迅速调整自己的方向。如果反馈不及时，那到时候返工的成本就大大增加了。</p><img src="/2017/Shorten-Feedback-Loop/feedback-quick-slow.png" title="Feedback Quick or Slow"><p>例如原型设计，其目的就是在于快速得到（客户）对产品功能的反馈。如果已经到达产品阶段再让客户反馈，而客户一旦否决某项功能，则开发该功能的所有花费都将付之一炬。反之如果是原型阶段就被否决，则损失的成本就小得多。</p><p>在另一些情况下，我们会很自觉地等待反馈。例如修改了几行代码，需要运行看看到底改得对不对，这时我们需要得到“正确”的反馈后才能继续前进。这时，得到反馈的快与慢直接就影响了我们等待的时间，从而影响工作的效率。</p><img src="/2017/Shorten-Feedback-Loop/feedback-waiting.png" title="Feedback Waiting"><h2 id="在工作流程上的体现"><a class="header-anchor" href="#在工作流程上的体现">#</a>在工作流程上的体现</h2><h3 id="敏捷开发"><a class="header-anchor" href="#敏捷开发">#</a>敏捷开发</h3><p>首先要说的是“<a href="https://zh.wikipedia.org/wiki/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91" target="_blank" rel="noopener">敏捷开发</a>”，相信现在几乎所有软件开发人员都听说过这个词语，可是它的内涵究竟是什么呢？</p><p>敏捷开发有许多特点（宣言）、方法和工具，这里我要讨论的是它的一些特点：</p><blockquote><p>对我们而言，最重要的是通过 <em>尽早</em> 和 <em>不断交付</em> 有价值的软件满足客户需要。我们欢迎需求的变化，即使在开发后期。敏捷过程能够驾驭变化，保持客户的竞争优势。经常交付可以工作的软件，从几星期到几个月，时间尺度越短越好。</p></blockquote><p>这里敏捷开发的原则中的前 3 项，是要缩短迭代周期，持续交付软件给客户，并拥抱客户的需求变化。那么这些“原则”或“价值观”背后的动机是什么呢？我给自己的答案便是要得到“及时”的反馈。</p><p>而为什么“及时”反馈如此重要？是因为绝大多数时候，客户并无法描述自己的需求，也因此瀑布开发流程越发地无力。客户并没有办法在计划阶段完整地、准确地描述需求，所以往往在交付的时候会与自己的预期出入很大。这也是持续交付和及时反馈的必要性，目的是为了矫正对客户与开发双方对需求的理解。</p><p>现在我认为这些“对外”（客户）的内容比一些“对内”（团队）的方法和工具更加地重要。例如缩短迭代周 期，但产品并没有快速交付给客户，那下个迭代开始时，团队并无法得到客户的反馈，那缩短迭代周期的意义何在？</p><p>也就是说我认为及时反馈就是敏捷开发的核心内涵。</p><h3 id="design-thinking"><a class="header-anchor" href="#design-thinking">#</a>Design Thinking</h3><p>中文译为 <a href="https://zh.wikipedia.org/wiki/%E8%A8%AD%E8%A8%88%E6%80%9D%E8%80%83" target="_blank" rel="noopener">设计思考</a>，它是一个方法论，“透过从人的需求出发，为各种议题寻求创新解决方案，并创造更多的可能性”。</p><p>例如你需要设计一个产品，但却无从下手，那么可以应用 desgin thinking 的方法/流程来按步就班地得到结果：</p><ol><li>Empathy （同理心）：去了解产品的用户，包括体验、问卷、采访等方法来寻找用户的真正需求。</li><li>Define （需求定义）：利用前面收集到的知识做更深入的挖掘，确认用户的真正需求。</li><li>Ideate（创意动脑）：发散思维，找出尽可能多的解决方案，例如头脑风暴，并最终透过不同的投票标准来找出真正合适的解决方案。</li><li>Prototype（制作原型）：制作原型，来将解决方案以某种形式呈现出来，既用作内部交流，之后也会用作测试。</li><li>Test （实际测试）：利用原型与用户沟通，通过情景模拟，测试解决方案是否可用。通过用户的使用，回应等等，重新定义需求或改进解决方案，同时更深入了解使用者。</li></ol><p><img src="https://media.nngroup.com/media/editor/2016/07/29/designthinking_illustration_final-01-01.png" alt="">（上图来来自 <a href="https://www.nngroup.com/articles/design-thinking/" target="_blank" rel="noopener">Design Thinking 101</a>）</p><p>可以看到，Design Thinking 的整个流程就是构建了一个环，一个从定义用户需求，找出解决方案，制作原型并得到用户反馈的环。而我们也可以看到它与“敏捷开发”也有相似的地方，例如制作原型并得到反馈。</p><p>Design Thinking 并不是关于设计，而是解决问题的思维，可以并已经应用到多个领域中，如果读者感兴趣，不妨多做了解。</p><p>当然，仅从上面的流程并看不出 Design Thinking 鼓励“及时”的反馈，但它也有类似敏捷开发的“原则”：</p><blockquote><ol start="2"><li>及早失败：设计思考鼓励及早失败的心态，宁可在早期成本与时间投入相对较少的状况，早点知道失败，并作相对应的修正。如此一来，损失会较已完成一定程度，投入巨大资本的状况更不严重。</li></ol></blockquote><p>这就是及时反馈的其中一个优点，减少返工的成本。</p><h2 id="在编程中的体现"><a class="header-anchor" href="#在编程中的体现">#</a>在编程中的体现</h2><p>上面讲到的工作流程方面的反映，更多是鼓励及早失败。而在实际编程时我们希望的是减少等待反馈的时间。因为等待时间变长，不仅浪费等待的时间，程序员也需要更多的时间恢复（开始等待时）脑中的状态。</p><h3 id="repl"><a class="header-anchor" href="#repl">#</a>REPL</h3><p>如果用到动态语言应该对 REPL 不陌生，例如浏览器的 Console，Python 的命令行解释器，更别提 REPL 始祖 Lisp 的 REPL 了。</p><p>REPL 指的是 Read-Eval-Print-Loop，是一个循环，指的是解释器读入（Read）代码，解释执行（Eval）并打印（Print）出结果这样一个循环。而进一步扩展，可以认为是我们编辑代码(Read)，部署代码(Eval)，并查看结果(Print)的循环。</p><p>一般来说，解释型的语言（如 js/python/ruby/lua）通常提供 REPL，让我们能快速地写一些代码并测试是否可用。而相应的，编译型语言（如 C/C++/Java）则还需要写一些测试用例，编译，运行等等。明显动态语言的反馈更为及时。</p><p>另一方面，相像我们在运行一个 web 程序，现在我们修改了其中的一小段代码，我们需要 确认代码是否正确，怎么做呢？很正常的一个步骤是关掉正在运行的程序，编译修改后的代码，重新启动修改后的程序，再打开对应的网页确认结果。这整个流程是很耗时间的， 所以一些 IDE 就提供了热部署(Hot Swap)的功能，能将修改后的一些类动态地替换到正在运行的 web 程序上，就大大地缩小了反馈的时间，提高工作的效率。</p><p>无独有偶，<a href="https://github.com/bhauman/lein-figwheel" target="_blank" rel="noopener">figwheel</a> 是ClojureScript 的一个库，它可以在前端开发中提供“热部署”的功能。相像你在用 js 写一个 PPT。发现第 10 页的图片位置不对，于是在后台修改了位置。现在想看看结果，于是在浏览器中刷新页面，结果又从第 1 页开始显示，于是需要连点 10 下才能看到结果正确与否。而 figwheel 则支持修改后，切换到浏览器，甚至不需要手工刷新，就能把修改后的结果反映出来。</p><p>我认为这些工具的本质都是在缩短反馈的时间，从而提高效率。换句话说，要想进一步提高效率，可以从缩短反馈时间入手。</p><p>想想我们公司一次测试环境的部署要花近两个小时，无言以对……</p><h3 id="null-检查"><a class="header-anchor" href="#null-检查">#</a>Null 检查</h3><p>这里要讲到另一种反馈，编程中的静态检查。在 Java 开发中，有许多的 bug 是源于没有正确地检查变量是否为 null。甚至它的发明者都说它是 <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare" target="_blank" rel="noopener">值 10 亿美元的错误</a>。</p><p>但我们这里不讲语言的设计，而是说我们如何对待它。在工作中，一般我们都是等到测试出错时才发现有什么地方忘了判断，这对于程序员来说可能没什么，不过是一时不小心，但一般 null 未检查会很严重地影响产品的功能，例如某个功能可能就直接无法使用。</p><p>一些 IDE（如 Intellij）可以对某些情形做些判断并提示变量没有做 null 检查，但多数情况是无法提示的；Kotlin 语言要求使用不同的变量类型来表示某个变量可以为null，如 <code>String</code> 不可为 null，而 <code>String?</code> 则可以为 null，这样就能在编译时给出 error；最后像 Rust 语言在语言层面上去除了 null, 而用标准类型 <code>Option</code> 来指代可以为 <code>None</code> 的类型。</p><p>这里重要的内容是，语言的设计让程序员能在编译期就得到“代码有错”的反馈，而通常如果是在运行时去检查的话，需要花费很多时间才能定位到 bug 所在，特别浪费时间。</p><p>也因此我认为编译期的错误提示是缩短反馈时间的一种体现，并且是提高开发效率的一种很好的方式。再贴一句<a href="https://www.ibm.com/developerworks/community/blogs/beingagile/entry/short_feedback_loops_everywhere?lang=en" target="_blank" rel="noopener">引用</a>：</p><blockquote><p>It has been well understood in software development that the cost to fix adefect increases and in many cases increases dramatically the longer you waitto fix it.</p></blockquote><h2 id="现实中的无奈与突破"><a class="header-anchor" href="#现实中的无奈与突破">#</a>现实中的无奈与突破</h2><p>例如公司如果采用敏捷开发，可能是想利用它能更好应对需求改变的特点，当然也可能是想理所当然压榨员工的时间。但如果是想应对需求改变，那么客户的反馈就是很重要的一环。而现实中想得到客户/用户的反馈也是有很大成本的，例如客户不愿意花时间看成品并填调查问卷。这就是现实中的无奈。</p><p>只是如果一个方法论中的重要一环已经被破除，还有意义继续执行其它的部分吗？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近发现自己及整个团队的开发效率低下，思前想后认为跟反馈链太长脱不了干系，于是思考及时反馈的重要性，以及它如何影响我们的效率。这里做一个小结。&lt;/p&gt;
&lt;h2 id=&quot;及时反馈为何重要&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#及时反馈为何重要&quot;&gt;#
      
    
    </summary>
    
      <category term="Post" scheme="http://lotabout.github.io/categories/Post/"/>
    
    
      <category term="feedback" scheme="http://lotabout.github.io/tags/feedback/"/>
    
      <category term="efficiency" scheme="http://lotabout.github.io/tags/efficiency/"/>
    
  </entry>
  
  <entry>
    <title>估算：古代水稻亩产量</title>
    <link href="http://lotabout.github.io/2017/Estimate-Rice-Production-In-History/"/>
    <id>http://lotabout.github.io/2017/Estimate-Rice-Production-In-History/</id>
    <published>2017-11-03T10:56:24.000Z</published>
    <updated>2018-01-30T13:53:38.923Z</updated>
    
    <content type="html"><![CDATA[<p>用了金克垃，亩产一千八。古代没有金克垃，亩产有多少？有你现有的常识，能估算出来吗？</p><h2 id="估算思路"><a class="header-anchor" href="#估算思路">#</a>估算思路</h2><p>想想这就是求“单价”的问题，如果知道了生产的总量，加上有多少亩，就能求出亩产了。</p><p>一想，有个说法是“一亩三分地”，于是先假设一户人家能有 1.3 亩地。那么剩下的就是求一户人家能产多少粮食。</p><p>于是反向思考，一户人家要消耗多少粮食。</p><p>记得大学食堂里一顿饭一般女生 2 两，男生 3 两。古代人肯定没有米饭吃，只能喝稀粥；但考虑劳动量消耗大，于是算一个人一天 2 两米（估计实际消耗更小）。再假设一家有 5 口人。于是一户人家一天消耗 1 斤米。</p><p>考虑种一季水稻，于是一年 365 天，需要消耗 365 斤米。再考虑交租交税，于是假设剩下的 0.3 亩产出都拿来交租交税了，于是得到结果：亩产 365 斤。</p><h2 id="查阅资料"><a class="header-anchor" href="#查阅资料">#</a>查阅资料</h2><p>只是大概搜索了一下，不保证权威。并且古代很多东西没有详细记录，这里引用 <a href="http://economy.guoxue.com/?p=8272" target="_blank" rel="noopener">十九世纪上半期的中国粮食亩产量及总产量再估计</a>：</p><blockquote><p>基于此，笔者认为，根据表2，可以将嘉、道事例的平均数即3.2石作为其时南方稻作平均亩产的高限，而据清代全部事例和清前期事例分别计算出的两个平均数，即亩产3石或稍多，则可以作为当时南方稻作平均亩产量估计值的低限。这个产量区间，换算为近代市制大约为每市亩438－468市斤[⑦]，合公制约为每公顷3285－3510公斤。</p></blockquote><p>如果按亩产 <code>(438+468)/2=453</code> 来看，我们得到的结果是偏差 <code>(453-365)/453 = 19.4%</code>，不能算差。</p><p>再仔细验证了下上面的模型，发现了一些更有意思情况。</p><p>引用知乎问题 <a href="https://www.zhihu.com/question/46817892/answer/149544202" target="_blank" rel="noopener">工业化之前的全国平均粮食亩产最高能有多少？ - 膝盖中箭周公瑾的回答 - 知乎</a>：</p><p><img src="https://pic2.zhimg.com/50/v2-7979c0a6265afd120ff4b480c0a62c89_hd.jpg" alt=""></p><p>可以看到土地改革之前，“一亩三分地”已经是属于“佃富农”到“中农”的阶级了，而如果用这个事实更新我们的模型，意味着一家人供养的人大于 5 人的可能性会变高。如果算是父母 + 两个女儿 + 三个儿子共 7 口人计算，则需要亩产 <code>0.2 * 7 * 365 = 511</code> 斤。就多出了平均亩产 12%。</p><p>前面我们按剩下的 0.3 亩产出用于交租交税，则意味着 <code>0.3/1.3 = 23%</code> 的租税，那实际情况如何呢？依旧引用知乎的回答（下图及上图）：</p><p><img src="https://pic3.zhimg.com/50/v2-73328885fffb89dac2eed1e790f47eea_hd.jpg" alt=""></p><blockquote><p>一般每石租谷 8 斗到 1 石，相当于年产量的 70 ～ 80%</p></blockquote><p>换句话说，一家 7 口人，如果按 70% 的租税，租 1.3 亩地，亩均产量 453 斤，每天能食用的粮食为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">453 * 1.3 * 0.3 / 7 / 365 = 0.07 斤</span><br></pre></td></tr></table></figure><p>当然，基础数据不一定准确，且人们肯定不只是食用大米。但这样的估算也能侧面反映出当时农民的贫穷生活。</p><h2 id="小结"><a class="header-anchor" href="#小结">#</a>小结</h2><p>估算，个人觉得十分有趣，如何用一些常识和简单的测量、演算逼进真正的结论。通常考验的是人们的建模的能力。这里仅仅是作为一个分享，当然如果你有更好的估算思路，也不妨分享分享。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用了金克垃，亩产一千八。古代没有金克垃，亩产有多少？有你现有的常识，能估算出来吗？&lt;/p&gt;
&lt;h2 id=&quot;估算思路&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#估算思路&quot;&gt;#&lt;/a&gt;估算思路&lt;/h2&gt;
&lt;p&gt;想想这就是求“单价”的问题，如果知道了生产
      
    
    </summary>
    
      <category term="Tweet" scheme="http://lotabout.github.io/categories/Tweet/"/>
    
    
      <category term="Estimation" scheme="http://lotabout.github.io/tags/Estimation/"/>
    
  </entry>
  
  <entry>
    <title>CSS 子元素依次收缩的实现</title>
    <link href="http://lotabout.github.io/2017/flex-shrink-in-order/"/>
    <id>http://lotabout.github.io/2017/flex-shrink-in-order/</id>
    <published>2017-09-29T21:27:49.000Z</published>
    <updated>2018-01-30T13:53:38.955Z</updated>
    
    <content type="html"><![CDATA[<p>当子元素的宽度（或高度）超过父元素时，如果父元素设置了 <code>display: flex</code>，则子元素将按比例缩小自己的宽度（或高度），但现在我们希望子元素按一定的优先级缩小。即：当宽度不足时，优先缩小某一个子元素，当达到该元素的最小宽度（<code>min-width</code>）时，再开始缩小另外的元素。下面是一个示例图：</p><img src="/2017/flex-shrink-in-order/expected.gif" title="Expected Behavior"><p>可以看到，当宽度不足时，上例中优先缩小了最右的元素，当最右元素达到最小宽度100px 时开始缩小左边的元素，依此类推。</p><a id="more"></a><p>本文我们将分析 flexbox 中的 <code>flex-shrink</code> 属性，来实现上述效果。本文假设你熟悉 flexbox 的基本用法。</p><h2 id="基本设置"><a class="header-anchor" href="#基本设置">#</a>基本设置</h2><p>话不多说，先把主要的框架搭上，参见下面的 <a href="https://jsfiddle.net/lotabout/xozxdz3z/6/" target="_blank" rel="noopener">jsfiddle</a>：</p><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/lotabout/xozxdz3z/6/embedded/result,html,css,js/light" frameborder="0" allowfullscreen></iframe><p>在上面的例子中，只设置了父元素为 <code>display: flex</code> 及第一个元素为 <code>flex: none</code>，即不参与 flexbox 的伸缩的计算，只占与它本身宽度相同的宽度。</p><p>如果在输入框中输入，可以看到：当宽度不足时，三个子元素一起收缩，出现 <code>...</code> 字样。这是因为，flex 元素的子元素的默认 flex 设置为 <code>flex: 0 1 auto</code>。即收缩的比值为 <code>1</code>。</p><p>题外话，设置 <code>flex</code> 属性相当于设置 3 个值，即 <code>flex: flex-grow, flex-shrink, flex-basis</code>。所以官方提倡直接设置 <code>flex</code> 属性而不是分别设置三个。</p><h2 id="内置的支持？"><a class="header-anchor" href="#内置的支持？">#</a>内置的支持？</h2><p>我们通过查找文档发现，<code>flex-shrink</code> 的作用是指定缩小的系数，即如果一个元素 A的 <code>flex-shrink: 2</code> 而元素 B 为 <code>flex-shrink: 1</code>，当需要缩小 30px 才能不超出父元素宽度时，A 与 B 按 <code>2:1</code> 收缩，即 A 元素缩小 20px 而 B 元素缩小 10px。</p><p>这样看来，<code>flex-shrink</code> 并不适合我们上面所说的任务。因为只要设置了flex-shrink，那么元素就一定会缩小，也就达不到前文需要的效果了。</p><p>也许你从标题里也猜到了，是的，flexbox 并没有提供任何机制，来设置伸缩的优先级。所以我们只能进一步思考，如何才能做到？</p><h2 id="合适的比例？"><a class="header-anchor" href="#合适的比例？">#</a>合适的比例？</h2><p>于是我们的第一反应就是：如果把其中一个元素的 <code>flex-shrink</code> 设置得很大，而另一个很小不就可以了？嗯，有道理！于是我们先忽略第二个子元素，将它设置为<code>flex:none</code>，第三个元素设置为 <code>flex: 0 1</code>，第四个元素 <code>flex: 0 1000</code>，即它的缩小的系数是第三个元素的 1000 倍！</p><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/lotabout/xozxdz3z/8/embedded/result,html,css,js/light" frameborder="0" allowfullscreen></iframe><p>输上几个字符，居然就成功了！</p><p>然后如果仔细观察输入的情况，会发现输入到一定长度时，虽然最后一个元素还没有达到<code>min-width</code>，第三个元素也发生了收缩：</p><img src="/2017/flex-shrink-in-order/wrong.gif" title="Wrong Answer"><p>难道是缩小系数还不够大？调成 10000 试试。还真的就成功了！但为什么 1000/1 不够大，而 10000/1 就能正常工作；需要多大的比例还能实现一个元素优先收缩的效果？</p><h2 id="flex-shrink-如何计算？"><a class="header-anchor" href="#flex-shrink-如何计算？">#</a>flex-shrink 如何计算？</h2><p>显然我们之前据说的计算方法是错误的，那 <code>flex-shrink</code> 真正的作用方式如何呢？</p><p>这里引述一个教程：<a href="http://madebymike.com.au/writing/understanding-flexbox/" target="_blank" rel="noopener">understandingflexbox</a> 的例子。</p><p>首先，缩放的系数是由 <code>flex-shrink</code> 的值乘于 <code>flex-basis</code> 的值共同决定的，而这么做的原因即使指定了相同的 <code>flex-shrink</code>，较大的元素（较大的 basis）也会显得收缩了更多，也符合人的直观印象。</p><p>得到这个比例之后，再除于所有子元素的系数之和作为最终的缩小的比例，用这个比例乘于总共需要缩小的宽度，就是该元素需要缩小的宽度了。还是看看例子吧：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.flex-container&#123; width: 600px; &#125;</span><br><span class="line">.flex-item-1&#123; flex-basis: 100px; flex-shrink: 1; &#125;</span><br><span class="line">.flex-item-2&#123; flex-basis: 400px; flex-shrink: 1; &#125;</span><br><span class="line">.flex-item-3&#123; flex-basis: 400px; flex-shrink: 1; &#125;</span><br><span class="line">Total basis: 900px</span><br><span class="line">Space remaining: -300px</span><br><span class="line">Item 1 shrink factor: (1×100) / (100px + 400px + 400px) = .111 × -300px = -33.333px</span><br><span class="line">Item 2 shrink factor: (1×400) / (100px + 400px + 400px) = .444 × -300px = -133.333px</span><br><span class="line">Item 3 shrink factor: (1×400) / (100px + 400px + 400px) = .444 × -300px = -133.333px</span><br></pre></td></tr></table></figure><h2 id="宽度可以是小数？"><a class="header-anchor" href="#宽度可以是小数？">#</a>宽度可以是小数？</h2><p>我们知道 CSS 的最小单位是像素，即 <code>px</code>，那计算出来的小数有何作用？经过一番搜索，又学习到了新的知识：<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="noopener">getBoundingClientRect()</a>，它可以返回一个 DOM 元素的位置和大小信息，最为重要的是，它返回信息的类型是 <strong>浮点型</strong>！这意味着浏览器是需要存储小数级别的信息的！</p><p>我们打印出了一些信息：</p><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/lotabout/xozxdz3z/10/embedded/result,html,css,js/light" frameborder="0" allowfullscreen></iframe><p>下面是在我本机上得到的输出结果，下面是在第三个元素缩小之前：</p><img src="/2017/flex-shrink-in-order/before-shrink.png" title="Before Shrink"><p>下面是第三个元素缩小之后：</p><img src="/2017/flex-shrink-in-order/after-shrink.png" title="After Shrink"><p>上面这两张图只能对比第三个元素的信息，这里直接说下，在第四个元素收缩之前，它的大小是 <code>191px</code>。在第三个元素收缩时（即变成 <code>...</code>）时：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">总宽度: 600px (去掉父元素的 border 2px)</span><br><span class="line">总缩小宽度：600-60-176-186-191 = -13px</span><br><span class="line">第3个元素的 shrink factor: (1×186)    / (186px + 1000×191px)</span><br><span class="line">                           = 0.00094674680015273484 × -13px = -0.01230770840198555292px</span><br><span class="line">第4个元素的 shrink factor: (1000×191) / (186px + 1000×191px)</span><br><span class="line">                           = 0.99905325319984726515 * -13px = -12.98769229159801444695px</span><br></pre></td></tr></table></figure><p>因此，计算后第 3 个元素的宽度为 <code>186 - 0.01230770840198555292 = 185.98769229159801444708</code> 并不等于图片中的结果 <code>185.98333740234375</code>。恭喜，发现了一个很深的坑。</p><p>问题其实在于，浏览器会保留多少精度。这是一个没有标准定义的内容，叫作 “subpixelrendering”。一个简单的例子就是指定 3 个 <code>width: 33.33333%</code> 的 div 时，由于精度问题，浏览器可能并不会占满 100%。</p><p>那精度到底是多少呢？这个精度叫作<a href="http://trac.webkit.org/wiki/LayoutUnit" target="_blank" rel="noopener">LayoutUnit</a>，Chrome 是 <code>1/64px</code>，而Firefox 是 <code>1/60px</code>。</p><p>我们这里取整：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">185.98769229159801444708 * 60</span><br><span class="line">=&gt; 11159.26153749588086682480</span><br><span class="line">11159 / 60</span><br><span class="line">=&gt; 185.98333333333333333333</span><br></pre></td></tr></table></figure><p>当然，由于 <code>1/60</code> 的精度是无限的，还是会有精度丢失，这里看到 <code>185.98 &lt; 186</code>因此导致元素 3 发生了 overflow。</p><p>最后，如果你愿意计算，这个 flex-shrink 的大小是跟各个元素的宽度相关的，在这个特定的例子里，假设元素 3 宽度为 <code>a</code>，元素 4 宽度为 <code>b</code>，元素 4 的 <code>min-width</code>为 <code>c</code>，则要使元素 3 保持正常，则要满足 <code>a/(a + bx) * (b-c) &lt; 1/60</code>，即使 a元素缩小的量小于一个 LayoutUnit，即 <code>x &gt; (60*a*(b-c) -a)/b</code>，算得约 5316。</p><p>当然，由于我们输入的字符并不是 1px 的，所以可能相差几倍也不太重要。</p><h2 id="小结"><a class="header-anchor" href="#小结">#</a>小结</h2><ol><li>想让子元素按优先级收缩，可以通过设置大倍率的 flex-shrink 完成。</li><li>flex-shrink 的算法与 flex-grow 不同，需要先与 flex-basis 相乘得到 shrinkfactor。</li><li>浏览器的 pixel 最小单位称为 LayoutUnit，Chrome 为 <code>1/64px</code>，Firefox 为<code>1/60px</code>。</li></ol><h2 id="扩展阅读"><a class="header-anchor" href="#扩展阅读">#</a>扩展阅读</h2><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-shrink" target="_blank" rel="noopener">MDN: flex-shrink</a></li><li><a href="http://madebymike.com.au/writing/understanding-flexbox/" target="_blank" rel="noopener">Understanding Flexbox</a></li><li><a href="http://cruft.io/posts/percentage-calculations-in-ie/" target="_blank" rel="noopener">Browser Rounding and Fractional Pixels</a></li><li><a href="http://trac.webkit.org/wiki/LayoutUnit" target="_blank" rel="noopener">LayoutUnit</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当子元素的宽度（或高度）超过父元素时，如果父元素设置了 &lt;code&gt;display: flex&lt;/code&gt;，则子
元素将按比例缩小自己的宽度（或高度），但现在我们希望子元素按一定的优先级缩小。
即：当宽度不足时，优先缩小某一个子元素，当达到该元素的最小宽度（&lt;code&gt;min-width&lt;/code&gt;）
时，再开始缩小另外的元素。下面是一个示例图：&lt;/p&gt;
&lt;img src=&quot;/2017/flex-shrink-in-order/expected.gif&quot; title=&quot;Expected Behavior&quot;&gt;
&lt;p&gt;可以看到，当宽度不足时，上例中优先缩小了最右的元素，当最右元素达到最小宽度
100px 时开始缩小左边的元素，依此类推。&lt;/p&gt;
    
    </summary>
    
      <category term="Knowledge" scheme="http://lotabout.github.io/categories/Knowledge/"/>
    
    
      <category term="flex-shrink" scheme="http://lotabout.github.io/tags/flex-shrink/"/>
    
      <category term="css" scheme="http://lotabout.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Python Decorator(装饰器)</title>
    <link href="http://lotabout.github.io/2017/Python-Decorator/"/>
    <id>http://lotabout.github.io/2017/Python-Decorator/</id>
    <published>2017-09-29T09:23:41.000Z</published>
    <updated>2018-01-30T13:53:38.939Z</updated>
    
    <content type="html"><![CDATA[<p>今天来说说 Python 里的装饰器 (decorator)。它不难，但却几乎是 “精通” Python 的路上的第一道关卡。让我们来看看它到底是什么东西，为什么我们需要它。</p><h2 id="手写装饰器"><a class="header-anchor" href="#手写装饰器">#</a>手写装饰器</h2><p>现在我们要写一个函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure><p>然后我们想看看运行的结果，于是写了几个 print 语句：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"add(10)"</span>,       add(<span class="number">10</span>))</span><br><span class="line">print(<span class="string">"add(20, 30)"</span>,   add(<span class="number">20</span>, <span class="number">30</span>))</span><br><span class="line">print(<span class="string">"add('a', 'b')"</span>, add(<span class="string">'a'</span>, <span class="string">'b'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Results:</span></span><br><span class="line"><span class="comment"># add(10) 20</span></span><br><span class="line"><span class="comment"># add(20, 30) 50</span></span><br><span class="line"><span class="comment"># add('a', 'b') ab</span></span><br></pre></td></tr></table></figure><p>现在我们想看看测试这个函数的性能，于是我们加上这个代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">before = time()</span><br><span class="line">print(<span class="string">"add(10)"</span>,       add(<span class="number">10</span>))</span><br><span class="line">after = time()</span><br><span class="line">print(<span class="string">"time taken: &#123;&#125;"</span>.format(after - before))</span><br><span class="line"></span><br><span class="line">before = time()</span><br><span class="line">print(<span class="string">"add(20, 30)"</span>,   add(<span class="number">20</span>, <span class="number">30</span>))</span><br><span class="line">after = time()</span><br><span class="line">print(<span class="string">"time taken: &#123;&#125;"</span>.format(after - before))</span><br><span class="line"></span><br><span class="line">before = time()</span><br><span class="line">print(<span class="string">"add('a', 'b')"</span>, add(<span class="string">'a'</span>, <span class="string">'b'</span>))</span><br><span class="line">after = time()</span><br><span class="line">print(<span class="string">"time taken: &#123;&#125;"</span>.format(after - before))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Results</span></span><br><span class="line"><span class="comment"># add(10) 20</span></span><br><span class="line"><span class="comment"># time taken: 0.00017189979553222656</span></span><br><span class="line"><span class="comment"># add(20, 30) 50</span></span><br><span class="line"><span class="comment"># time taken: 9.751319885253906e-05</span></span><br><span class="line"><span class="comment"># add('a', 'b') ab</span></span><br><span class="line"><span class="comment"># time taken: 0.00012969970703125</span></span><br></pre></td></tr></table></figure><p>代码马上变得很复杂。但最重要的是，我们得写一堆代码（复制粘贴），程序员是懒惰的，所以我们就想到一些更简单的方法，与其写这么多次，我们可以只写一次代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y=<span class="number">10</span>)</span>:</span></span><br><span class="line">    before = time()</span><br><span class="line">    result = x + y</span><br><span class="line">    after = time()</span><br><span class="line">    print(<span class="string">'elapsed: '</span>, after - before)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">print(<span class="string">"add(10)"</span>,       add(<span class="number">10</span>))</span><br><span class="line">print(<span class="string">"add(20, 30)"</span>,   add(<span class="number">20</span>, <span class="number">30</span>))</span><br><span class="line">print(<span class="string">"add('a', 'b')"</span>, add(<span class="string">'a'</span>, <span class="string">'b'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Results</span></span><br><span class="line"><span class="comment"># elapsed:  1.9073486328125e-06</span></span><br><span class="line"><span class="comment"># add(10) 20</span></span><br><span class="line"><span class="comment"># elapsed:  9.5367431640625e-07</span></span><br><span class="line"><span class="comment"># add(20, 30) 50</span></span><br><span class="line"><span class="comment"># elapsed:  1.9073486328125e-06</span></span><br><span class="line"><span class="comment"># add('a', 'b') ab</span></span><br></pre></td></tr></table></figure><p>不论是代码的修改量还是代码的美观程度，都比之前的版本要好！</p><p>但是，现在我们写了另一个函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(x, y=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x - y</span><br></pre></td></tr></table></figure><p>我们必须再为 <code>sub</code> 函数加上和 <code>add</code> 相同的性能测试代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(x, y=<span class="number">10</span>)</span>:</span></span><br><span class="line">    before = time()</span><br><span class="line">    result = x - y</span><br><span class="line">    after = time()</span><br><span class="line">    print(<span class="string">'elapsed: '</span>, after - before)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>作为一个懒惰的程序员，我们立马就发现了，有一个 “模式” 反复出现，即执行一个函数，并计算这个函数的执行时间。于是我们就可以把这个模式抽象出来，用函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func, x, y = <span class="number">10</span>)</span>:</span></span><br><span class="line">    before = time()</span><br><span class="line">    result = func(x, y)</span><br><span class="line">    after = time()</span><br><span class="line">    print(<span class="string">"elapsed: "</span>, after - before)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y = <span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(x, y = <span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line"></span><br><span class="line">print(<span class="string">"add(10)"</span>, timer(add, <span class="number">10</span>))</span><br><span class="line">print(<span class="string">"add(20, 30)"</span>, timer(add, <span class="number">20</span>, <span class="number">30</span>))</span><br></pre></td></tr></table></figure><p>但这样还是很麻烦，因为我们得改到所有的测试用例，把 <code>add(20, 30)</code> 改成<code>timer(add, 20, 30)</code>。于是我们进一步改进，让 timer 返回函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wraper</span><span class="params">(x, y=<span class="number">10</span>)</span>:</span></span><br><span class="line">        before = time()</span><br><span class="line">        result = func(x, y)</span><br><span class="line">        after = time()</span><br><span class="line">        print(<span class="string">"elapsed: "</span>, after - before)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wraper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y = <span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">add = timer(add)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(x, y = <span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line">sub = timer(sub)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"add(10)"</span>,       add(<span class="number">10</span>))</span><br><span class="line">print(<span class="string">"add(20, 30)"</span>,   add(<span class="number">20</span>, <span class="number">30</span>))</span><br></pre></td></tr></table></figure><p>这里的最后一个问题是，我们的 timer 包装的函数可能有不同的参数，于是我们可以进一步用 <code>*args, **kwargs</code> 来传递参数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wraper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        before = time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        after = time()</span><br><span class="line">        print(<span class="string">"elapsed: "</span>, after - before)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wraper</span><br></pre></td></tr></table></figure><p>这里的 <code>timer</code> 函数就是一个 “装饰器”，它接受一个函数，并返回一个新的函数。在装饰器的内部，对原函数进行了“包装”。</p><p>注：上面的例子取自 <a href="https://youtu.be/7lmCu8wz8ro?t=45m25s" target="_blank" rel="noopener">What Does it Take to Be an Expert At Python</a>。</p><h2 id="语法糖"><a class="header-anchor" href="#语法糖">#</a>@ 语法糖</h2><p>上一节是一个懒惰的程序员用原生的 Python 写的装饰器，但在装饰器的使用上，用的是这个代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y = <span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">add = timer(add)        <span class="comment"># &lt;- notice this</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(x, y = <span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line">sub = timer(sub)</span><br></pre></td></tr></table></figure><p>上面这个语句里，我们把 <code>add</code> 的名字重复了 3 次，如果函数改了名字，我们就得改 3处。懒惰的程序员就想了一个更“好”的方法，提供了一个语法来替换上面的内容：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure><p>这就是我们最常见的装饰器的形式了，这两种写法完全等价，只是 <code>@</code> 写法更简洁一些。</p><h2 id="带参数的装饰器"><a class="header-anchor" href="#带参数的装饰器">#</a>带参数的装饰器</h2><p>我们知道下面两种代码是等价的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@dec</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(...)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">func = dec(func)</span><br></pre></td></tr></table></figure><p>我们可以把它当成是纯文本的替换，于是可以是这样的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@dec(arg)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(...)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">func = dec(arg)(func)</span><br></pre></td></tr></table></figure><p>这也就是我们看到的“带参数”的装饰器。可见，只要 <code>dec(arg)</code> 的返回值满足 “装饰器” 的定义即可。（接受一个函数，并返回一个新的函数）</p><p>这里举一个例子（<a href="https://foofish.net/python-decorator.html" target="_blank" rel="noopener">来源</a>）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> level == <span class="string">"warn"</span>:</span><br><span class="line">                logging.warn(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">            <span class="keyword">elif</span> level == <span class="string">"info"</span>:</span><br><span class="line">                logging.info(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">            <span class="keyword">return</span> func(*args)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging(level="warn")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name=<span class="string">'foo'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">"i am %s"</span> % name)</span><br></pre></td></tr></table></figure><p>先不管 <code>use_logging</code> 长什么样，先关心它的返回值 <code>decorator</code>，看到 <code>decorator</code>本身是一个函数，并且参数是函数，返回值是函数，于是确认 <code>decorator</code> 是一个 “装饰器”。于是上面这种“带参数的装饰器”的作用也就很直接了。</p><h2 id="类作为装饰器"><a class="header-anchor" href="#类作为装饰器">#</a>类作为装饰器</h2><p>如果说 Python 里一切都是对象的话，那函数怎么表示成对象呢？其实只需要一个类实现<code>__call__</code> 方法即可。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self._func = func</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        before = time()</span><br><span class="line">        result = self._func(*args, **kwargs)</span><br><span class="line">        after = time()</span><br><span class="line">        print(<span class="string">"elapsed: "</span>, after - before)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="meta">@Timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure><p>也就是说把类的构造函数当成了一个装饰器，它接受一个函数作为参数，并返回了一个对象，而由于对象实现了 <code>__call__</code> 方法，因此返回的对象相当于返回了一个函数。因此该类的构造函数就是一个装饰器。</p><h2 id="小结"><a class="header-anchor" href="#小结">#</a>小结</h2><p>装饰器中还有一些其它的话题，例如装饰器中元信息的丢失，如何在类及类的方法上使用装饰器等。但本文里我们主要目的是简单介绍装饰器的原因及一般的使用方法，能用上的地方就大胆地用上吧！</p><h2 id="扩展阅读"><a class="header-anchor" href="#扩展阅读">#</a>扩展阅读</h2><ul><li>[PEP 0318 – Decorators for Functions and Methods](PEP 0318 – Decorators for Functions and Methods)</li><li><a href="http://python-3-patterns-idioms-test.readthedocs.io/en/latest/PythonDecorators.html" target="_blank" rel="noopener">Python Decorator in Detail</a></li><li><a href="https://youtu.be/7lmCu8wz8ro?t=45m25s" target="_blank" rel="noopener">What Does it Take to Be an Expert At Python</a></li><li><a href="https://foofish.net/python-decorator.html" target="_blank" rel="noopener">理解 Python 装饰器看这一篇就够了</a></li><li><a href="http://blog.dscpl.com.au/2014/01/how-you-implemented-your-python.html" target="_blank" rel="noopener">How you implemented your Python decorator is wrong</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天来说说 Python 里的装饰器 (decorator)。它不难，但却几乎是 “精通” Python 的路上的第一道关卡。让我们来看看它到底是什么东西，为什么我们需要它。&lt;/p&gt;
&lt;h2 id=&quot;手写装饰器&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=
      
    
    </summary>
    
    
      <category term="python" scheme="http://lotabout.github.io/tags/python/"/>
    
      <category term="decorator" scheme="http://lotabout.github.io/tags/decorator/"/>
    
  </entry>
  
  <entry>
    <title>Underscore.js 源码阅读</title>
    <link href="http://lotabout.github.io/2017/underscore-source-code-comment/"/>
    <id>http://lotabout.github.io/2017/underscore-source-code-comment/</id>
    <published>2017-09-24T09:27:34.000Z</published>
    <updated>2018-01-30T13:53:38.971Z</updated>
    
    <content type="html"><![CDATA[<p>（这是两年前的笔记，现在把它搬到博客上，Underscore 版本：1.8.3）</p><p>受 <a href="http://web.jobbole.com/83872/" target="_blank" rel="noopener">这篇文章</a> 的启发,萌生阅读 underscore.js 源码的念头,其中有许多不理解的地方,也是读了上述文章后才明白的.为了保持本文的完整性,也尽量按自己的理解进行注释. 不再提及上述引用文章.</p><a id="more"></a><h2 id="目录"><a class="header-anchor" href="#目录">#</a>目录</h2><ul><li><a href="#%E5%85%A8%E5%B1%80%E5%AE%9A%E4%B9%89">全局定义</a></li><li><a href="#%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8">链式调用</a></li><li><a href="#%E6%8E%A5%E5%89%8D%E6%96%87">接前文</a></li><li><a href="#Collection-%E5%87%BD%E6%95%B0">Collection 函数</a></li><li><a href="#%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%E7%9A%84%E5%87%BD%E6%95%B0">函数相关的函数</a></li><li><a href="#Object-%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0">Object 相关函数</a></li><li><a href="#%E7%9B%B8%E7%AD%89%E5%88%A4%E6%96%AD">相等判断</a></li><li><a href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD">类型判断</a></li><li><a href="#template">template</a></li></ul><h2 id="全局定义"><a class="header-anchor" href="#全局定义">#</a>全局定义</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><p>underscore.js 中通过自执行函数来防止打乱已有的命令空间中的变量.这样函数中定义的所有变量在外部都是不可见的.但是仍旧需要以某种方式来导出其中定义的变量.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Establish the root object, `window` (`self`) in the browser, `global`</span></span><br><span class="line"><span class="comment">// on the server, or `this` in some virtual machines. We use `self`</span></span><br><span class="line"><span class="comment">// instead of `window` for `WebWorker` support.</span></span><br><span class="line"><span class="keyword">var</span> root = <span class="keyword">typeof</span> self == <span class="string">'object'</span> &amp;&amp; self.self === self &amp;&amp; self ||</span><br><span class="line">        <span class="keyword">typeof</span> global == <span class="string">'object'</span> &amp;&amp; global.global === global &amp;&amp; global ||</span><br><span class="line">        <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure><p><code>root</code> 变量的作用是用来捕捉外部环境. 由于在自执行函数中,<code>this</code> 变量会被设置成<code>Window</code> (浏览器中),所以我们可能通过为 <code>this</code> (即此处的<code>root</code>) 添加相应的变量来导出函数. 如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.exported_var = <span class="number">10</span></span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.exported_var);</span><br><span class="line"><span class="comment">// =&gt; 10</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Save bytes in the minified (but not gzipped) version:</span></span><br><span class="line"><span class="keyword">var</span> ArrayProto = <span class="built_in">Array</span>.prototype, ObjProto = <span class="built_in">Object</span>.prototype;</span><br></pre></td></tr></table></figure><p>为了减少 JS 代码在网络传输中占用的流量,通常要对其进行压缩,以减少源代码的大小.方法之一是替换现有的变量名.将 <code>Array.prototype</code> 赋值给新变量,就允许我们对该变量进行重命名.例如: <code>ArrayProto.toString =&gt; a.toString</code> 而若使用诸如<code>Array.prototype.toString =&gt; a.prototype.toString</code> 则找不到该函数.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create quick reference variables for speed access to core prototypes.</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">  push = ArrayProto.push,</span><br><span class="line">  slice = ArrayProto.slice,</span><br><span class="line">  toString = ObjProto.toString,</span><br><span class="line">  hasOwnProperty = ObjProto.hasOwnProperty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// All **ECMAScript 5** native function implementations that we hope to use</span></span><br><span class="line"><span class="comment">// are declared here.</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">  nativeIsArray = <span class="built_in">Array</span>.isArray,</span><br><span class="line">  nativeKeys = <span class="built_in">Object</span>.keys,</span><br><span class="line">  nativeCreate = <span class="built_in">Object</span>.create;</span><br></pre></td></tr></table></figure><p>以上同理.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Naked function reference for surrogate-prototype-swapping.</span><br><span class="line">var Ctor = function()&#123;&#125;;</span><br></pre></td></tr></table></figure><p><code>Ctor</code> 函数只有一个用途,就是为了兼容老版本 JavaScript 的继承,即用来实现<code>Object.create</code> 函数.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SubClass.prototype = Object.create(SuperClass.prototype)</span><br><span class="line">// 等价于</span><br><span class="line">var ctor = function () &#123;&#125;</span><br><span class="line">ctor.prototype = SuperClass.prototype;</span><br><span class="line">SubClass.prototype = new ctor();</span><br></pre></td></tr></table></figure><p><code>Ctor</code> 在之后的 <code>baseCreate</code> 函数中使用.</p><h2 id="链式调用"><a class="header-anchor" href="#链式调用">#</a>链式调用</h2><p>因为涉及的内容较多,所以归成一节.</p><p>首先,我们要明白什么是链式调用.简单地说,链式调用是方便我们写代码的一个手段,看下面的例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x = obj.method_O();</span><br><span class="line">var y = x.method_X();</span><br><span class="line">var z = y.method_Y();</span><br><span class="line">z.method_Z();</span><br></pre></td></tr></table></figure><p>上述写法需要许多中间变量,由于对象 <code>obj</code> 的 <code>method_O</code> 方法正好返回一个类 <code>X</code>的对象(这里指的是返回的变量 <code>x</code> 需要有 <code>method_X</code> 方法),所以可以直接调用 <code>X</code> 的方法 <code>method_X()</code>. 以此类推.因此我们可以省略其中的中间变量,写成:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">obj.method_O().method_X().method_Y().method_Z();</span><br></pre></td></tr></table></figure><p>要达到上述效果,我们便需要让 <code>method_O()</code> 方法在结束时返回一个类 <code>X</code> 的对象:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method_O</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="keyword">new</span> X(); <span class="comment">// 创建一个 `X` 的对象返回</span></span><br><span class="line">    一些逻辑处理</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以此类推.上述方法是 Javascript 原生支持的.现在的问题在于,例如调用 <code>method_X</code>方法返回了 <code>Y</code> 的对象,就再也无法使用类 <code>X</code> 中的方法了.例如:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var flattened_obj = _([[1,2]]).flatten();</span><br><span class="line">flattened_obj.each(...) // 出错</span><br></pre></td></tr></table></figure><p>上述代码中我们首先创建了一个 underscore.js 的对象 <code>_([[1,2]])</code> 目的是使用underscore.js 为我们提供的丰富辅助函数.之后我们调用 underscore.js 中的<code>flatten</code> 函数得到一个扁平化的数组: <code>[1,2]</code>. 之后我们想在其中调用underscore.js 的 <code>each</code> 函数. 此时报错,提示没有该函数.故此时我们无法使用链式调用:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_([[1,2]]).flatten().each(...) // 报错</span><br></pre></td></tr></table></figure><p>故而 underscore.js 需要提供一些机制来包裹返回的对象,使之能访问 underscore.js中的函数.</p><p>underscore.js 中通过 <code>_.chain(obj)</code> 来返回一个包裹的 <code>_</code> 对象;再对underscore.js 中提供的所有函数做特殊的处理,使得:当调用函数的是包裹的对象时,返回的结果也是一个 <code>_</code> 的对象,而由于 underscore.js 中的所有函数都存放在 <code>_</code>中,所以调用链中的每一步都可以访问 underscore.js 中的函数.</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_.chain([[1,2]]) instanceof _; // =&gt; true</span><br><span class="line">_.chain([[1,2]]).flatten() instanceof _; // =&gt; true</span><br><span class="line">_([[1,2]]).flatten() instanceof _; // =&gt; false</span><br></pre></td></tr></table></figure><h3 id="链式调用的实现"><a class="header-anchor" href="#链式调用的实现">#</a>链式调用的实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Create a safe reference to the Underscore object for use below.</span><br><span class="line">var _ = function(obj) &#123;</span><br><span class="line">  if (obj instanceof _) return obj;</span><br><span class="line">  if (!(this instanceof _)) return new _(obj);</span><br><span class="line">  this._wrapped = obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Add a &quot;chain&quot; function. Start chaining a wrapped Underscore object.</span><br><span class="line">_.chain = function(obj) &#123;</span><br><span class="line">  var instance = _(obj);</span><br><span class="line">  instance._chain = true;</span><br><span class="line">  return instance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的函数可以看到 <code>_</code> 函数生成一个新的 <code>_</code> 对象,并将输入的 <code>obj</code> 置于<code>this._wrapped</code> 中. 而 <code>_.chain</code> 函数则再设置 <code>this._chain = true</code> 的标志.</p><p>单凭上述两个函数并没有实际用途,因此需要一个辅助函数:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Helper function to continue chaining intermediate results.</span><br><span class="line">var chainResult = function(instance, obj) &#123;</span><br><span class="line">  return instance._chain ? _(obj).chain() : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该函数检查 <code>instacne</code> 本身是否设置了 <code>_chain</code> 标志,若是则将 <code>obj</code> 用 <code>chain()</code>包裹,它的作用就是对调用链上函数返回的结果进行处理,如 <code>x.method()</code> 中,若设置了 <code>_chain</code> 标志,则将 <code>x.method()</code> 的返回结果再用 <code>chain()</code> 包裹.这样调用链中的每个函数返回的都是一个 <code>_</code> 的对象,因此也就能继续访问类 <code>_</code> 的方法了.</p><p>还有一个问题是,即使有以上函数, underscore.js 在定义新的函数时仍需手工调用<code>chainResult</code> 函数,十分麻烦. 所以 underscore.js 又提供了另一个辅助函数,将所有已有的函数进行包裹:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Add your own custom functions to the Underscore object.</span><br><span class="line">_.mixin = function(obj) &#123;</span><br><span class="line">  _.each(_.functions(obj), function(name) &#123;</span><br><span class="line">    var func = _[name] = obj[name];</span><br><span class="line">    _.prototype[name] = function() &#123;</span><br><span class="line">      var args = [this._wrapped];</span><br><span class="line">      push.apply(args, arguments);</span><br><span class="line">      return chainResult(this, func.apply(_, args));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Add all of the Underscore functions to the wrapper object.</span><br><span class="line">_.mixin(_);</span><br></pre></td></tr></table></figure><p>该函数将 <code>obj</code> 中的所有函数替换成包裹后的函数.首先取出 <code>_</code> 对象中包裹的实际值, <code>push.apply(args, arguments)</code> 将该值与现有的函数参数结合,最后对原函数的返回值进行处理: <code>chainResult(this, func.apply(_, args))</code>.</p><p>还有一些函数单独作了处理,如 <code>pop</code>, <code>push</code>, <code>reverse</code>, 等等,此处不再详谈.</p><h2 id="接前文"><a class="header-anchor" href="#接前文">#</a>接前文</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Export the Underscore object for **Node.js**, with</span></span><br><span class="line"><span class="comment">// backwards-compatibility for their old module API. If we're in</span></span><br><span class="line"><span class="comment">// the browser, add `_` as a global object.</span></span><br><span class="line"><span class="comment">// (`nodeType` is checked to ensure that `module`</span></span><br><span class="line"><span class="comment">// and `exports` are not HTML elements.)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> exports != <span class="string">'undefined'</span> &amp;&amp; !exports.nodeType) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> != <span class="string">'undefined'</span> &amp;&amp; !<span class="built_in">module</span>.nodeType &amp;&amp; <span class="built_in">module</span>.exports) &#123;</span><br><span class="line">    exports = <span class="built_in">module</span>.exports = _;</span><br><span class="line">  &#125;</span><br><span class="line">  exports._ = _;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  root._ = _;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Current version.</span></span><br><span class="line">_.VERSION = <span class="string">'1.8.3'</span>;</span><br></pre></td></tr></table></figure><p>上文较好理解，判断不同的平台，导出 <code>_</code> 变量。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Internal function that returns an efficient (for current engines) version</span></span><br><span class="line"><span class="comment">// of the passed-in callback, to be repeatedly applied in other Underscore</span></span><br><span class="line"><span class="comment">// functions.</span></span><br><span class="line"><span class="keyword">var</span> optimizeCb = <span class="function"><span class="keyword">function</span>(<span class="params">func, context, argCount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> func;</span><br><span class="line">  <span class="keyword">switch</span> (argCount == <span class="literal">null</span> ? <span class="number">3</span> : argCount) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> func.call(context, value);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// The 2-parameter case has been omitted only because no current consumers</span></span><br><span class="line">    <span class="comment">// made use of it.</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value, index, collection</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> func.call(context, value, index, collection);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">accumulator, value, index, collection</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> func.call(context, accumulator, value, index, collection);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> func.apply(context, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要理解 <code>optimizeCb</code> 的作用，需要先理解 underscore.js 提供的 context 切换的功能。我们首先查看 <code>_.each</code> 的文档：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">each: _.each(list, iteratee, [context]) Alias: forEach</span><br></pre></td></tr></table></figure><p>它接收额外的参数 <code>context</code>。而它的作用是在 <code>iteratee</code> 函数中将 <code>this</code> 指向<code>context</code>。下面的是一个<a href="http://stackoverflow.com/questions/4946456/underscore-js-eachlist-iterator-context-what-is-context" target="_blank" rel="noopener">StackOverflow</a>的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> someOtherArray = [<span class="string">"name"</span>,<span class="string">"patrick"</span>,<span class="string">"d"</span>,<span class="string">"w"</span>];</span><br><span class="line"></span><br><span class="line">_.each([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 函数内， this “等于” someOtherArray</span></span><br><span class="line"></span><br><span class="line">    alert( <span class="keyword">this</span>[num] ); <span class="comment">// num is the value from the array being iterated</span></span><br><span class="line">                        <span class="comment">//    so this[num] gets the item at the "num" index of</span></span><br><span class="line">                        <span class="comment">//    someOtherArray.</span></span><br><span class="line">&#125;, someOtherArray);</span><br></pre></td></tr></table></figure><p>关于 context 的具体应用可以参考 <a href="https://medium.com/@jedschneider/the-secret-life-of-context-in-underscore-and-lodash-722ce3e24608#.l4kxy31d5" target="_blank" rel="noopener">这篇文章</a></p><p>为了切换 <code>this</code> 的实际值，我们需要做如下的工作：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> origin = <span class="function"><span class="keyword">function</span>(<span class="params">arg ...</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> withContext = orig.call(context, arg ...);</span><br></pre></td></tr></table></figure><p>即通过 <code>function.call(...)</code> 的方式来调用函数，以传入新的 <code>this</code> 值。而<code>optimizeCb</code> 函数便是 underscore.js 内部用于完成这个转换的辅助函数。</p><p><code>optimizeCb</code> 函数中判断了目标函数 <code>func</code> 的参数个数，返回不同的函数，如果参数的个数不是 1～4，则采用通用的逻辑 <code>func.apply</code> 代替 <code>func.call</code>。似乎对当前的引擎而言，<code>func.call</code> 要稍快于 <code>func.apply</code>。 <a href="https://jsperf.com/function-calls-direct-vs-apply-vs-call-vs-bind/6" target="_blank" rel="noopener">这个网页</a> 用于测试各种调用方式的效率，在我本机测试下 <code>call</code> 要稍快于（7％） <code>apply</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A mostly-internal function to generate callbacks that can be applied</span></span><br><span class="line"><span class="comment">// to each element in a collection, returning the desired result — either</span></span><br><span class="line"><span class="comment">// `identity`, an arbitrary callback, a property matcher, or a property accessor.</span></span><br><span class="line"><span class="keyword">var</span> cb = <span class="function"><span class="keyword">function</span>(<span class="params">value, context, argCount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span>) <span class="keyword">return</span> _.identity;</span><br><span class="line">  <span class="keyword">if</span> (_.isFunction(value)) <span class="keyword">return</span> optimizeCb(value, context, argCount);</span><br><span class="line">  <span class="keyword">if</span> (_.isObject(value)) <span class="keyword">return</span> _.matcher(value);</span><br><span class="line">  <span class="keyword">return</span> _.property(value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">_.iteratee = <span class="function"><span class="keyword">function</span>(<span class="params">value, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> cb(value, context, <span class="literal">Infinity</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>cb</code> 几乎只被内部函数使用，用途是根据 <code>value</code> 的类型生成回调函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)</span></span><br><span class="line"><span class="comment">// This accumulates the arguments passed into an array, after a given index.</span></span><br><span class="line"><span class="keyword">var</span> restArgs = <span class="function"><span class="keyword">function</span>(<span class="params">func, startIndex</span>) </span>&#123;</span><br><span class="line">  startIndex = startIndex == <span class="literal">null</span> ? func.length - <span class="number">1</span> : +startIndex;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = <span class="built_in">Math</span>.max(<span class="built_in">arguments</span>.length - startIndex, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">var</span> rest = <span class="built_in">Array</span>(length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">      rest[index] = <span class="built_in">arguments</span>[index + startIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (startIndex) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, rest);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">0</span>], rest);</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> func.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>[<span class="number">0</span>], <span class="built_in">arguments</span>[<span class="number">1</span>], rest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>(startIndex + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; startIndex; index++) &#123;</span><br><span class="line">      args[index] = <span class="built_in">arguments</span>[index];</span><br><span class="line">    &#125;</span><br><span class="line">    args[startIndex] = rest;</span><br><span class="line">    <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>restArgs</code> 也只在内部使用，它用来实现类似其它语言（及ES6）的 <code>rest</code> 参数。rest参数的作用是将多余的参数以数组（Array）的方式保存为最后一个参数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b, rest</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>) =&gt; a: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">rest</span>: [],</span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) =&gt; a: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">rest</span>: [<span class="number">3</span>],</span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) =&gt; a: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">rest</span>: [<span class="number">3</span>, <span class="number">4</span>],</span><br></pre></td></tr></table></figure><p>当然，JavaScript 并不直接支持（ES6 前）这样的语法，所以 underscore.js 自己实现了一个（JavaScript 真强大啊！）。有了 <code>restArgs</code> 我的就能写成：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">orig</span>(<span class="params">a, b, rest</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = restArgs(orig, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>) =&gt; a: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">rest</span>: [],</span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) =&gt; a: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">rest</span>: [<span class="number">3</span>],</span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) =&gt; a: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">rest</span>: [<span class="number">3</span>, <span class="number">4</span>],</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An internal function for creating a new object that inherits from another.</span></span><br><span class="line"><span class="keyword">var</span> baseCreate = <span class="function"><span class="keyword">function</span>(<span class="params">prototype</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!_.isObject(prototype)) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (nativeCreate) <span class="keyword">return</span> nativeCreate(prototype);</span><br><span class="line">  Ctor.prototype = prototype;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">new</span> Ctor;</span><br><span class="line">  Ctor.prototype = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>baseCreate</code> 与 <code>Object.create(...)</code> 等价，只是老版本的 JavaScript 没有<code>Object.create</code> 函数，因此用它来做兼容。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> property = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj == <span class="literal">null</span> ? <span class="keyword">void</span> <span class="number">0</span> : obj[key];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper for collection methods to determine whether a collection</span></span><br><span class="line"><span class="comment">// should be iterated as an array or as an object.</span></span><br><span class="line"><span class="comment">// Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength</span></span><br><span class="line"><span class="comment">// Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094</span></span><br><span class="line"><span class="keyword">var</span> MAX_ARRAY_INDEX = <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> getLength = property(<span class="string">'length'</span>);</span><br><span class="line"><span class="keyword">var</span> isArrayLike = <span class="function"><span class="keyword">function</span>(<span class="params">collection</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = getLength(collection);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> length == <span class="string">'number'</span> &amp;&amp; length &gt;= <span class="number">0</span> &amp;&amp; length &lt;= MAX_ARRAY_INDEX;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>isArrayLike</code> 用来判断一个 collection 是否是“类数组”的，那什么是“类数组”呢？需要满足两个条件：</p><ol><li>元素可以通过编号访问</li><li>元素个数通过 <code>length</code> 属性得到。</li></ol><p>“类数组” 不要求有数组（Array）提供的函数，如 <code>push</code>, <code>forEach</code> 及 <code>indexOf</code>. 例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arrayLikeCollection = &#123;&#125;</span><br><span class="line">arrayLikeCollection[0] = 0</span><br><span class="line">arrayLikeCollection[1] = 10;</span><br><span class="line">arrayLikeCollection[2] = 20;</span><br><span class="line">arrayLikeCollection[3] = 30;</span><br><span class="line">arrayLikeCollection.length = 4;</span><br></pre></td></tr></table></figure><p>所以，underscore.js 中定义的 <code>isArrayLike</code> 并没有真正检查条件1。条件 2 在先前的版本中是通过 <code>obj.length === +obj.length</code> 完成的，但似乎在某些情况下有 BUG，于是改成了当前的版本。</p><h2 id="collection-函数"><a class="header-anchor" href="#collection-函数">#</a>Collection 函数</h2><p>本节中讲的是一些 collection 的辅助函数，如 <code>map</code>, <code>each</code>, <code>reduce</code> 等等。这些函数常用于函数式编程语言（如 Haskell）中，它们能更好地描述 collection 的一些操作。在编程中，我们要学习利用这些函数，学会从 collection 的整体角度进行思考，而不以 collection 中的元素作为处理对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The cornerstone, an `each` implementation, aka `forEach`.</span></span><br><span class="line"><span class="comment">// Handles raw objects in addition to array-likes. Treats all</span></span><br><span class="line"><span class="comment">// sparse array-likes as if they were dense.</span></span><br><span class="line">_.each = _.forEach = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">  iteratee = optimizeCb(iteratee, context);</span><br><span class="line">  <span class="keyword">var</span> i, length;</span><br><span class="line">  <span class="keyword">if</span> (isArrayLike(obj)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, length = obj.length; i &lt; length; i++) &#123;</span><br><span class="line">      iteratee(obj[i], i, obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> keys = _.keys(obj);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, length = keys.length; i &lt; length; i++) &#123;</span><br><span class="line">      iteratee(obj[keys[i]], keys[i], obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the results of applying the iteratee to each element.</span></span><br><span class="line">_.map = _.collect = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">  iteratee = cb(iteratee, context);</span><br><span class="line">  <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class="line">      length = (keys || obj).length,</span><br><span class="line">      results = <span class="built_in">Array</span>(length);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; length; index++) &#123;</span><br><span class="line">    <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</span><br><span class="line">    results[index] = iteratee(obj[currentKey], currentKey, obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>_.each</code> 函数是 collection 相关函数的基石，它的作用是将函数 <code>iteratee</code> 应用于collection 中的每个元素，而 <code>map</code> 函数将 <code>iteratee</code> 每次调用的结果收集，以一个数组返回。</p><p>注意的是 <code>_.each</code> 与 <code>_.map</code> 同时支持以 “类数组”及 collection。在underscore.js 中，通常将 object 抽象成 “广义的数组”。广义的数组包含一个键数组 <code>keys</code> 和一个值数组 <code>values</code>，它们一一对应，而由于它们是数组，也因此可以通过索引进行访问。对于普通的“类数组”，键数组中包含的就是对应值的索引。</p><p>所以，在涉及到索引相关的运算时，underscore.js 通常会先获取键数组，如 <code>_.map</code>函数中的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取键数组</span></span><br><span class="line"><span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class="line">length = (keys || obj).length,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">var</span> currentKey = keys ? keys[index] : index;</span><br></pre></td></tr></table></figure><p>相应的，如果涉及值运算时，underscore.js 通常会先取得它的值数组：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj = isArrayLike(obj) ? obj : _.values(obj);</span><br></pre></td></tr></table></figure><p>这个模式中 underscore.js 中被多次运用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a reducing function iterating left or right.</span></span><br><span class="line"><span class="keyword">var</span> createReduce = <span class="function"><span class="keyword">function</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Optimized iterator function as using arguments.length</span></span><br><span class="line">  <span class="comment">// in the main function will deoptimize the, see #1991.</span></span><br><span class="line">  <span class="keyword">var</span> reducer = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, initial</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</span><br><span class="line">        length = (keys || obj).length,</span><br><span class="line">        index = dir &gt; <span class="number">0</span> ? <span class="number">0</span> : length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!initial) &#123;</span><br><span class="line">      memo = obj[keys ? keys[index] : index];</span><br><span class="line">      index += dir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; index &gt;= <span class="number">0</span> &amp;&amp; index &lt; length; index += dir) &#123;</span><br><span class="line">      <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</span><br><span class="line">      memo = iteratee(memo, obj[currentKey], currentKey, obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> initial = <span class="built_in">arguments</span>.length &gt;= <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> reducer(obj, optimizeCb(iteratee, context, <span class="number">4</span>), memo, initial);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// **Reduce** builds up a single result from a list of values, aka `inject`,</span></span><br><span class="line"><span class="comment">// or `foldl`.</span></span><br><span class="line">_.reduce = _.foldl = _.inject = createReduce(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The right-associative version of reduce, also known as `foldr`.</span></span><br><span class="line">_.reduceRight = _.foldr = createReduce(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><p>与 <code>_.map</code> 一样，<code>_.reduce</code> 也是函数式编程语言中常用的辅助函数，上面的代码较乱，下面是一个更为简单的实现，用以演示核心的逻辑。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reduce</span>(<span class="params">coll, func, init_val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; coll.length; i++) &#123;</span><br><span class="line">    init_val = func(init_val, coll[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> init_val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum = reduce([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="keyword">function</span>(<span class="params">memo, num</span>)</span>&#123; <span class="keyword">return</span> memo + num; &#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// =&gt; 6</span></span><br></pre></td></tr></table></figure><p>这里的实现使用了两个闭包，<a href="http://web.jobbole.com/83872/" target="_blank" rel="noopener">这篇文章</a> 认为这里闭包的作用是持久化变量。但我认为，这里将逻辑分成两个函数的目的，如注释所说的，是为了提高执行的效率。即使主逻辑中不包含对<code>arguments.length</code>的使用，但具体为何能提高效率，还有待学习。</p><p><code>_.find</code>, <code>_.filter</code>, <code>_.reject</code>, <code>_.every</code>, <code>_.some</code> 等函数中规中矩，唯一要注意的是它们是如何同时处理 collection 和“类数组”的情况。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> group = <span class="function"><span class="keyword">function</span>(<span class="params">behavior, partition</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = partition ? [[], []] : &#123;&#125;;</span><br><span class="line">    iteratee = cb(iteratee, context);</span><br><span class="line">    _.each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> key = iteratee(value, index, obj);</span><br><span class="line">      behavior(result, value, key);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>group</code> 函数稍微难理解一些，它只在 underscore 内部使用。函数的主要复杂性来源于参数 <code>partition</code>，它用来标记 <code>group</code> 返回的函数返回结果的类型。我认为这是一个不恰当的抽象，一个更直观的抽象应该是（这里不考虑 context 切换的问题）：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> simpleGroup = <span class="function"><span class="keyword">function</span>(<span class="params">behavior</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">        _.each(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> key = iteratee(value, index, obj);</span><br><span class="line">            behavior(result, value, key);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>即对于 <code>obj</code> 中的每个元素，通过调用 <code>iteratee</code> 函数得到一个分组的依据 <code>key</code>，再调用 <code>behavior</code> 对返回的结果进行组装。如 <code>_.groupBy</code> 函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Groups the object's values by a criterion. Pass either a string attribute</span></span><br><span class="line"><span class="comment">// to group by, or a function that returns the criterion.</span></span><br><span class="line">_.groupBy = group(<span class="function"><span class="keyword">function</span>(<span class="params">result, value, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_.has(result, key)) result[key].push(value); <span class="keyword">else</span> result[key] = [value];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>它的 <code>behavior</code> 函数就是将 <code>iteratee</code> 调用后的结果 <code>value</code> 按 <code>key</code> 进行分组。</p><p>上面提到，<code>group</code> 由于支持 <code>partition</code> 带来了额外的复杂性，具体的调用如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.partition = group(<span class="function"><span class="keyword">function</span>(<span class="params">result, value, pass</span>) </span>&#123;</span><br><span class="line">  result[pass ? <span class="number">0</span> : <span class="number">1</span>].push(value);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>而其实该函数可以由 <code>_.groupBy</code> 实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.partition = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = _.groupBy(obj, iteratee);</span><br><span class="line">    <span class="keyword">return</span> [result[<span class="literal">true</span>], result[<span class="literal">false</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Generator function to create the findIndex and findLastIndex functions</span></span><br><span class="line"><span class="keyword">var</span> createPredicateIndexFinder = <span class="function"><span class="keyword">function</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">array, predicate, context</span>) </span>&#123;</span><br><span class="line">    predicate = cb(predicate, context);</span><br><span class="line">    <span class="keyword">var</span> length = getLength(array);</span><br><span class="line">    <span class="keyword">var</span> index = dir &gt; <span class="number">0</span> ? <span class="number">0</span> : length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; index &gt;= <span class="number">0</span> &amp;&amp; index &lt; length; index += dir) &#123;</span><br><span class="line">      <span class="keyword">if</span> (predicate(array[index], index, array)) <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the first index on an array-like that passes a predicate test</span></span><br><span class="line">_.findIndex = createPredicateIndexFinder(<span class="number">1</span>);</span><br><span class="line">_.findLastIndex = createPredicateIndexFinder(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><p><code>createPredicateIndexFinder</code> 根据指定的步长 <code>dir</code> 创建遍历的函数。而实际上它在被用来创建 <code>_.findIndex</code> 和 <code>_.findLastIndex</code>，但无疑，这增加了许多阅读上的复杂度。当一个逻辑没有被很多使用时，是否需要独立成一个单独的模块，值得思考与讨论。</p><h2 id="函数相关的函数"><a class="header-anchor" href="#函数相关的函数">#</a>函数相关的函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Determines whether to execute a function as a constructor</span></span><br><span class="line"><span class="comment">// or a normal function with the provided arguments</span></span><br><span class="line"><span class="keyword">var</span> executeBound = <span class="function"><span class="keyword">function</span>(<span class="params">sourceFunc, boundFunc, context, callingContext, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(callingContext <span class="keyword">instanceof</span> boundFunc)) <span class="keyword">return</span> sourceFunc.apply(context, args);</span><br><span class="line">  <span class="keyword">var</span> self = baseCreate(sourceFunc.prototype);</span><br><span class="line">  <span class="keyword">var</span> result = sourceFunc.apply(self, args);</span><br><span class="line">  <span class="keyword">if</span> (_.isObject(result)) <span class="keyword">return</span> result;</span><br><span class="line">  <span class="keyword">return</span> self;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a function bound to a given object (assigning `this`, and arguments,</span></span><br><span class="line"><span class="comment">// optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if</span></span><br><span class="line"><span class="comment">// available.</span></span><br><span class="line">_.bind = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">func, context, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!_.isFunction(func)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Bind must be called on a function'</span>);</span><br><span class="line">  <span class="keyword">var</span> bound = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">callArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> executeBound(func, bound, context, <span class="keyword">this</span>, args.concat(callArgs));</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> bound;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里，我们首先回顾一下 <code>restArgs(func, startIndex)</code> 默认的使用方法。当参数<code>startIndex</code> 为空时，它默认为 <code>func</code> 参数个数减一。所以有：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function orig(a, b, rest) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var test = restArgs(orig);</span><br><span class="line"></span><br><span class="line">test(1, 2) =&gt; a: 1, b: 2, rest: [],</span><br><span class="line">test(1, 2, 3) =&gt; a: 1, b: 2, rest: [3],</span><br><span class="line">test(1, 2, 3, 4) =&gt; a: 1, b: 2, rest: [3, 4],</span><br><span class="line">// 即此时 test 的多余参数都将收集成一个数组，作为 orig 调用里的 rest 参数</span><br></pre></td></tr></table></figure><p>知道了这点就不难看懂 <code>_.bind</code> 与 <code>executeBound</code>函数。还有一点需要深追的是条件判断：<code>(!(callingContext instanceof boundFunc))</code>，它的作用是什么呢？</p><p>其实 <code>_.bind</code> 是要实现 ECMA5 中的 <code>Function.bind</code> 类似的功能，我们从 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener">MDN</a> 上截取 <code>bind</code> 函数的一个使用实例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.x = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  x: <span class="number">81</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.getX(); <span class="comment">// 81</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> retrieveX = <span class="built_in">module</span>.getX;</span><br><span class="line">retrieveX(); <span class="comment">// 9, because in this case, "this" refers to the global object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new function with 'this' bound to module</span></span><br><span class="line"><span class="comment">//New programmers (like myself) might confuse the global var getX with module's property getX</span></span><br><span class="line"><span class="keyword">var</span> boundGetX = retrieveX.bind(<span class="built_in">module</span>);</span><br><span class="line"><span class="comment">// var boundGetX = _.bind(retrieveX, module); // underscore.js 相应的替代方法。</span></span><br><span class="line">boundGetX(); <span class="comment">// 81</span></span><br></pre></td></tr></table></figure><p>上述例子在执行时，<code>callingContext</code> 指向的是全局的 <code>Window</code>（浏览器中）。而只有当我们创建一个新的该函数的对象时，才会出现 <code>callingContent instanceof boundFunc</code> 的情形：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> boundGetX(); <span class="comment">// 或者</span></span><br><span class="line">boundGetX.apply(instance);</span><br></pre></td></tr></table></figure><p>这是由 <code>new</code> 操作符的特性导致的。一般来说，获取一个函数（类）的一个实例“只能”通过 <code>new</code> 操作符来完成。<code>new func(...)</code> 执行了三个步骤：</p><ol><li>创建一个新的对象，该对象继承了 <code>func.prototype</code>；</li><li>以新创建的对象为 <code>this</code> 调用构造函数 <code>func</code>；</li><li>如果 <code>func</code> 有返回值则返回它，若没有，则返回第1步创建的对象。</li></ol><p>以代码来说就是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newObj = <span class="built_in">Object</span>.create(func.prototype);</span><br><span class="line"><span class="keyword">var</span> result = func.apply(newObj, ...args...);</span><br><span class="line"><span class="keyword">if</span> (result <span class="keyword">instanceof</span> object) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，在上述例子中 <code>func.apply</code> 的过程中，<code>this</code> 指针必须要指向 <code>newObj</code> 而不能指向先前绑定的 <code>context</code> 值。所以 <code>executeBound</code> 判断了这一情况，并实现了类似 <code>new</code> 操作符的逻辑。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Partially apply a function by creating a version that has had some of its</span></span><br><span class="line"><span class="comment">// arguments pre-filled, without changing its dynamic `this` context. _ acts</span></span><br><span class="line"><span class="comment">// as a placeholder by default, allowing any combination of arguments to be</span></span><br><span class="line"><span class="comment">// pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.</span></span><br><span class="line">_.partial = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">func, boundArgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> placeholder = _.partial.placeholder;</span><br><span class="line">  <span class="keyword">var</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> position = <span class="number">0</span>, length = boundArgs.length;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>(length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      args[i] = boundArgs[i] === placeholder ? <span class="built_in">arguments</span>[position++] : boundArgs[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (position &lt; <span class="built_in">arguments</span>.length) args.push(<span class="built_in">arguments</span>[position++]);</span><br><span class="line">    <span class="keyword">return</span> executeBound(func, bound, <span class="keyword">this</span>, <span class="keyword">this</span>, args);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> bound;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">_.partial.placeholder = _;</span><br></pre></td></tr></table></figure><p><code>partial</code> 函数类似于科里化（curry），但功能更加强大。关键在于支持占位符。如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subtract = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> b - a; &#125;;</span><br><span class="line">subFrom20 = _.partial(subtract, _, <span class="number">20</span>);</span><br><span class="line">subFrom20(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// =&gt; 15</span></span><br></pre></td></tr></table></figure><p>并且，由于要支持占位符，所以每次执行 <code>_.partial</code> 返回的函数，它的内部都要访问<code>_.partial</code> 定义时的参数，无形中降低了一些效率。即：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">args[i] = boundArgs[i] === placeholder ? <span class="built_in">arguments</span>[position++] : boundArgs[i];</span><br></pre></td></tr></table></figure><p><code>_.throttle</code> 和 <code>_.debounce</code> 函数都比较有意思。其中 <code>_.throttle</code> 将对一个函数进行包裹，返回一个函数，当我们迅速调用该函数时，在一个的时间范围内，至多被调用一次。可以实验以下代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inc = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"out&gt;&gt; "</span>, x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yyy = _.throttle(inc, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迅速调用 n 次</span></span><br><span class="line">yyy(); <span class="comment">// =&gt; out&gt;&gt; 1, 1</span></span><br><span class="line">yyy(); <span class="comment">// =&gt; 1</span></span><br><span class="line">yyy(); <span class="comment">// =&gt; 1</span></span><br><span class="line">yyy(); <span class="comment">// 3s 后 =&gt; out&gt;&gt; 2, 2</span></span><br></pre></td></tr></table></figure><p>可以看到在 3s 内它只会被调用一次，且在这个时间范围内，调用直接返回前一次调用得到的结果，而不实际执行函数。</p><p><code>_.debound(func, wait)</code> 正好相反，如果执行了某个函数后，在 <code>wait</code> 时间内，若再调用该函数，则不执行它，并且将等待时间置零，直到 <code>wait</code> 时间后才继续执行。</p><h2 id="object-相关函数"><a class="header-anchor" href="#object-相关函数">#</a>Object 相关函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Keys in IE &lt; 9 that won't be iterated by `for key in ...` and thus missed.</span></span><br><span class="line"><span class="keyword">var</span> hasEnumBug = !&#123;<span class="attr">toString</span>: <span class="literal">null</span>&#125;.propertyIsEnumerable(<span class="string">'toString'</span>);</span><br><span class="line"><span class="keyword">var</span> nonEnumerableProps = [<span class="string">'valueOf'</span>, <span class="string">'isPrototypeOf'</span>, <span class="string">'toString'</span>,</span><br><span class="line">                    <span class="string">'propertyIsEnumerable'</span>, <span class="string">'hasOwnProperty'</span>, <span class="string">'toLocaleString'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> collectNonEnumProps = <span class="function"><span class="keyword">function</span>(<span class="params">obj, keys</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nonEnumIdx = nonEnumerableProps.length;</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">constructor</span> = obj.<span class="keyword">constructor</span>;</span><br><span class="line">  var proto = _.isFunction(<span class="keyword">constructor</span>) &amp;&amp; <span class="keyword">constructor</span>.prototype || ObjProto;</span><br><span class="line"></span><br><span class="line">  // Constructor is a special case.</span><br><span class="line">  var prop = '<span class="keyword">constructor</span>';</span><br><span class="line">  if (_.has(obj, prop) &amp;&amp; !_.contains(keys, prop)) keys.push(prop);</span><br><span class="line"></span><br><span class="line">  while (nonEnumIdx--) &#123;</span><br><span class="line">    prop = nonEnumerableProps[nonEnumIdx];</span><br><span class="line">    <span class="keyword">if</span> (prop <span class="keyword">in</span> obj &amp;&amp; obj[prop] !== proto[prop] &amp;&amp; !_.contains(keys, prop)) &#123;</span><br><span class="line">      keys.push(prop);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>In IE &lt; 9, JScript will skip over any property in any object where there is a same-named property in the object’s prototype chain that has the DontEnum attribute.</p></blockquote><p>在 IE &lt; 9 中，若 object 中的某个属性在它的原形链 (prototype chain)上有一个同名的，具有 DontEnum 特性的属性，则在 <code>for key in object</code>枚举时将被忽略。</p><p>上述代码就是用来处理这个情形。注意代码中是如何手工判断 <code>obj</code> 是否含有键 <code>prop</code> ：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (prop <span class="keyword">in</span> obj &amp;&amp; obj[prop] !== proto[prop] &amp;&amp; !_.contains(keys, prop)) &#123;</span><br><span class="line">  keys.push(prop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An internal function for creating assigner functions.</span></span><br><span class="line"><span class="keyword">var</span> createAssigner = <span class="function"><span class="keyword">function</span>(<span class="params">keysFunc, defaults</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = <span class="built_in">arguments</span>.length;</span><br><span class="line">    <span class="keyword">if</span> (defaults) obj = <span class="built_in">Object</span>(obj);</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">2</span> || obj == <span class="literal">null</span>) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">1</span>; index &lt; length; index++) &#123;</span><br><span class="line">      <span class="keyword">var</span> source = <span class="built_in">arguments</span>[index],</span><br><span class="line">          keys = keysFunc(source),</span><br><span class="line">          l = keys.length;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> key = keys[i];</span><br><span class="line">        <span class="keyword">if</span> (!defaults || obj[key] === <span class="keyword">void</span> <span class="number">0</span>) obj[key] = source[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extend a given object with all the properties in passed-in object(s).</span></span><br><span class="line">_.extend = createAssigner(_.allKeys);</span><br></pre></td></tr></table></figure><p><code>createAssigner</code> 看似较为复杂，但只要了解了它如何使用，那其中的逻辑也不难理解了。我们看 <code>_.extend</code> 的使用例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.extend(&#123;<span class="attr">name</span>: <span class="string">'moe'</span>&#125;, &#123;<span class="attr">age</span>: <span class="number">50</span>&#125;);</span><br><span class="line"><span class="comment">// =&gt; &#123;name: 'moe', age: 50&#125;</span></span><br></pre></td></tr></table></figure><p>即，它以接收多个 object 作为参数，将第2个及之后的 object 的属性不断加入/覆盖到第一个 object 中并返回。因此 <code>createAssigner</code> 的核心就是两层循环，外层对参数进行迭代，内层对该参数的所有属性进行迭代。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Internal pick helper function to determine if `obj` has key `key`.</span></span><br><span class="line"><span class="keyword">var</span> keyInObj = <span class="function"><span class="keyword">function</span>(<span class="params">value, key, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> key <span class="keyword">in</span> obj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return a copy of the object only containing the whitelisted properties.</span></span><br><span class="line">_.pick = restArgs(<span class="function"><span class="keyword">function</span>(<span class="params">obj, keys</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = &#123;&#125;, iteratee = keys[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">  <span class="keyword">if</span> (_.isFunction(iteratee)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (keys.length &gt; <span class="number">1</span>) iteratee = optimizeCb(iteratee, keys[<span class="number">1</span>]);</span><br><span class="line">    keys = _.allKeys(obj);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    iteratee = keyInObj;</span><br><span class="line">    keys = flatten(keys, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    obj = <span class="built_in">Object</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, length = keys.length; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = keys[i];</span><br><span class="line">    <span class="keyword">var</span> value = obj[key];</span><br><span class="line">    <span class="keyword">if</span> (iteratee(value, key, obj)) result[key] = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>_.pick</code> 的复杂性也是由于额外的支持引起的。由于它可以接受一个函数作为参数，用作判断一个键是否选取的依据，因此它的代码中就要对参数 <code>keys</code> 是函数的情况进行判断。如果 <code>keys</code> 只是普通的键名，则 <code>iteratee</code> 退化为 <code>keyInObj</code>。额外的一点是，<code>_.pick</code> 除了接收函数作参数，同时还支持改变该函数的 <code>context</code>，函数中的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (keys.length &gt; <span class="number">1</span>) iteratee = optimizeCb(iteratee, keys[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>就是起这个作用的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Invokes interceptor with the obj, and then returns obj.</span></span><br><span class="line"><span class="comment">// The primary purpose of this method is to "tap into" a method chain, in</span></span><br><span class="line"><span class="comment">// order to perform operations on intermediate results within the chain.</span></span><br><span class="line">_.tap = <span class="function"><span class="keyword">function</span>(<span class="params">obj, interceptor</span>) </span>&#123;</span><br><span class="line">  interceptor(obj);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前面提到了链式调用，<code>_.tap(func)</code> 的作用是将 <code>func</code> 应用到链式调用的中间结果。看 underscore.js 官方的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.chain([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">200</span>])</span><br><span class="line">  .filter(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123; <span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">0</span>; &#125;)</span><br><span class="line">  .tap(alert)</span><br><span class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123; <span class="keyword">return</span> num * num &#125;)</span><br><span class="line">  .value();</span><br><span class="line">=&gt; <span class="comment">// [2, 200] (alerted)</span></span><br><span class="line">=&gt; [<span class="number">4</span>, <span class="number">40000</span>]</span><br></pre></td></tr></table></figure><p>从 <code>_.tap</code> 的实现中我们注意到，几乎所有 underscore.js 内置的函数的第一个参数都是 <code>obj</code>。而这样定义的函数我们又能以两种方式调用，如 <code>_.each</code> 函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">_.each([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="built_in">console</span>.log(x);&#125;); <span class="comment">// 1</span></span><br><span class="line">_([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).each(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="built_in">console</span>.log(x);&#125;); <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// _([1,2,3]).each([3,4,5], function (x) &#123; console.log(x);&#125;); // 3 出错</span></span><br></pre></td></tr></table></figure><p>而 <code>_.each = function(obj, iteratee, context) {...}</code> 包含三个参数，为什么第 2种调用可行，而第三种调用则出错呢？</p><p>原因是：1、2 两种调用的根本就不是一个函数！</p><p>首先要注意的是 <code>_</code> 变量本身是一个函数，而在 Javascript 中，函数同时承载着“类”的功能。因此要区分两种赋值方式：<code>_.attr = ...</code> 及 <code>_.prototype[attr] = ...</code>第一种是为变量（对象）本身添加属性，第二种是为原型（类）添加属性。区分以下例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var underscore = function () &#123;&#125;</span><br><span class="line">underscore.attr = 10;</span><br><span class="line">underscore.prototype[&apos;attr&apos;] = 20;</span><br><span class="line"></span><br><span class="line">console.log(underscore.attr); // =&gt; 10</span><br><span class="line"></span><br><span class="line">var instance = new underscore();</span><br><span class="line">console.log(instance.attr); // =&gt; 20</span><br></pre></td></tr></table></figure><p>所以，当我们试图访问变量（对象）的某个属性时，它会首先寻找变量本身的属性，若不存在，则通过原型链（prototype chain）进行查找。</p><p>回到 <code>_.each</code> 的例子上，<code>_.each([1,2,3], func...)</code> 的调用的方法是变量（对象）<code>_</code> 的属性，而 <code>_([1,2,3]).each(...)</code> 调用的是变量（对象）<code>_([1,2,3])</code> 的属性，而由于该变量并没有 <code>each</code> 属性，所以是调用的是 <code>_.prototype.each</code> 函数。</p><p>最后一个问题是 <code>_.prototype.each</code> 是在哪里设置的呢？答案是 <code>_.mixin</code> 函数中，上文已有讨论。</p><h2 id="相等判断"><a class="header-anchor" href="#相等判断">#</a>相等判断</h2><p>（不知道 Equality 怎么翻译）</p><p>这部分是用来学习 Javascript 内部判等机制的好材料。这里只涉及一个函数 <code>eq</code> 用来深度判等，举例来说，两个数组相等，当且仅当包含同样个数，且每个元素都相等，由于元素可能还是数组，所以要递归（深度）地进行判断。</p><p>先来个链接：<a href="https://dorey.github.io/JavaScript-Equality-Table/" target="_blank" rel="noopener">判等表格</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">eq = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Identical objects are equal. `0 === -0`, but they aren't identical.</span></span><br><span class="line">  <span class="comment">// See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).</span></span><br><span class="line">  <span class="keyword">if</span> (a === b) <span class="keyword">return</span> a !== <span class="number">0</span> || <span class="number">1</span> / a === <span class="number">1</span> / b;</span><br><span class="line">  <span class="comment">// A strict comparison is necessary because `null == undefined`.</span></span><br><span class="line">  <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) <span class="keyword">return</span> a === b;</span><br><span class="line">  <span class="comment">// `NaN`s are equivalent, but non-reflexive.</span></span><br><span class="line">  <span class="keyword">if</span> (a !== a) <span class="keyword">return</span> b !== b;</span><br><span class="line">  <span class="comment">// Exhaust primitive checks</span></span><br><span class="line">  <span class="keyword">var</span> type = <span class="keyword">typeof</span> a;</span><br><span class="line">  <span class="keyword">if</span> (type !== <span class="string">'function'</span> &amp;&amp; type !== <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> deepEq(a, b, aStack, bStack);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可见，几乎所有的原子型数据都可以通过 <code>===</code> 进行判断。具体的判断方法参见 <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-strict-equality-comparison" target="_blank" rel="noopener">ECMA6Strict EqualityComparison</a></p><p>个人觉得使用 <code>x === y</code> 有几点值得一说：</p><ol><li><code>===</code> 会首先判断 <code>x</code> 与 <code>y</code> 的类型，若不相同，则返回 <code>false</code>。</li><li><code>===</code> 会判断 <code>x</code> 与 <code>y</code> 的值（原子类型），若相等，则返回 <code>true</code>，反之<code>false</code>.</li><li><code>NaN</code> 不等于任意数字，另 <code>-0 === +0</code>。</li><li>对于非原子类型，当且仅当它们是指向同一个 object 时才 <code>===</code>。</li></ol><p>接下去的 <code>deepEq</code> 函数很长，我们逐步分析。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Internal recursive comparison function for `isEqual`.</span></span><br><span class="line">deepEq = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, aStack, bStack</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Unwrap any wrapped objects.</span></span><br><span class="line">  <span class="keyword">if</span> (a <span class="keyword">instanceof</span> _) a = a._wrapped;</span><br><span class="line">  <span class="keyword">if</span> (b <span class="keyword">instanceof</span> _) b = b._wrapped;</span><br><span class="line">  <span class="comment">// Compare `[[Class]]` names.</span></span><br><span class="line">  <span class="keyword">var</span> className = toString.call(a);</span><br><span class="line">  <span class="keyword">if</span> (className !== toString.call(b)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">switch</span> (className) &#123;</span><br><span class="line">    <span class="comment">// Strings, numbers, regular expressions, dates, and booleans are compared by value.</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'[object RegExp]'</span>:</span><br><span class="line">    <span class="comment">// RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'[object String]'</span>:</span><br><span class="line">      <span class="comment">// Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is</span></span><br><span class="line">      <span class="comment">// equivalent to `new String("5")`.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span> + a === <span class="string">''</span> + b;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'[object Number]'</span>:</span><br><span class="line">      <span class="comment">// `NaN`s are equivalent, but non-reflexive.</span></span><br><span class="line">      <span class="comment">// Object(NaN) is equivalent to NaN</span></span><br><span class="line">      <span class="keyword">if</span> (+a !== +a) <span class="keyword">return</span> +b !== +b;</span><br><span class="line">      <span class="comment">// An `egal` comparison is performed for other numeric values.</span></span><br><span class="line">      <span class="keyword">return</span> +a === <span class="number">0</span> ? <span class="number">1</span> / +a === <span class="number">1</span> / b : +a === +b;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'[object Date]'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'[object Boolean]'</span>:</span><br><span class="line">      <span class="comment">// Coerce dates and booleans to numeric primitive values. Dates are compared by their</span></span><br><span class="line">      <span class="comment">// millisecond representations. Note that invalid dates with millisecond representations</span></span><br><span class="line">      <span class="comment">// of `NaN` are not equivalent.</span></span><br><span class="line">      <span class="keyword">return</span> +a === +b;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然在 <code>eq</code> 函数中判断了原子型数据，但由于我们可能创建了 underscore.js 的对象，如 <code>_(1)</code> 或 <code>_(&quot;abc&quot;)</code>，它们并不是原子型数据，所以上面的代码相当于自己实现了 <code>===</code> 的逻辑。根据 <code>a</code> <code>b</code>的类型进行相应的判断。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> areArrays = className === <span class="string">'[object Array]'</span>;</span><br></pre></td></tr></table></figure><p>判断一个对象是否是 ‘Array’ 的正确方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!areArrays) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a != <span class="string">'object'</span> || <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Objects with different constructors are not equivalent, but `Object`s or `Array`s</span></span><br><span class="line">  <span class="comment">// from different frames are.</span></span><br><span class="line">  <span class="keyword">var</span> aCtor = a.constructor, bCtor = b.constructor;</span><br><span class="line">  <span class="keyword">if</span> (aCtor !== bCtor &amp;&amp; !(_.isFunction(aCtor) &amp;&amp; aCtor <span class="keyword">instanceof</span> aCtor &amp;&amp;</span><br><span class="line">                           _.isFunction(bCtor) &amp;&amp; bCtor <span class="keyword">instanceof</span> bCtor)</span><br><span class="line">                      &amp;&amp; (<span class="string">'constructor'</span> <span class="keyword">in</span> a &amp;&amp; <span class="string">'constructor'</span> <span class="keyword">in</span> b)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文代码应是有些 Bug，因为函数并非数组，所以会进入该 <code>if</code> 语句，但由于它们的类型并非 <code>object</code> 所以直接返回 <code>false</code>，即所有函数都不相等。考虑下面的测试用例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">_.isEqual(tmp, tmp); <span class="comment">// =&gt; false, 似乎有些版本的 underscore.js 返回 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = _(tmp);</span><br><span class="line"><span class="keyword">var</span> y = _(tmp);</span><br><span class="line"></span><br><span class="line">_.isEqual(x, y); <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure><p>所以结果是所有的函数都不相等。</p><p>接下来重要的是下面这个代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Assume equality for cyclic structures. The algorithm for detecting cyclic</span></span><br><span class="line"><span class="comment">// structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Initializing stack of traversed objects.</span></span><br><span class="line"><span class="comment">// It's done here since we only need them for objects and arrays comparison.</span></span><br><span class="line">aStack = aStack || [];</span><br><span class="line">bStack = bStack || [];</span><br><span class="line"><span class="keyword">var</span> length = aStack.length;</span><br><span class="line"><span class="keyword">while</span> (length--) &#123;</span><br><span class="line">  <span class="comment">// Linear search. Performance is inversely proportional to the number of</span></span><br><span class="line">  <span class="comment">// unique nested structures.</span></span><br><span class="line">  <span class="keyword">if</span> (aStack[length] === a) <span class="keyword">return</span> bStack[length] === b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是用来检测环形数据结构的，什么意思呢？就是对象中直接或间接地引用了自己本身，如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接引用</span></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line">a[<span class="number">0</span>] = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 间接引用</span></span><br><span class="line"><span class="keyword">var</span> x = [];</span><br><span class="line"><span class="keyword">var</span> y = [x];</span><br><span class="line">x[<span class="number">0</span>] = y;</span><br></pre></td></tr></table></figure><p>上述检测环形数据的原理是：只要是环形数据，意味着在递归获取子结构时，在某个时候，得到的子结构会与之前访问过的某一结构完全一致。如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span><br><span class="line">          ^         |</span><br><span class="line">          |         v</span><br><span class="line">          8 &lt;- 7 &lt;- 6</span><br></pre></td></tr></table></figure><p>在第一次访问 3 时，<code>aStack</code> 中保存了整个环（3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt;…），所以第二次访问 3 时，仍然得到这个环（3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt;…），此时，条件 <code>if(aStack[length] === a)</code> 就会通过，从而检测出该环。</p><h2 id="类型判断"><a class="header-anchor" href="#类型判断">#</a>类型判断</h2><p>接下去是一些类型判断的函数如 <code>isArray</code>，<code>isObject</code> 等。主要的判断依据是<code>toString</code> 函数。</p><p>根据 <a href="http://ecma262-5.com/ELS5_HTML.htm#Section_15.2.4.2" target="_blank" rel="noopener">ELS6</a>，<code>Object.prototype.toString</code> 会输出调用时 <code>this</code> 所指对象的内部 <code>[[Class]]</code> 属性。输出 <code>&quot;[object&quot; + [[Class]] + &quot;]&quot;</code>。</p><p>例如，在创建数组对象时，对象的 <code>[[Class]]</code> 属性会被设置为 <code>Array</code>，故对数组调用 <code>toString</code> 时将输出 <code>[object Array]</code>。</p><p>这里要注意的是 <code>toString</code> 的调用方法：<code>toString.call(obj)</code> 而非<code>toString(obj)</code>。这就涉及到函数调用 <code>toString(obj)</code> 时 <code>this</code> 的值究竟是什么？它的规则如下：</p><p>函数是否由 <code>new</code> 调用？</p><ol><li>是 -&gt; <code>this</code> 指向新建的对象</li><li>否 -&gt; 函数是否由 <code>dot(.)</code> 进行调用？<ol><li>是 -&gt; <code>this</code> 指向 dot 之前的对象</li><li>否 -&gt; <code>this</code> 指向全局对象 window</li></ol></li></ol><p>请参见 <a href="http://web.jobbole.com/84046/" target="_blank" rel="noopener">图解 Javascript this 指向什么</a></p><p>测试下面代码的结果：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">toString(<span class="string">"abc"</span>);      <span class="comment">// =&gt; "[object Undefined]"</span></span><br><span class="line">toString.call(<span class="string">"abc"</span>); <span class="comment">// =&gt; "[object String]"</span></span><br></pre></td></tr></table></figure><h2 id="template"><a class="header-anchor" href="#template">#</a>template</h2><p>模板函数是 underscore.js 中个人觉得最有趣的函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JavaScript micro-templating, similar to John Resig's implementation.</span></span><br><span class="line"><span class="comment">// Underscore templating handles arbitrary delimiters, preserves whitespace,</span></span><br><span class="line"><span class="comment">// and correctly escapes quotes within interpolated code.</span></span><br><span class="line"><span class="comment">// NB: `oldSettings` only exists for backwards compatibility.</span></span><br><span class="line">_.template = <span class="function"><span class="keyword">function</span>(<span class="params">text, settings, oldSettings</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!settings &amp;&amp; oldSettings) settings = oldSettings;</span><br><span class="line">  settings = _.defaults(&#123;&#125;, settings, _.templateSettings);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Combine delimiters into one regular expression via alternation.</span></span><br><span class="line">  <span class="keyword">var</span> matcher = <span class="built_in">RegExp</span>([</span><br><span class="line">    (settings.escape || noMatch).source,</span><br><span class="line">    (settings.interpolate || noMatch).source,</span><br><span class="line">    (settings.evaluate || noMatch).source</span><br><span class="line">  ].join(<span class="string">'|'</span>) + <span class="string">'|$'</span>, <span class="string">'g'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compile the template source, escaping string literals appropriately.</span></span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> source = <span class="string">"__p+='"</span>;</span><br><span class="line">  text.replace(matcher, <span class="function"><span class="keyword">function</span>(<span class="params">match, escape, interpolate, evaluate, offset</span>) </span>&#123;</span><br><span class="line">    source += text.slice(index, offset).replace(escapeRegExp, escapeChar);</span><br><span class="line">    index = offset + match.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">escape</span>) &#123;</span><br><span class="line">      source += <span class="string">"'+\n((__t=("</span> + <span class="built_in">escape</span> + <span class="string">"))==null?'':_.escape(__t))+\n'"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interpolate) &#123;</span><br><span class="line">      source += <span class="string">"'+\n((__t=("</span> + interpolate + <span class="string">"))==null?'':__t)+\n'"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (evaluate) &#123;</span><br><span class="line">      source += <span class="string">"';\n"</span> + evaluate + <span class="string">"\n__p+='"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adobe VMs need the match returned to produce the correct offset.</span></span><br><span class="line">    <span class="keyword">return</span> match;</span><br><span class="line">  &#125;);</span><br><span class="line">  source += <span class="string">"';\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If a variable is not specified, place data values in local scope.</span></span><br><span class="line">  <span class="keyword">if</span> (!settings.variable) source = <span class="string">'with(obj||&#123;&#125;)&#123;\n'</span> + source + <span class="string">'&#125;\n'</span>;</span><br><span class="line"></span><br><span class="line">  source = <span class="string">"var __t,__p='',__j=Array.prototype.join,"</span> +</span><br><span class="line">    <span class="string">"print=function()&#123;__p+=__j.call(arguments,'');&#125;;\n"</span> +</span><br><span class="line">    source + <span class="string">'return __p;\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> render;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    render = <span class="keyword">new</span> <span class="built_in">Function</span>(settings.variable || <span class="string">'obj'</span>, <span class="string">'_'</span>, source);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    e.source = source;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> template = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> render.call(<span class="keyword">this</span>, data, _);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Provide the compiled source as a convenience for precompilation.</span></span><br><span class="line">  <span class="keyword">var</span> argument = settings.variable || <span class="string">'obj'</span>;</span><br><span class="line">  template.source = <span class="string">'function('</span> + argument + <span class="string">')&#123;\n'</span> + source + <span class="string">'&#125;'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> template;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然在使用之前要明白它的 <a href="http://underscorejs.org/#template" target="_blank" rel="noopener">使用方法</a>。简单来说就是预先定义好模板，之后就可以用它来生成字符串。</p><p>模板中支持三种替换类型：值替换（interpolate）<code>&lt;%= ... %&gt;</code>；执行替换（evaluate） <code>&lt;% ... %&gt;</code> 及转义替换（escape） <code>&lt;%- ... %&gt;</code>。</p><p>下面的例子取自官网：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var compiled = _.template(&quot;hello: &lt;%= name %&gt;&quot;);</span><br><span class="line">compiled(&#123;name: &apos;moe&apos;&#125;);</span><br><span class="line">=&gt; &quot;hello: moe&quot;</span><br><span class="line"></span><br><span class="line">var template = _.template(&quot;&lt;b&gt;&lt;%- value %&gt;&lt;/b&gt;&quot;);</span><br><span class="line">template(&#123;value: &apos;&lt;script&gt;&apos;&#125;);</span><br><span class="line">=&gt; &quot;&lt;b&gt;&amp;lt;script&amp;gt;&lt;/b&gt;&quot;</span><br><span class="line"></span><br><span class="line">var compiled = _.template(&quot;&lt;% print(&apos;Hello &apos; + epithet); %&gt;&quot;);</span><br><span class="line">compiled(&#123;epithet: &quot;stooge&quot;&#125;);</span><br><span class="line">=&gt; &quot;Hello stooge&quot;</span><br></pre></td></tr></table></figure><p>在试图看懂这段代码之前，我们先来了解 Javascript 中的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval" target="_blank" rel="noopener">eval</a>函数。它的作用是将输入的字符串作为代码执行。举个“看似”有用的例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function gen_getter_setter(obj, field) &#123;</span><br><span class="line">    var field_path = obj + &apos;.&apos; + field;</span><br><span class="line"></span><br><span class="line">    return &apos;function get_&apos; + field + &apos;() &#123;\n&apos;</span><br><span class="line">        + &apos;return &apos; + field_path + &apos;;\n&apos;</span><br><span class="line">        + &apos;&#125;\n&apos;</span><br><span class="line">        + &apos;function set_&apos; + field + &apos;(val) &#123;\n&apos;</span><br><span class="line">        + field_path + &apos;= val;\n&apos;</span><br><span class="line">        + &apos;&#125;&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var object = &#123;a: 10&#125;;</span><br><span class="line"></span><br><span class="line">eval(gen_getter_setter(&apos;object&apos;, &apos;a&apos;));</span><br><span class="line"></span><br><span class="line">get_a(); // =&gt; 10</span><br><span class="line">set_a(20);</span><br><span class="line">object.a; // =&gt; 20</span><br></pre></td></tr></table></figure><p>例子中 <code>gen_getter_setter('object', 'a')</code> 生成的字符串如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;function get_a() &#123;</span><br><span class="line">return object.a;</span><br><span class="line">&#125;</span><br><span class="line">function set_a(val) &#123;</span><br><span class="line">object.a= val;</span><br><span class="line">&#125;&quot;</span><br></pre></td></tr></table></figure><p>也即我们生成了一个字符串，但字符串的内容完全符合 Javascript 的语法，因此<code>eval</code> 可以根据 Javascript 的语法来解析该字符串。可以参考 Lisp 中的 Macro（宏）。</p><p>说了这么多，可是代码里根本没有 <code>eval</code> 啊？好吧，是的，只是代码里通过 <code>new Function(...)</code> 创建新的函数对象时，也是传递字符串作为函数的函数体（函数的正文）。所以要明确的就是我们可以构建字符串，将字符串作为代码来执行。</p><p>因此，<code>_.template</code> 函数的大部分功能就是在构造 <code>render</code> 函数的函数体。我们先撇开对 <code>source</code> 的构建，先看 <code>render</code> 的框架部分（重新调整了格式）：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">obj, _</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> __t,</span><br><span class="line">      __p = <span class="string">''</span>,</span><br><span class="line">      __j = <span class="built_in">Array</span>.prototype.join,</span><br><span class="line">      print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        __p += __j.call(<span class="built_in">arguments</span>, <span class="string">''</span>);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">with</span>(obj || &#123;&#125;) &#123;</span><br><span class="line">      ...</span><br><span class="line">      the content <span class="keyword">of</span> source</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，生成的代码根据参数 <code>obj</code> 进行操作（具体操作未知），最终将代码存放在变量 <code>__p</code> 中返回。</p><p>所以具体的操作就要看 <code>source</code> 中的内容，而它又是根据模板字符串 <code>text</code> 生成的。下面再贴出主要逻辑的代码，以便于查看：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="string">"__p+='"</span>;</span><br><span class="line">text.replace(matcher, <span class="function"><span class="keyword">function</span>(<span class="params">match, escape, interpolate, evaluate, offset</span>) </span>&#123;</span><br><span class="line">  source += text.slice(index, offset).replace(escapeRegExp, escapeChar);</span><br><span class="line">  index = offset + match.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">escape</span>) &#123;</span><br><span class="line">    source += <span class="string">"'+\n((__t=("</span> + <span class="built_in">escape</span> + <span class="string">"))==null?'':_.escape(__t))+\n'"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (interpolate) &#123;</span><br><span class="line">    source += <span class="string">"'+\n((__t=("</span> + interpolate + <span class="string">"))==null?'':__t)+\n'"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (evaluate) &#123;</span><br><span class="line">    source += <span class="string">"';\n"</span> + evaluate + <span class="string">"\n__p+='"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Adobe VMs need the match returned to produce the correct offset.</span></span><br><span class="line">  <span class="keyword">return</span> match;</span><br><span class="line">&#125;);</span><br><span class="line">source += <span class="string">"';\n"</span>;</span><br></pre></td></tr></table></figure><p>这段代码将匹配 <code>_.template</code> 支持的三种模式，即 <code>&lt;%= ... %&gt;</code>、<code>&lt;% .. %&gt;</code>及<code>&lt;%- .. %&gt;</code> 并将其替换成相应的代码。</p><p>例如：对于模板字符串 <code>&quot;&lt;b&gt;&lt;%- value %&gt;&lt;/b&gt;&quot;</code>，则会进入 <code>escape</code> 分支（注意会调用不止一次），生成相应的代码放在之前的上下文中如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">obj, _</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> __t,</span><br><span class="line">      __p = <span class="string">''</span>,</span><br><span class="line">      __j = <span class="built_in">Array</span>.prototype.join,</span><br><span class="line">      print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        __p += __j.call(<span class="built_in">arguments</span>, <span class="string">''</span>);</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the content of source</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">with</span>(obj || &#123;&#125;) &#123;</span><br><span class="line">      __p += <span class="string">'&lt;b&gt;'</span></span><br><span class="line">        + ((__t = (value)) == <span class="literal">null</span> ? <span class="string">''</span> : _.escape(__t))</span><br><span class="line">        + <span class="string">''</span></span><br><span class="line">        + <span class="string">'&lt;/b&gt;'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解 <code>_.template</code> 代码要注意区分生成字符串的代码与生成的字符串。相信跟着例子调试几次就能够完全理解它了。</p><h2 id="写在后面"><a class="header-anchor" href="#写在后面">#</a>写在后面</h2><p>阅读 underscore.js 的代码花费了许多时间，但受益颇丰。通过深究其中的许多细节，让我对 Javascript 的原理有了更深的理解和掌握。相信只要读者静下心来，仔细钻研其中的细节，定有收获。</p><p>文章写得匆忙，也只是作为个人的笔记，若有错误不足之处，敬请批评指正。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;（这是两年前的笔记，现在把它搬到博客上，Underscore 版本：1.8.3）&lt;/p&gt;
&lt;p&gt;受 &lt;a href=&quot;http://web.jobbole.com/83872/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt; 的启发,萌生阅读 underscore.js 源
码的念头,其中有许多不理解的地方,也是读了上述文章后才明白的.为了保持本文的完整
性,也尽量按自己的理解进行注释. 不再提及上述引用文章.&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="http://lotabout.github.io/categories/Notes/"/>
    
    
      <category term="underscore" scheme="http://lotabout.github.io/tags/underscore/"/>
    
      <category term="javascript" scheme="http://lotabout.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>CSS position:sticky</title>
    <link href="http://lotabout.github.io/2017/CSS-position-sticky/"/>
    <id>http://lotabout.github.io/2017/CSS-position-sticky/</id>
    <published>2017-09-04T15:04:26.000Z</published>
    <updated>2018-01-30T13:53:38.923Z</updated>
    
    <content type="html"><![CDATA[<p>大约两年看在看 <a href="https://www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="noopener">ECMA 2015</a>的时候，发现在滚动时每个章节的标题都会固定在页面的顶端，好奇的我看了下它的CSS，发现只有简单的一行 <code>position: sticky</code>。当时只有 Firefox 实现了这个特性，不免心生遗憾，今天恰巧注意到 Chrome 从 56 也支持这个特性了！这里我们就来介绍下这个神奇的特性吧。</p><h2 id="先暏为快"><a class="header-anchor" href="#先暏为快">#</a>先暏为快</h2><p>先看下面的 JsFiddle，注意滚动时左侧导航栏的行为。</p><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/lotabout/d6xv8num/2/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe><p>下面这个例子是 MDN 的 demo:</p><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/lotabout/hjf99x20/embedded/result,html,css/light" frameborder="0" allowfullscreen></iframe><p>只需要一行 CSS 就能实现，没有这个特性时，我们需要用 JS 监控滚动事件来实现。下面我们看看它的工作原理吧。</p><h2 id="工作原理"><a class="header-anchor" href="#工作原理">#</a>工作原理</h2><blockquote><p>Sticky positioning can be thought of as a hybrid of relative and fixedpositioning. A stickily positioned element is treated as relatively positioneduntil it crosses a specified threshold, at which point it is treated as fixed.</p></blockquote><p>可以认为 sticky 是 relative 及 fixed 两种 position 的混合。当一个元素的position 为 sticky 时，它首先会被当成是 <code>position: relative</code>，之后，当它的位置超出一定的阈值时，该元素就被认为是 <code>position: fixed</code>。</p><p>默认情况下，元素被当作是 <code>position: relative</code>，当用户滚动页面时，元素跟着它的父元素一起滚动。当元素和视区（viewport，这里可以理解成浏览器窗口）的距离小于（通过 <code>top: 10px</code> 等）指定的数值时，元素被认为是 <code>position: fixed</code>。造成的效果是元素和 viewport 的距离保持不变，不会小于指定的距离。</p><p>例如：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#one</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: sticky;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当滚动屏幕使得元素 <code>#one</code> 与视区的距离小于 <code>10px</code> 时，它就变成了 <code>position: fixed; top: 10px</code>，此时继续滚动的话，<code>#one</code> 是不会移动的，因此也称为黏性(sticky)的。</p><p>最后要注意一个注意点， <code>position: sticky</code> 的元素是不会“超出”父元素的。当滚动时，父元素也快离开屏幕时，子元素是不会继续保持 <code>sticky</code> 的状态的，它会随着父元素一起“滚”出屏幕。可以参考上节给出的 MDN 的例子。</p><p>因此，如果将 <code>position: sticky</code> 与 <code>flexbox</code> 一起使用，要注意 flexbox 默认会拉伸元素。如第一个例子中，我们使用了 <code>align-items: flex-start;</code> 来保证导航栏的高度不会和父元素一样，否则 sticky 就没作用了。</p><h2 id="最后"><a class="header-anchor" href="#最后">#</a>最后</h2><p>本文只是对 <code>position: sticky</code> 做一个简单的介绍，对它的介绍也是以自己的直观理解为主，如果遇到问题还请查阅官方文档。</p><ul><li><a href="https://developer.mozilla.org/en/docs/Web/CSS/position#Sticky_positioning" target="_blank" rel="noopener">MDN: sticky position</a></li><li><a href="https://developers.google.com/web/updates/2012/08/Stick-your-landings-position-sticky-lands-in-WebKit" target="_blank" rel="noopener">sticky 支持 webkit!</a></li><li><a href="https://github.com/wilddeer/stickyfill" target="_blank" rel="noopener">sticky polyfill</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大约两年看在看 &lt;a href=&quot;https://www.ecma-international.org/ecma-262/6.0/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ECMA 2015&lt;/a&gt;
的时候，发现在滚动时每个章节的标题都会固定在页面的
      
    
    </summary>
    
      <category term="Knowledge" scheme="http://lotabout.github.io/categories/Knowledge/"/>
    
    
      <category term="CSS" scheme="http://lotabout.github.io/tags/CSS/"/>
    
      <category term="position" scheme="http://lotabout.github.io/tags/position/"/>
    
      <category term="sticky" scheme="http://lotabout.github.io/tags/sticky/"/>
    
  </entry>
  
  <entry>
    <title>理解 Python asyncio</title>
    <link href="http://lotabout.github.io/2017/understand-python-asyncio/"/>
    <id>http://lotabout.github.io/2017/understand-python-asyncio/</id>
    <published>2017-09-03T12:02:00.000Z</published>
    <updated>2018-01-30T13:53:38.971Z</updated>
    
    <content type="html"><![CDATA[<p>协程 (coroutine) 几乎是 Python 里最为复杂的特性之一了，这篇文章我们来说一说asyncio 的内部实现机制，借此来理解一门语言要支持协程需要做的工作。</p><p>本文需要提前了解 Python 的 <code>yeild from</code> 语法，不了解的话，可以看看</p><a href="/2017/Python-Generator/" title="之前关于 Generator 的文章">之前关于 Generator 的文章</a> ；另外，最好对<p>future/promise 的概念有一定了解。文中不会介绍如何使用 asyncio 及协程，并且文中给出的代码不一定能实际运行（不然代码量太大）。</p><h2 id="多线程与协程"><a class="header-anchor" href="#多线程与协程">#</a>多线程与协程</h2><p>CPU 的执行是顺序的，线程是操作系统提供的一种机制，允许我们在操作系统的层面上实现“并行”。而协程则可以认为是应用程序提供的一种机制（用户或库来完成），允许我们在应用程序的层面上实现“并行”。</p><p>由于本质上程序是顺序执行的，要实现这种“并行”的假像，我们需要一种机制，来“暂停”当前的执行流，并在之后“恢复”之前的执行流。这在操作系统及多线程/多进程中称为“上下文切换” (context switch)。其中“上下文”记录了某个线程执行的状态，包括线程里用到的各个变量，线程的调用栈等。而“切换”指的就是保存某个线程当前的运行状态，之后再从之前的状态中恢复。只不过线程相关的工作是由操作系统完成，而协程则是由应用程序自己来完成。</p><p>与线程不同的时，协程完成的功能通常较小，所以会有需求将不同的协程串起来，我们暂时称它为协程链 (coroutine chain)。</p><p>那么，与线程类似，要实现一个协程的库，我们需要这几样东西：</p><ol><li>事件循环 (event loop)。一方面，它类似于 CPU ，顺序执行协程的代码；另一方面，它相当于操作系统，完成协程的调度，即一个协程“暂停”时，决定接下来执行哪个协程。</li><li>上下文的表示。在 Python 中，我们使用 Python 本身支持的生成器 Generator 来代表基本的上下文，但协程链是如何工作的呢？</li><li>上下文的切换。最基础的切换也是通过 Python 生成器的 yeild 加强版语法来完成的，但我们还要考虑协程链的情况。</li></ol><h2 id="event-loop"><a class="header-anchor" href="#event-loop">#</a>Event Loop</h2><p>首先，因为协程是一种能暂停的函数，那么它暂停是为了什么？一般是等待某个事件，比如说某个连接建立了；某个 socket  接收到数据了；某个计时器归零了等。而这些事件应用程序只能通过轮询的方式得知是否完成，但是操作系统（所有现代的操作系统）可以提供一些中断的方式通知应用程序，如 <code>select</code>, <code>epoll</code>, <code>kqueue</code> 等等。</p><p>那么有了操作系统的支持，我们就可以手写这样的循环（伪代码）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="keyword">True</span></span><br><span class="line">    happend = poll_events(events_to_listen, timeout)</span><br><span class="line">    process_events(happend)</span><br></pre></td></tr></table></figure><p>第一个问题是：如何注册我们想监听的事件？很简单，把事件加到 <code>events_to_listen</code>里就可以了。第二个问题，可以监听什么事件？由于 <code>process_events</code> 需要操作系统的支持，那么我们想监听的事件是需要操作系统支持才行的，一般操作系统支持网络 I/O的文件描述符 (file descriptor)。</p><p>接下来，当事件发生时，我们要指定做一些事，一般称为回调 (callback)。也就是说我们需要告诉 event loop 一个 <code>事件:回调</code> 的对应关系。现在我们把 event loop 用类表示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.events_to_listen = []</span><br><span class="line">        self.callbacks = &#123;&#125;</span><br><span class="line">        self.timeout = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register_event</span><span class="params">(self, event, callback)</span>:</span></span><br><span class="line">        self.events_to_listen.append(event)</span><br><span class="line">        self.callbacks[event] = callback</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unregister_event</span><span class="params">(self, event)</span>:</span></span><br><span class="line">        self.events_to_listen.remove(evenrt)</span><br><span class="line">        <span class="keyword">del</span> self.callbacks[event]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_process_events</span><span class="params">(self, events)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> events:</span><br><span class="line">            self.callbacks[event](event)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_loop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            events_happend = poll_events(self.events_to_listen, timeout)</span><br><span class="line">            self._process_events(events_happend)</span><br><span class="line"></span><br><span class="line">loop = EventLoop()</span><br><span class="line">loop.register_event(fd, callback)</span><br><span class="line">loop.start_loop()</span><br></pre></td></tr></table></figure><p><code>register_event</code> 用到注册 <code>事件: 回调</code> 的关系，<code>start_loop</code> 用于开启事件循环。</p><p>现在，你不是想说，之前提到过事件也包括“某个计时器归零了”，但 <code>poll_events</code> 只支持网络 I/O 的文件描述符，计时器又要如何实现呢？一般 <code>poll_events</code> 函数是支持<code>timeout</code> 参数表示等待的时间。因此，可以修改 <code>start_loop</code>:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_later</span><span class="params">(self, delay, callback)</span>:</span></span><br><span class="line">    self.call_at(now() + delay, callback)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_at</span><span class="params">(self, when, callback)</span>:</span></span><br><span class="line">    self.timeout_callbacks[when] = callback</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_loop</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        timeout = min(self.timeout_callbacks.keys()) - now()</span><br><span class="line">        events_happend = poll_events(self.events_to_listen, timeout)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> empty(events_happend):</span><br><span class="line">            self._process_events(events_happend)</span><br><span class="line">        self._process_timeout_events()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_process_timeout_events</span><span class="params">(self)</span>:</span></span><br><span class="line">    time_now = now()</span><br><span class="line">    <span class="keyword">for</span> time, callback <span class="keyword">in</span> self.timeout_callbacks.iteritems():</span><br><span class="line">        <span class="keyword">if</span> time &lt; time_now:</span><br><span class="line">            callback()</span><br><span class="line">            <span class="keyword">del</span> self.timeout_callbacks[time]</span><br></pre></td></tr></table></figure><p>这里 <code>poll_events</code> 之前，会去计算所有计时器事件最少需要等待的时间，这个时间内即使没有事件发生，<code>poll_events</code> 也会退出，以便触发计时器事件。<code>_process_timeout_events</code> 函数的作用是对比当前时间与计时器的目标执行时间，如果目标执行时间已经到达，则执行相应的回调函数。</p><p>于是一个简单的 event loop 就完成了。可以看到，它是异步操作的基础：允许等待某个事件的发生并执行相应的操作。同时，它还是个简单的调度器，能顺序地执行发生事件的回调函数。</p><h2 id="callback-vs-promise-vs-await"><a class="header-anchor" href="#callback-vs-promise-vs-await">#</a>Callback vs Promise vs await</h2><p>好了，现在我们有了 event loop ，它允许我们为事件注册回调函数。现在假设我们要顺序调用几个 API， 用阻塞式编程如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result1 = api1()</span><br><span class="line">result2 = api2(result1)</span><br><span class="line">result3 = api3(result2)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果这几个 API 都是异步的，用 event loop + callback 怎么实现？</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Implementation for api</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">api1</span><span class="params">(callback)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callback_for_api1</span><span class="params">()</span>:</span></span><br><span class="line">        result1 = some_calculation_1()</span><br><span class="line">        event_loop.unregister_event(event1)</span><br><span class="line">        <span class="keyword">return</span> callback(result1)</span><br><span class="line">    event_loop.register_event(event1, callback_for_api1)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">api2</span><span class="params">(result, callback)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callback_for_api2</span><span class="params">()</span>:</span></span><br><span class="line">        result2 = some_calculation_2(result)</span><br><span class="line">        event_loop.unregister_event(event2)</span><br><span class="line">        <span class="keyword">return</span> callback(result2)</span><br><span class="line">    event_loop.register_event(event2, callback_for_api2)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Our code</span></span><br><span class="line"><span class="keyword">global</span> result</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">api1_callback</span><span class="params">(result1)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">api2_callback</span><span class="params">(result2)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">api3_callback</span><span class="params">(result3)</span>:</span></span><br><span class="line">            <span class="keyword">global</span> result</span><br><span class="line">            result = some_calculation(result3)</span><br><span class="line">        <span class="keyword">return</span> api3(result2, api3_callback)</span><br><span class="line">    <span class="keyword">return</span> api2(result1, api2_callback)</span><br><span class="line">api1(api1_callback)</span><br></pre></td></tr></table></figure><p>这里 <code>api1</code> <code>api2</code> 的实现由于需要用 event loop 来注册注销某些事件，所以显得特别复杂，这里我们可以先忽略它们的实现，但是看最后一段“用户代码”是不是极其复杂？随着操作的复杂性增加，回调函数的嵌套会越变越深。如果你熟悉Javascript，你应该听过“callback hell”的大名。回调函数的方式为什么不好？最重要的就是它违反了我们写代码的直觉，我们都习惯顺序执行的代码。</p><p>例如上例中，我们期待的是 <code>api1</code> 先执行，我们再用它的结果做点什么，但采用回调的方式，我们就需要在写 <code>api1</code> 的回调时，就去思考我们想用它的结果做些什么操作。在这个例子里，我们需要调用 <code>api2</code> 及 <code>api3</code>，这些嵌套的思考又得一遍遍重复下去。最终代码非常难以理解。</p><p>因此 Javascript 提出了 Promise ，所谓的 promise 像是一个占位符，它表示一个运算现在还未完成，但我保证它会做完的；你可以指定它完成的时候做些其它的事。下面我们尝试用这个思路去做一些改进（Python 没有原生的 promise 支持）：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">then</span><span class="params">(self, callback_that_return_promise)</span>:</span></span><br><span class="line">        self._then = callback_that_return_promise</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_result</span><span class="params">(self, result)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._then(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Implementation for api</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">api1</span><span class="params">()</span>:</span></span><br><span class="line">    promise = Promise()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callback_for_api1</span><span class="params">()</span>:</span></span><br><span class="line">        promise.set_result(some_calculation_1())</span><br><span class="line">        event_loop.unregister_event(event1)</span><br><span class="line">    event_loop.register_event(event1, callback_for_api1)</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">api2</span><span class="params">(result)</span>:</span></span><br><span class="line">    promise = Promise()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callback_for_api2</span><span class="params">()</span>:</span></span><br><span class="line">        promise.set_result((some_calculation_2(result))</span><br><span class="line">        event_loop.unregister_event(event2)</span><br><span class="line">        <span class="keyword">return</span> callback(result2)</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Our code</span></span><br><span class="line"><span class="keyword">global</span> result</span><br><span class="line">promise = api1().then(<span class="keyword">lambda</span> result1: <span class="keyword">return</span> api2(result1))</span><br><span class="line">    .then(<span class="keyword">lambda</span> result2: <span class="keyword">return</span> api3(result3))</span><br><span class="line">    .then(<span class="keyword">lambda</span> result3: <span class="keyword">global</span> result; result = result3)</span><br><span class="line"></span><br><span class="line">promise.wait_till_complete()</span><br></pre></td></tr></table></figure><p>这里我们简单实现了一个我们自己的 Promise 类，当它的 <code>set_result</code> 方法被调用时，Promise 会去执行之前用 <code>.then</code> 注册的回调函数，该回调函数将执行另一些操作并返回一个新的 Promise。也因此，我们可以不断地调用 <code>then</code> 将不同的 Promise 组合起来。可以看到，现在我们的代码就是线性的了！</p><p>然而故事还没有结束，人们依旧不满于 Promise 的写法和用法，又提出了<code>async/await</code> 的写法。在 Python 中，上面的代码用 <code>async/await</code> 重写如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result1 = <span class="keyword">await</span> api1()</span><br><span class="line">result2 = <span class="keyword">await</span> api2(result1)</span><br><span class="line">result3 = <span class="keyword">await</span> api3(result2)</span><br></pre></td></tr></table></figure><p>是不是简单明了？它的效果和我们前几个例子是等价的，但它的写法与我们初开始的阻塞版本几乎一致。这样能把异步与同步的编码在结构上尽量统一起来。</p><p>这里我不禁想问，为什么大家没有一开始就想到 <code>async/await</code> 的方式呢？我的一个假设是 <code>async/await</code> 是需要语言本身的支持的，而写编译器/解释器的专家不一定有编写应用的丰富经验，是很可能从一开始就拒绝这样的修改的。因此程序员们只能自己用库的形式添加支持了。当然这纯粹是猜测，只想感叹下不同领域的隔阂。</p><p>总而言之，有了 event loop 我们就能通过回调函数来完成异步编程，但这种方式非常不友好，因此人们又提出了类似 Promise 的思想，让我们能顺序编写异步代码，最后通过语言对 <code>async/await</code> 的语法支持，异步与同步代码的结构就几乎达到统一。这种统一有很重要的意义，它使我们能以同步的思维去理解异步的代码而不受回调方式的代码结构的影响。</p><p>而这一切都是为了将不同的异步函数“链接”起来，只不过是 <code>async/await</code> 的方式最为方便。对比线程，操作系统是没有提供方式将不同的线程链接起来的，因此这种将不同的协程链接起来的工具是协程比线程好的一个方面。</p><h2 id="上下文切换-恢复控制流"><a class="header-anchor" href="#上下文切换-恢复控制流">#</a>上下文切换（恢复控制流）</h2><p>前面提到过，如果某个协程在等待某些资源，我们需要暂停它的执行，在 event loop 中注册这个事件，以便当事件发生的时候，能再次唤醒该协程的执行。</p><p>这里举一个 Python <a href="https://docs.python.org/3/library/asyncio-task.html#example-chain-coroutines" target="_blank" rel="noopener">官方文档</a>的例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    print(<span class="string">"Compute %s + %s ..."</span> % (x, y))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">print_sum</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    result = <span class="keyword">await</span> compute(x, y)</span><br><span class="line">    print(<span class="string">"%s + %s = %s"</span> % (x, y, result))</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(print_sum(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure><p>上面的代码的执行流程是：</p><p><img src="https://docs.python.org/3/_images/tulip_coro.png" alt="Control Flow of Coroutine"></p><p>这里有两个问题：</p><ol><li>谁向 event loop 注册了事件（及回调）？</li><li>程序从哪里恢复执行？</li></ol><p>程序从 <code>print_sum</code> 开始执行，执行到 <code>asyncio.sleep</code> 时需要暂停，那么肯定是在<code>sleep</code> 中向 event loop 注册了计时器事件。那们问题来了，当程序恢复执行时，它应该从哪里恢复呢？</p><p>从上面的流程图中，可以看见它是从 <code>print_sum</code> 开始恢复，但这样的话，<code>sleep</code> 注册事件时就需要知道是谁（即 <code>print_sum</code>）调用了它，这样才能在 callback 中指定从<code>print_sum</code> 开始恢复执行！</p><p>但如果不是从 <code>print_sum</code> 恢复执行，那么一样的，从 <code>sleep</code> 恢复执行后，<code>sleep</code>需要知道接下来返回到什么位置（即 compute 函数中的 await 位置）， asyncio 又是如何做到这点的？</p><p>那么事实（代码实现）是怎样的呢？</p><p>当我们把一个协程用 <code>loop.run_until_complete</code> （或其它相似方法）执行时，event loop 会把它包裹成一个<a href="https://github.com/python/cpython/blob/3.6/Lib/asyncio/tasks.py#L23" target="_blank" rel="noopener">Task</a> 。当协程开始执行或被唤醒时，Task 的<a href="https://github.com/python/cpython/blob/3.6/Lib/asyncio/tasks.py#L164" target="_blank" rel="noopener">_step</a>方法会被调用，<a href="https://github.com/python/cpython/blob/3.6/Lib/asyncio/tasks.py#L180" target="_blank" rel="noopener">这里</a> 它会调用 <code>coro.send(None)</code> 来执行/唤醒它包裹着的协程。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> exc <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">    <span class="comment"># We use the `send` method directly, because coroutines</span></span><br><span class="line">    <span class="comment"># don't have `__iter__` and `__next__` methods.</span></span><br><span class="line">    result = coro.send(<span class="keyword">None</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    result = coro.throw(exc)</span><br></pre></td></tr></table></figure><p>注意到这里将 <code>coro.send</code> 的结果赋值给了 <code>result</code>，那么它会返回什么呢？在我们这个例子中，协程链的最末尾是 <code>asyncio.sleep</code>，我们看看 <a href="https://github.com/python/cpython/blob/3.6/Lib/asyncio/tasks.py#L469" target="_blank" rel="noopener">它的实现</a>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(delay, result=None, *, loop=None)</span>:</span></span><br><span class="line">    <span class="string">"""Coroutine that completes after a given time (in seconds)."""</span></span><br><span class="line">    <span class="keyword">if</span> delay == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> loop <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        loop = events.get_event_loop()</span><br><span class="line">    future = loop.create_future()</span><br><span class="line">    h = future._loop.call_later(delay,</span><br><span class="line">                                futures._set_result_unless_cancelled,</span><br><span class="line">                                future, result)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">yield</span> <span class="keyword">from</span> future)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        h.cancel()</span><br></pre></td></tr></table></figure><p>这里它创建了一个 <code>future</code> 并为它注册了事件（<code>call_later</code>），最终调用了 <code>yield from future</code> 返回。它代表什么呢？我们已经假设你明白 <code>yield from</code> 的使用方法，这代表 Python 会首先调用 <code>future.__iter__</code> 函数，我们来看看<a href="https://github.com/python/cpython/blob/3.6/Lib/asyncio/futures.py#L329" target="_blank" rel="noopener">它长什么样</a>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.done():</span><br><span class="line">        self._asyncio_future_blocking = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">yield</span> self  <span class="comment"># This tells Task to wait for completion.</span></span><br><span class="line">    <span class="keyword">assert</span> self.done(), <span class="string">"yield from wasn't used with future"</span></span><br><span class="line">    <span class="keyword">return</span> self.result()  <span class="comment"># May raise too.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> compat.PY35:</span><br><span class="line">    __await__ = __iter__ <span class="comment"># make compatible with 'await' expression</span></span><br></pre></td></tr></table></figure><p>注意这里的 <code>yield self</code>！也就是说 future 在第一次执行到这里时，会暂停执行并返回它自己，由于 coroutine 中使用的都是 <code>yield from/await</code> （它们在接收的参数上有区别，但在本文的讨论中没有区别），因此这个值会一直向上传递，到 <code>Task._step</code>函数的 <code>result = coro.send(None)</code> 这里，那我们来看看 <code>Task</code> 对 <code>result</code> 做了什么，重要的是<a href="https://github.com/python/cpython/blob/3.6/Lib/asyncio/tasks.py#L216" target="_blank" rel="noopener">这一句</a>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result.add_done_callback(self._wakeup)</span><br></pre></td></tr></table></figure><p>也就是说 task(<code>print_sum</code>) 得到了最内层暂停的 <code>sleep</code> 生成的 future 并为该future 注册了一个回调，使得在 <code>future.set_result</code> 被调用时，<code>task._wakeup</code> 会被调用。这部分的逻辑可以看<a href="https://github.com/python/cpython/blob/3.6/Lib/asyncio/futures.py#L303" target="_blank" rel="noopener">这里</a>。</p><p>我们再回过头来看看 <code>future.set_result</code> 会在什么时候被调用，在 <code>asyncio.sleep</code>函数里，我们为 event loop 注册了一个回调函数：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h = future._loop.call_later(delay,</span><br><span class="line">                            futures._set_result_unless_cancelled,</span><br><span class="line">                            future, result)</span><br></pre></td></tr></table></figure><p>那么这个 <a href="https://github.com/python/cpython/blob/3.6/Lib/asyncio/futures.py#L344" target="_blank" rel="noopener">_set_result_unless_cancelled</a> 是这样的：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_set_result_unless_cancelled</span><span class="params">(fut, result)</span>:</span></span><br><span class="line">    <span class="string">"""Helper setting the result only if the future was not cancelled."""</span></span><br><span class="line">    <span class="keyword">if</span> fut.cancelled():</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    fut.set_result(result)</span><br></pre></td></tr></table></figure><p>因此，所有的流程应该是这样的：</p><img src="/2017/understand-python-asyncio/asyncio-flow.png"><h2 id="小结"><a class="header-anchor" href="#小结">#</a>小结</h2><p>那么 asyncio 做为一个库，做了什么，没做什么？</p><ol><li>控制流的暂停与恢复，这是通过 Python 内部的 Generator（生成器）相关的功能实现的。</li><li>协程链，即把不同协程链链接在一起的机制。依旧是通过 Python 的内置支持，即async/await，或者说是生成器的 yield from。</li><li>Event Loop，这个是 asyncio 实现的。它决定了我们能对什么事件进行异步操作，目前只支持定时器与网络 IO 的异步。</li><li>协程链的控制流恢复，即内部的协程暂停了，恢复时却需要从最外层的协程开始恢复。这是 asyncio 实现的内容。</li><li>其它的库支持，这里指的是像 <code>asyncio.sleep()</code> 这种协程链的最内层的协程，因此我们一般不希望自己去调用 event loop 注册/注销事件。</li></ol><p>因此，如果没有 asyncio，我们要实现相应的功能，主要的内容就是 Event Loop 及控制流的恢复，最后再加上一些好用的协程函数。</p><h2 id="扩展阅读"><a class="header-anchor" href="#扩展阅读">#</a>扩展阅读</h2><ul><li><a href="https://www.slideshare.net/saghul/asyncio-internals" target="_blank" rel="noopener">asyncio internals</a> 关于 asyncio 内部的一些机制。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;协程 (coroutine) 几乎是 Python 里最为复杂的特性之一了，这篇文章我们来说一说
asyncio 的内部实现机制，借此来理解一门语言要支持协程需要做的工作。&lt;/p&gt;
&lt;p&gt;本文需要提前了解 Python 的 &lt;code&gt;yeild from&lt;/code&gt; 语
      
    
    </summary>
    
      <category term="Notes" scheme="http://lotabout.github.io/categories/Notes/"/>
    
    
      <category term="python" scheme="http://lotabout.github.io/tags/python/"/>
    
      <category term="asyncio" scheme="http://lotabout.github.io/tags/asyncio/"/>
    
      <category term="coroutine" scheme="http://lotabout.github.io/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>评：30 多年的编码经验浓缩成的 10 条最佳实践</title>
    <link href="http://lotabout.github.io/2017/comment-on-10-tips-for-writing-better-code/"/>
    <id>http://lotabout.github.io/2017/comment-on-10-tips-for-writing-better-code/</id>
    <published>2017-09-01T09:51:38.000Z</published>
    <updated>2018-01-30T13:53:38.955Z</updated>
    
    <content type="html"><![CDATA[<p>文章<a href="https://my.oschina.net/editorial-story/blog/1525762?p=3&amp;temp=1504230510405" target="_blank" rel="noopener">30 多年的编码经验浓缩成的 10 条最佳实践</a>原文出自 <a href="https://cdiggins.github.io/blog/programming-tips.html" target="_blank" rel="noopener">10 Tips for Writting BetterCode</a>。我认为这 10 条原则挺有帮助，所以本文想对这些原则做一些评价，说说我的看法，可以的话顺便给一些例子。建议看这篇文章之前先阅读原文。</p><blockquote><p>事实上，我们可以将好的代码等同为 <strong>可重用</strong> 的代码</p></blockquote><p>文章里说“可重用”也是文中罗列的 10 条原则的“背后驱动”。那么什么样的设计才是“可重用”的呢？其实早有大神提出了“高内聚，低耦合”的指标。“高内聚”说的是一个模块作为一个整体，功能要“专一”；“低耦合”说的是不同模块间的联系尽可能少。之后可以看到原文提到的 10 条原则很大程序上与之有关。</p><h2 id="遵循单一职责原则"><a class="header-anchor" href="#遵循单一职责原则">#</a>遵循单一职责原则</h2><blockquote><p>函数是程序员的工具中最重要的抽象形式。它们能更多地被重复使用，你需要编写的代码就越少，代码也因此变得更可靠。较小的函数遵循单一职责原则更有可能被重复使用。</p></blockquote><p>这条原则几乎就是“高内聚”的另一种说法，只不是“高内聚”谈论的是模块，而这里谈论的是函数。</p><p>这里举一个 <a href="https://stackoverflow.com/a/10830225/826907" target="_blank" rel="noopener">StackOverflow 关于高内聚的一个例子</a>。假设你创建一个类用来将两个数相加，与此同时，这个类还创建了一个窗口用来显示相加的结果。这个类就是“低内聚”的。因为做加法和创建窗口这两件事没什么相关性，创建窗口是“显示”的部分，而加法是“逻辑”的部分。</p><p>按照“单一职责”的原则来说的话，这个类的职责是不单一的，因此我们很难去重用这个类，因为除非我们的需求正好是要做加法，同时要将结果在一个窗口显示，否则这个类并不能被重用。</p><p>换句话说，如果一个函数有多个职责，那只有在使用者同时需要这几个职责的时候，才能重用这个函数。因此保持函数/类的单一职责，有利于重用。</p><h2 id="尽量减少共享状态"><a class="header-anchor" href="#尽量减少共享状态">#</a>尽量减少共享状态</h2><blockquote><p>你应该尽量减少函数之间的隐式共享状态，无论它是文件作用域的变量还是对象的成员字段，这有利于明确要求把值作为参数。当能明确地显示函数需要什么才可以产生所需的结果时，代码会变得更容易理解和重用。</p></blockquote><blockquote><p>对此的一个推论是，在一个对象中，相对于成员变量，你更应该优先选择静态的无状态变量 (static stateless variables)。</p></blockquote><p>首先讲讲什么是“共享状态”。这里提了两个：“文件作用域变量”及“对象的成员字段”。分别举例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g_config = read_configuration(<span class="string">'config.ini'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(message)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(g_config[<span class="string">'log_file'</span>], <span class="string">'w'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(message)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_config</span><span class="params">(key, value)</span>:</span></span><br><span class="line">    g_config[key] = value</span><br></pre></td></tr></table></figure><p>这里，<code>g_config</code> 变量存在于整个文件里，所以称为“文件作用域变量”。并且 <code>log</code> 函数与 <code>update_config</code> 函数之间共享了 <code>g_config</code> 这个状态。上面这种写法也可以写成类的形式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, config_file)</span>:</span></span><br><span class="line">        self.g_config = read_configuration(config_file)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(self, message)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(self.g_config[<span class="string">'log_file'</span>], <span class="string">'w'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            fp.write(message)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_config</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self.g_config[key] = value</span><br></pre></td></tr></table></figure><p>这一次，由于 <code>g_config</code> 是类的“成员字段”，而 <code>log</code> 与 <code>update_config</code> 者依赖于这个变量，所以也称他们共享了这个状态。</p><p><strong>为什么要减少状态共享</strong>？共享状态增加了函数间的“耦合”，可能会引起：</p><ol><li>代码不好阅读，因为必须同时理解共享状态的各个函数。</li><li>当修改了其中一个函数时，另外的函数的逻辑可能会发生改变，因此代码难以维护。</li><li>不利于多线程运行。容易造成竞争。</li></ol><p>因此，推荐尽量把函数运行需要的状态通过参数传递给函数，如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(config, message)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(config[<span class="string">'log_file'</span>], <span class="string">'w'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        fp.write(message)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_config</span><span class="params">(config, key, value)</span>:</span></span><br><span class="line">    config[key] = value</span><br><span class="line">g_config = read_configuration(<span class="string">'config.ini'</span>)</span><br><span class="line">log(g_config, <span class="string">"error here"</span>)</span><br></pre></td></tr></table></figure><p>至于 <code>static stateless variables</code>，<code>static</code> 代表它不是“成员变量”， <code>stateless</code>的含义应该等同于 <code>final</code> ，也就是说如果要共享状态，最好就用类变量而非成员变量，同时，变量最好是“不可变的”。</p><h2 id="将-副作用-局部化"><a class="header-anchor" href="#将-副作用-局部化">#</a>将“副作用”局部化</h2><blockquote><p>理想的副作用（例如：打印到控制台、日志记录、更改全局状态、文件系统操作等）应该被放置到单独的模块中，而不是散布在整个代码里面。函数中的一些“副作用”功能往往违反了单一职责原则。</p></blockquote><p>“副作用(side effect)”是指在某个域（如函数域）里修改了域之外的状态。</p><ol><li>副作用一般伴随着状态共享，这种代码非常难理解。</li><li>有副作用的代码一般都是“线程不安全”的。</li></ol><p>这里不深入这个话题，最好的方法就是尽量减少副作用的代码。感举的话，可以考虑参考我之前的文章： <a href="/2017/Side-Effects/" title="在面向对象语言中写纯函数！">在面向对象语言中写纯函数！</a></p><h2 id="优先使用不变的对象"><a class="header-anchor" href="#优先使用不变的对象">#</a>优先使用不变的对象</h2><blockquote><p>如果一个对象的状态在其构造函数中仅被设置一次，并且从不再次更改，则调试会变得更加容易，因为只要构造正确就能保持有效。这也是降低软件项目复杂性的最简单方法之一。</p></blockquote><p>有这样一句话：<code>Shared Mutable State is the root of evil</code>，共享的，可变的状态是万恶之源。为什么，因为共享意味着它们之间是“耦合的”，没法单独分析/工作。可变的意味着这个共享是会传染的，改变了共享的状态，所有依赖该状态的单元都可能发生变化。</p><p>有一些语言干脆禁止使用可变变量（不准确），如 Haskell, Clojure 等。另一些语言则试图阻止变量的“共享”，如 Rust。那么在如 C/C++/Java 之类的语言中，虽然语言本身没有过多的限制，但我们还是应该自己限制自己，减少不必要的麻烦。</p><h2 id="多用接口少用类"><a class="header-anchor" href="#多用接口少用类">#</a>多用接口少用类</h2><blockquote><p>接收接口的函数（或 C++ 中的模板参数和概念）比在类上运行的函数更具可重用性。</p></blockquote><p>我认为究其原因，主要是一般定义接口的时候不会指定成员变量，也就是说不会去限制这些接口（方法）的实现细节，而定义类的时候往往会这么做，这就意味着接口具有更高的可扩展性，（API 的）用户也更可能去实现某个接口而非继承某个类，因此一个接收接口的函数更有可能被调用。</p><p>另外，java 是不允许多继承的，但可以实现多个接口，如果函数接收的是类，那么意味着用户的类必须继承我们指定的类，那用户自己就无法构建类的继承结构了。</p><h2 id="对模块应用良好的原则"><a class="header-anchor" href="#对模块应用良好的原则">#</a>对模块应用良好的原则</h2><blockquote><p>寻找机会将软件项目分解成更小的模块（例如库和应用程序），以促进模块级别的重用。对于模块，应该遵循的一些关键原则是：</p></blockquote><blockquote><ol><li>尽可能减少依赖</li><li>每个项目应该有一个明确的职责</li><li>不要重复自身</li></ol></blockquote><p>这里的原则其实跟上面说的其它原则有一定重复：</p><ul><li>“尽可能减少依赖”。其实就是减少该模块和其它模块的耦合。</li><li>“每个项目应该有一个明确的职责” 则对应着“高内聚”</li><li>“不要重复自身” (don’t repeat yourself) 翻译有误，应该指不要自己写重复的代码，也就是说重复的代码要写成函数。</li></ul><h2 id="避免继承"><a class="header-anchor" href="#避免继承">#</a>避免继承</h2><blockquote><p>在面向对象编程中，继承 —— 特别是和虚拟函数结合使用时，在可重用性方面往往是一条死胡同。我很少有成功的使用或编写重载类的库的经历。</p></blockquote><p>这点可能有人会质疑，但我个人是深信不疑的。在 <strong>实践中</strong> 我们很少能真正写出一个能重用的类，这里的重用指的是被继承。</p><p>归要结底，（我认为）这是面向对象这种方法的缺陷，世上的事物真的能用类继承的方式良好地表达吗？通常面向对象的教材会举两个例子，一个是“动物”，另一个是“图形”。“图形”的例子是说各种图形都有“求面积”的方法，正方形可以继续并实现自己的“面积”算法，“圆形”也相似。因此可以通过继承来表达，“面积”函数就是虚函数，实现多态。“动物”的例子也类似，例如狗会叫，但不同的狗叫声不同，因此可以继承“狗”类。</p><p>有人（找不到出处了）质疑，上面的例子都是良好定义的一些关系，但现实中遇到的问题真的能良好的表达吗？不可否认面向对象有它适合的领域，如 GUI 的各个组件等。还有一些问题能用面向对象（继承）但不一定是最佳的方案，例如报表，及不同细节的报表。另一些问题可能就不太能用面向对象来表达了。</p><p>这一点我建议阅读一些其它的讨论：</p><ol><li><a href="https://softwareengineering.stackexchange.com/questions/137994/does-object-oriented-programming-really-model-the-real-world" target="_blank" rel="noopener">Does OOP really model the real world</a></li><li><a href="https://softwareengineering.stackexchange.com/questions/59387/is-oop-hard-because-it-is-not-natural" target="_blank" rel="noopener">Is OOP hard because it is not natual</a></li></ol><p>最后，要注意的是“继承”继承的是父类的“数据+方法”，更多的时候我们关心的只是“方法”的“继承”。</p><h2 id="将测试作为设计和开发的一部分"><a class="header-anchor" href="#将测试作为设计和开发的一部分">#</a>将测试作为设计和开发的一部分</h2><blockquote><p>我不是测试驱动开发的坚定分子，但开始编码时先编写测试代码会使得代码十分自然地遵循许多指导原则。这也有助于尽早发现错误。不过要注意避免编写无用的测试，良好的编码实践意味着更高级别的测试（例如单元测试中的集成测试或特征测试）在揭示缺陷方面更有效。</p></blockquote><p>我的测试经验不是特别丰富，同时我也不是测试驱动开发的坚定分子。</p><p>关于“编码之前先写测试”，我认为它最重要的作用是让我们对该函数/类的功能有更清晰的认识，而不是一开始就把头扎到实现细节中，这点非常用帮助。</p><p>“避免编写无用的测试”这点也很重要。测试与开发的矛盾点在于，测试是要保证开发的功能是没问题的，但开发（函数的内容/作用）是会随着时间变动的。因此测试的粒度是一个十分重要的问题。目前我也在学习中。</p><h2 id="优先使用标准库而不是手写的"><a class="header-anchor" href="#优先使用标准库而不是手写的">#</a>优先使用标准库而不是手写的</h2><blockquote><p>我经常看到更好版本的 std::vector 或 std::string，但这几乎总是浪费时间和精力。一个明显的事实是 —— 你正在为一个新的地方引入 bug，其他开发者也不太可能重用你的代码，因为没有被广泛理解、支持和测试。</p></blockquote><p><code>+10086</code>。去 hack 一个标准库应该永远是你 <strong>最后</strong> 想到的解决方法。你永远无法想象一个标准库需要经过多少测试，踩过多少坑才能稳定。并且，如果出现 bug，他们的支持也是十分富贵的，我们的时间永远不够用。</p><h2 id="避免编写新的代码"><a class="header-anchor" href="#避免编写新的代码">#</a>避免编写新的代码</h2><blockquote><p>这是每个程序员都应遵循的最重要的教诲：最好的代码就是还没写的代码。你写的代码越多，你将遇到的问题就越多，查找和修复错误就越困难。</p></blockquote><blockquote><p>在写一行代码之前先问一问自己，有没有一个工具、函数或者库已经实现了你所需要的功能？你真的需要自己实现这个功能，而不是调用一个已经存在的功能吗？</p></blockquote><p>跟上一点有点重复，但我觉得这里有两个要点：</p><ol><li>能不写尽量不要自己写。</li><li>如果非要写，尽量写得短。</li></ol><p>同上一点一样，要写出 bug free 的代码很困难，并且后续维护需要很大的精力。最后即使是同一个功能，一般代码量小的更好，因为你需要处理（记忆/思考）的量小。</p><h2 id="总结"><a class="header-anchor" href="#总结">#</a>总结</h2><p>所谓的编码原则，不是说非遵守不可，我们要去了解它背后的原理，原因然后因地制宜。理论上，如果你是一个天才，可以处理无穷的复杂事物，那么原则毫无意义。但对于普通人而言，如果事件变得越来越复杂，我们的处理能力是下降的，我们状态差的时候更是如此。</p><p>所以，平时遵守一些原则能提高我们在状态差时候的处理能力。</p><p>最后，我认为“高内聚，低耦合”的内因实际上是减少我们同时需要处理/理解/记忆的代码量，以此来提高我们的效率。希望对你有所启发。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文章
&lt;a href=&quot;https://my.oschina.net/editorial-story/blog/1525762?p=3&amp;amp;temp=1504230510405&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;30 多年的编码经验浓缩成的
      
    
    </summary>
    
      <category term="Comment" scheme="http://lotabout.github.io/categories/Comment/"/>
    
    
      <category term="comment" scheme="http://lotabout.github.io/tags/comment/"/>
    
      <category term="programming" scheme="http://lotabout.github.io/tags/programming/"/>
    
      <category term="tips" scheme="http://lotabout.github.io/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>Python Generator</title>
    <link href="http://lotabout.github.io/2017/Python-Generator/"/>
    <id>http://lotabout.github.io/2017/Python-Generator/</id>
    <published>2017-08-29T21:25:35.000Z</published>
    <updated>2018-01-30T13:53:38.939Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中的生成器 (generator) 是一个十分有用的工具，它让我们能方便地生成迭代器(iterator)。这篇文章里，我们就来说说什么是生成器，生成器有什么作用以及如何使用。</p><p>本文需要你对 Python 基本的语法有一定的了解，并知道 iterator 是什么，且我们可以通过 <code>next(iterator)</code> 来获取 <code>iterator</code> 的下一个值。</p><h2 id="iterator-简介"><a class="header-anchor" href="#iterator-简介">#</a>iterator 简介</h2><p>想象这样一个需求，我们需要从网上获取一些图片，这些图片的名字的规律是数字递增，因此我们有类似下面的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_images</span><span class="params">(n)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        result.append(get_image_by_id(i))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">images = get_images(n)</span><br></pre></td></tr></table></figure><p>现在，假设我们需要对图片进行一些操作，但依当前图片的情况不同，我们也许不需要后续的图片，并且， <code>get_image_by_id</code> 是一个很耗时的操作，我们希望在不需要的情况下尽量避免调用它。</p><p>换句话说，我们希望能对 <code>get_image_by_id</code> 进行懒执行 (lazy evalution)。这也不难，我们可以这么做：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image_id = <span class="number">-1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next_image</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> image_id</span><br><span class="line">    image_id += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> get_image_by_id(image_id)</span><br><span class="line"></span><br><span class="line">image0 = next_image()</span><br><span class="line">image1 = next_image()</span><br></pre></td></tr></table></figure><p>这里函数 <code>next_image</code> 使用了全局的变量保存当前已获取的图片的 <code>id</code>，使用全局变量决定了 <code>next_image</code> 无法被两个个体使用。例如两个人都想从头获取图片，这是没法完成的，因此我们定义一个类来解决这个问题：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageRepository</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.image_id = <span class="number">-1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next_image</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.image_id += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> get_image_by_id(self.image_id)</span><br><span class="line"></span><br><span class="line">repo = ImageRepository()</span><br><span class="line">image0 = repo.next_image()</span><br><span class="line">image1 = repo.next_image()</span><br></pre></td></tr></table></figure><p>如果你熟悉 iterator 的话，应该知道上面这个需求是一个典型的 iterator，因此我们可以实现 <code>__iter__</code> 及 <code>__next__</code> 方法来将它变成一个 iterator，从而充分利用iterator 现成的一些工具：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageRepository</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.image_id = <span class="number">-1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.image_id += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> get_image_by_id(self.image_id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> image <span class="keyword">in</span> ImageRepository():</span><br><span class="line">    <span class="comment"># some operation on each image</span></span><br></pre></td></tr></table></figure><p>是不是也没什么难度？下面我们看看其它的一些思路。</p><h2 id="从-iterator-到-generator"><a class="header-anchor" href="#从-iterator-到-generator">#</a>从 Iterator 到 Generator</h2><p>上面的 iterator 的例子有一个特点，就是它需要我们自己去管理 iterator 的状态，即<code>image_id</code>。这种写法跟我们的思维差异较大，因此懒惰的我们希望有一些更好，更方便的写法，这就是我们要介绍的 genrator 。</p><p>在 Python 中，只要一个函数中使用了 <code>yeild</code> 这个关键字，就代表这个函数是一个生成器 (generator)。而 <code>yield</code> 的作用就相当于让 Python 帮我们把一个“串行”的逻辑转换成 iterator 的形式。例如，上面的例子用 generator 的语法写就变成了：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image_repository</span><span class="params">()</span></span></span><br><span class="line">    image_id = -1</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        image_id += <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> get_image_by_id(image_id)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> image <span class="keyword">in</span> image_repository():</span><br><span class="line">    <span class="comment"># do some operation</span></span><br></pre></td></tr></table></figure><p>首先，就写法上，这种写法与我们最先开始的循环写法最为类似；其次，在功能上，调用这个函数 <code>image_repository()</code> 返回的是一个 generator object，它实现了 iterator 的方法，因此可以将它作为普通的 iterator 使用 （<code>for ... in ...</code>）；最后，注意到我们所要做的，就是把平时使用的 <code>return</code> 换成 <code>yield</code> 就可以了。</p><p>再举个例子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">()</span>:</span></span><br><span class="line">    a, b = (<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a+b</span><br><span class="line"></span><br><span class="line">fibos = fibonacci()</span><br><span class="line">next(fibos) <span class="comment">#=&gt; 0</span></span><br><span class="line">next(fibos) <span class="comment">#=&gt; 1</span></span><br><span class="line">next(fibos) <span class="comment">#=&gt; 1</span></span><br><span class="line">next(fibos) <span class="comment">#=&gt; 2</span></span><br></pre></td></tr></table></figure><p>通过 generator ，我们很轻松地就写出了一个无限的斐波那契数列函数。如果要手写的话，它相当于：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.a, self.b = (<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        result = self.a</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">fibos = Fibonacci()</span><br><span class="line">next(fibos) <span class="comment">#=&gt; 0</span></span><br><span class="line">next(fibos) <span class="comment">#=&gt; 1</span></span><br><span class="line">next(fibos) <span class="comment">#=&gt; 1</span></span><br><span class="line">next(fibos) <span class="comment">#=&gt; 2</span></span><br></pre></td></tr></table></figure><p>显然 generator 的写法更为清晰，且符合我们平时书写顺序结构的习惯。</p><h2 id="generator-与控制流"><a class="header-anchor" href="#generator-与控制流">#</a>Generator 与控制流</h2><p>前面我们提到，Generator 的作用其实是实现了懒执行 (lazy evalution) ，即在真正需要某个值的时候才真正去计算这个值。因此，更进一步，Generator 其实是返回了控制流。当一个 generator 执行到 yeild 语句时，它便保存当前的状态，返回所给的结果（也可以没有），并将当前的执行流还给调用它的函数，而当再次调用它时，Generator就从上次 yield 的位置继续执行。例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'before'</span>)</span><br><span class="line">    <span class="keyword">yield</span>            <span class="comment"># break 1</span></span><br><span class="line">    print(<span class="string">'middle'</span>)</span><br><span class="line">    <span class="keyword">yield</span>            <span class="comment"># break 2</span></span><br><span class="line">    print(<span class="string">'after'</span>)</span><br><span class="line"></span><br><span class="line">x = generator()</span><br><span class="line">next(x)</span><br><span class="line"><span class="comment">#=&gt; before</span></span><br><span class="line">next(x)</span><br><span class="line"><span class="comment">#=&gt; middle</span></span><br><span class="line">next(x)</span><br><span class="line"><span class="comment">#=&gt; after</span></span><br><span class="line"><span class="comment">#=&gt; exception StopIteration</span></span><br></pre></td></tr></table></figure><p>可以看到，第一次调用 <code>next(x)</code>，程序执行到了 <code>break 1</code> 处就返回了，第二次调用<code>next(x)</code> 时从之前 yield 的位置（即 <code>break 1</code>） 处继续执行。同理，第三次调用<code>next(x)</code> 时从 <code>break 2</code> 恢复执行，最终退出函数时，抛出 <code>StopIteration</code> 异常，代表 <code>generator</code> 已经退出。</p><p>为什么要提到 generator 的“控制流”的特点呢？因为 genrator 表允许我们从“顺序”执行流中暂时退出，利用这个特性我们能做一些很有意义的事。</p><p>例如，我们提供一个 API，它要求调用者首先调用 <code>call_this_first</code> 然后做一些操作，然后再调用 <code>call_this_second</code>，再做一些操作，最后调用 <code>call_this_last</code>。也就是说这些 API 的调用是有顺序的。但 API 的提供者并没有办法强制使用者按我们所说的顺序去调用这几个 API。但有了 generator，我们可以用另一种形式提供 API，如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">API</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_this_first</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_this_second</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_this_last</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">api</span><span class="params">()</span>:</span></span><br><span class="line">    first()</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    second()</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    last()</span><br></pre></td></tr></table></figure><p>通过这种方式提供的 API 能有效防止使用者的误用。这也是 generator 能 “从控制流中返回” 这个特性的一个应用。</p><h2 id="yield-加强版"><a class="header-anchor" href="#yield-加强版">#</a>yield 加强版</h2><p>上面我们说到 Generator 允许我们暂停控制流，并返回一些数据，之后能从暂停的位置恢复。那我们就会有疑问，既然暂停控制流时能返回数据，那恢复控制流的时候能不能传递数据到暂停的位置呢？ <a href="https://www.python.org/dev/peps/pep-0342" target="_blank" rel="noopener">PEP 342</a>中就加入了相关的支持。这个需求说起来比较抽象，我们举个例子：</p><p>想象我们要写一个函数，计算多个数的平均值，我们称它为 <code>averager</code>。我们希望每次调用都提供一个新的数，并返回至今为止所有提供的数的平均值。让我们先来看看用generator 的加强版语法怎么实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        sum += (<span class="keyword">yield</span> sum / num <span class="keyword">if</span> num &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">x = averager()</span><br><span class="line">x.send(<span class="keyword">None</span>)</span><br><span class="line"><span class="comment">#=&gt; 0</span></span><br><span class="line">x.send(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#=&gt; 1.0</span></span><br><span class="line">x.send(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#=&gt; 1.5</span></span><br><span class="line">x.send(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#=&gt; 2.0</span></span><br></pre></td></tr></table></figure><p>这个加强版的语法是这么工作的： yield 之前是语句，现在是表达式，是表达式就意味着我们能这么写 <code>x = yield 10</code>, <code>y = 10 + (yield)</code>, <code>foo(yield 42)</code>。Python 规定，除非 yield 左边直接跟着等号（不准确），否则必须用扩号括起来。</p><p>当 Python 执行到 yield 表达式时，它首先计算 yield 右边的表达式，上例中即为<code>sum / num if num &gt; 0 else 0</code> 的值，暂停当前的控制流，并返回。之后，除了可以用<code>next(generator)</code> 的方式（即 iterator  的方式）来恢复控制流之外，还可以通过<code>generator.send(some_value)</code> 来传递一些值。例如上例中，如果我们调用<code>x.send(3)</code> 则 Python 恢复控制流， <code>(yield sum/sum ...)</code> 的值则为我们赋予的<code>3</code>，并接着执行 <code>sum += 3</code> 以及之后的语句。注意的是，如果这时我们用的是<code>next(generator)</code> 则它等价为 <code>generator.send(None)</code>。</p><p>最后要注意的是，刚调用 generator 生成 generator object 时，函数并没有真正运行，也就是说这时控制流并不在 <code>yield</code> 表达式上等待用户传递值，因此我们需要先调用 <code>generate.send(None)</code> 或 <code>next(generator)</code> 来触发最开始的执行。</p><p>那么说到这里，用 generator 来实现这个需求明显没有其它方法好用，例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Averager</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.sum = <span class="number">0</span></span><br><span class="line">        self.num = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">avg_num</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.sum += n</span><br><span class="line">        self.num += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.sum / self.num</span><br><span class="line">averager = Averager()</span><br><span class="line">averager.avg_num(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#=&gt; 1.0</span></span><br><span class="line">averager.avg_num(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#=&gt; 1.5</span></span><br><span class="line">averager.avg_num(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#=&gt; 2.0</span></span><br></pre></td></tr></table></figure><p>这种写法比 generator 更直观，并且用户调用起来也方便，不需要额外调用一次<code>x.send(None)</code>。显然 generator 的加强版语法并不是为了专门用来解决我们这里提到的需求的。它要解决的真正问题是支持协程 (coroutine) 来实现异步编程的。由于这个问题比较复杂，这里就不深入讨论了。</p><h2 id="yield-from"><a class="header-anchor" href="#yield-from">#</a>yield from</h2><p>考虑我们有多个 generator 并想把 generator 组合起来，如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">odds</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evens</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">odd_even</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> odds(n):</span><br><span class="line">        <span class="keyword">yield</span> x</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> evens(n):</span><br><span class="line">        <span class="keyword">yield</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> odd_even(<span class="number">6</span>):</span><br><span class="line">    print(x)</span><br><span class="line"><span class="comment">#=&gt; 1, 3, 5, 0, 2, 4</span></span><br></pre></td></tr></table></figure><p><code>for x in generator(): yield x</code> 这种写法不太方便，因此 <a href="https://www.python.org/dev/peps/pep-0380/" target="_blank" rel="noopener">PEP380</a> 引入了 <code>yield from</code> 语法，来替代我们前面说的这种语法，因此上面的例子可以改成：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">odd_even</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> odds(n)</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> evens(n)</span><br></pre></td></tr></table></figure><p>是不是清晰许多？</p><h2 id="小结"><a class="header-anchor" href="#小结">#</a>小结</h2><p>我们简单介绍了 iterator ；之后介绍了使用 generator 来更方便地生成 iterator；之后举例说明了 yield 的加强版语法，最后介绍了 yield from 语法。</p><ol><li>当一个函数里使用了 yield 关键字，则该函数就被称为一个 generator （生成器）。</li><li>Generator 被调用时返回 Generator Object，它实现了 iterator 的接口。所以可以认为 generator 调用后返回了一个 iterator。</li><li>yeild 可以从控制流中暂时退出，之后可以从退出的位置恢复。通过加强版的语法还能在恢复时传递一些值给 generator。</li><li>yield from 语法可以用来方便地组合不同的 generator。</li></ol><p>Generator 是生成 iterator 非常方便的工具，希望本文能让你对 generator 有更好的了解，也希望 Generator 能给你今后的 Python 生涯带来更多的方便。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python 中的生成器 (generator) 是一个十分有用的工具，它让我们能方便地生成迭代器
(iterator)。这篇文章里，我们就来说说什么是生成器，生成器有什么作用以及如何使用。&lt;/p&gt;
&lt;p&gt;本文需要你对 Python 基本的语法有一定的了解，并知道 iter
      
    
    </summary>
    
      <category term="Notes" scheme="http://lotabout.github.io/categories/Notes/"/>
    
    
      <category term="python" scheme="http://lotabout.github.io/tags/python/"/>
    
      <category term="Generator" scheme="http://lotabout.github.io/tags/Generator/"/>
    
  </entry>
  
  <entry>
    <title>Git: Those You Don&#39;t Want to Learn by Youself</title>
    <link href="http://lotabout.github.io/2017/Git-Those-Don-t-Learn-by-Yourself/"/>
    <id>http://lotabout.github.io/2017/Git-Those-Don-t-Learn-by-Yourself/</id>
    <published>2017-08-02T21:02:57.000Z</published>
    <updated>2018-01-30T13:53:38.923Z</updated>
    
    <content type="html"><![CDATA[<p>This is a slide I made explaining the ugly internal detail of git.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;This is a slide I made explaining the ugly internal detail of git.&lt;/p&gt;

      
    
    </summary>
    
      <category term="Knowledge" scheme="http://lotabout.github.io/categories/Knowledge/"/>
    
    
      <category term="Git" scheme="http://lotabout.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>在面向对象语言中写纯函数！</title>
    <link href="http://lotabout.github.io/2017/Side-Effects/"/>
    <id>http://lotabout.github.io/2017/Side-Effects/</id>
    <published>2017-04-30T11:21:10.000Z</published>
    <updated>2018-01-30T13:53:38.939Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们说函数式编程时，提到的都是 lambda 表达式，也即函数式编程中的“函数是头等公民”的特点，然而函数式的另一个重要特点： <strong>无副作用</strong> ，在我看来更为重要。它可以在任何语言中实际应用。今天，我们来谈一谈面向对象中的“副作用”。</p><h2 id="什么是副作用"><a class="header-anchor" href="#什么是副作用">#</a>什么是副作用</h2><blockquote><p>In computer science, a function or expression is said to have a side effect ifit modifies some state outside its scope or has an observable interaction withits calling functions or the outside world.</p></blockquote><p>根据维基百科，在计算机中，当一个函数或表达式修改了自己的域之外的状态或是与函数外的东西有可见的交互，我们就称该函数或表达式有副作用（side effect）。</p><p>说得更直白一些，如果调用一个函数，该函数可以（一个或多个）返回值，除此之外，如果函数还修改了参数、全局变量，或是做了 I/O 操作，都说这个函数有副作用。没有副作用的函数被称为 <strong>纯函数</strong>。</p><p>为什么要去讨论一个函数有没有“副作用”呢？这是因为，如果一个函数没有副作用，那么可以推出这个函数的结果只依赖于它的参数，这个特性可以给我们带来一些好处，例如：</p><ul><li>易于并行，同时多线程执行一个纯函数肯定是不会产生竞争的。因为函数需要的资源全都由参数提供。</li><li>容易对它做缓存，因为函数的结果只与参数有关，因此可以容易对它做缓存。</li><li>易于 debug 及单元测试。只需要给定参数，检查结果即可。</li><li>如果一个纯函数的结果没有被使用，则删掉这个函数（及对它的调用）对程序的结果不影响。</li></ul><h2 id="一些非纯函数"><a class="header-anchor" href="#一些非纯函数">#</a>一些非纯函数</h2><p>Java 中的各种 setter <strong>不是</strong> 纯函数，因为它修改了函数的参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">int</span> newBalance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Account account = <span class="keyword">new</span> Account();</span><br><span class="line">account.setBalance(<span class="number">100</span>); <span class="comment">// equals to setBalance(account, 100);</span></span><br></pre></td></tr></table></figure><p>在上例中，执行完 <code>setBalance(account, 100)</code> 后， <code>account</code> 的值发生了变化，因此不是纯函数。推而广之，任何类的方法，只要修改了类的属性，则该函数不是纯函数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">last = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextRand</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> last</span><br><span class="line">    last = last * <span class="number">13</span> % <span class="number">7</span></span><br><span class="line">    <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure><p>上例中， <code>nextRand()</code> 函数读取并写入全局变量，因此 <strong>不是</strong> 纯函数。要注意的是只要读入 <strong>或</strong> 写入全局变量都属于副作用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def func(x):</span><br><span class="line">    print &quot;x is &quot;, x</span><br></pre></td></tr></table></figure><p>上述函数做了 I/O 操作，也不是纯函数。</p><p>结合上面的例子，其实有一个特别简单的判断，如果用相同的参数调用一个函数任意多次，它们返回的结果是一样的，则这个函数就是 <strong>纯函数</strong>，反之则不是。</p><h2 id="副作用的危害"><a class="header-anchor" href="#副作用的危害">#</a>副作用的危害</h2><p>单看上面的例子，我们看不出“副作用”的巨大危害，但 <strong>避免副作用</strong> 的思想一定要有！这里举一个在工作上被副作用坑害的例子，用以警告大家去避免函数的副作用。</p><p>这个例子是真实场景下出现的一个问题，只是这里简化了其中的逻辑与需求。</p><p>需求是检查两个帐号的信息，判断它们是否雷同/相似，并给出相同的字段。于是有了类似下面的代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountComparator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map sameFields = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">private</span> Map diffFields = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">compare</span><span class="params">(Account a, Account b)</span> </span>&#123;</span><br><span class="line">        bool sameName = a.getName().equal(b.getName());</span><br><span class="line">        bool sameEmail = a.getEmail().equal(b.getEmail());</span><br><span class="line">        bool sameBirthday = a.getBirthday().equal(b.getBirthday());</span><br><span class="line"></span><br><span class="line">        saveField(<span class="string">"name"</span>, sameName, a.getName());</span><br><span class="line">        saveField(<span class="string">"email"</span>, sameEmail, a.getEmail());</span><br><span class="line">        saveField(<span class="string">"birthday"</span>, sameEmail, b.getBirthday());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> gatherResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveField</span><span class="params">(String fieldName, bool isSame, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isSame) &#123;</span><br><span class="line">            sameFields.put(fieldName, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            diffFields.put(fieldName, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Result <span class="title">gatherResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Result ret = <span class="keyword">new</span> Result();</span><br><span class="line">        sameFields.forEach((k, v) -&gt; ret.addSameField(k, v));</span><br><span class="line">        diffFields.forEach((k, v) -&gt; ret.addDiffField(k, v));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AccountComparator comparator = <span class="keyword">new</span> AccountComparator();</span><br><span class="line">Result result = comparator.compare(a, b);</span><br></pre></td></tr></table></figure><p>这里只对比了其中的三项信息，调用 <code>saveField</code> 把该项结果保存起来，最后调用<code>gatherResult</code> 得到结果。在谈如何改进之前，这个类有什么问题？</p><p>相信你已经发现了，问题在于这个 <code>compare</code> 函数并不是纯函数！那会有什么问题呢？考虑下面的代码。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Account a = new Account(&quot;nameA&quot;, &quot;emailA&quot;, &quot;BirthdayA&quot;);</span><br><span class="line">Account b = new Account(&quot;nameA&quot;, &quot;emailB&quot;, &quot;BirthdayB&quot;);</span><br><span class="line">Account duplication_a = new Account(&quot;nameA&quot;, &quot;emailA&quot;, &quot;BirthdayA&quot;);</span><br><span class="line"></span><br><span class="line">AccountComparator comparator = new AccountComparator();</span><br><span class="line">Result result1 = comparator.compare(a, b);</span><br><span class="line">Result result2 = comparator.compare(a, duplication_a);</span><br></pre></td></tr></table></figure><p>那么 <code>result2</code> 中的 <code>diffFields</code> 包含什么值？我们的预期是空，因为 <code>a</code> 与<code>duplication_a</code> 是完全一样的，但实际返回时它却包含了 <code>email, birthday</code>。这些字段是调用 <code>compare(a, b)</code> 时留下的！</p><p>上例的 bug 是非常难发现的，因为做单元测试时如果没有测连续的调用，或都连续调用的参数设置不好，都是触发不了这个 bug 的。一般也不会特意想到这种例子，否则看代码就能发现 bug 了。</p><p>下面是其中的一种改法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountComparator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title">compare</span><span class="params">(Account a, Account b)</span> </span>&#123;</span><br><span class="line">        Map sameFields = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map diffFields = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        bool sameName = a.getName().equal(b.getName());</span><br><span class="line">        bool sameEmail = a.getEmail().equal(b.getEmail());</span><br><span class="line">        bool sameBirthday = a.getBirthday().equal(b.getBirthday());</span><br><span class="line"></span><br><span class="line">        saveField(<span class="string">"name"</span>, sameName, a.getName());</span><br><span class="line">        saveField(<span class="string">"email"</span>, sameEmail, a.getEmail());</span><br><span class="line">        saveField(<span class="string">"birthday"</span>, sameEmail, b.getBirthday());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> gatherResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveField</span><span class="params">(Map sameFields, Map diffFields,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String fieldName, bool isSame, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isSame) &#123;</span><br><span class="line">            sameFields.put(fieldName, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            diffFields.put(fieldName, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">gatherResult</span><span class="params">(Map sameFields, Map diffFields)</span> </span>&#123;</span><br><span class="line">        Result ret = <span class="keyword">new</span> Result();</span><br><span class="line">        sameFields.forEach((k, v) -&gt; ret.addSameField(k, v));</span><br><span class="line">        diffFields.forEach((k, v) -&gt; ret.addDiffField(k, v));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的是这里的 <code>saveField</code> 函数依旧不是纯函数，因为它修改了函数的参数<code>sameFields</code> 与 <code>diffFields</code>。但这里这么做是因为 Java 里对不可变数据结构(immutable datastructure) 的支持较差。</p><p>这样一来，函数 <code>compare</code> 就变成了一个纯函数，因为它所需要的状态全部存在于函数内（包括参数）。就样多次调用该函数也不会有问题的。</p><h2 id="纯函数的-副作用"><a class="header-anchor" href="#纯函数的-副作用">#</a>纯函数的“副作用”</h2><p>如果写的函数都是纯函数会怎么样呢？</p><p>首先是没办法与外界交流，因为不能用任意的 I/O操作，这在实际的编程中是绝不可能的。也因此，我们所能做的是尽量将“副作用”缩小到几个函数内，而大部分函数依旧是纯函数。</p><p>另一个问题就是效率。就像上面看到的，任意类的 setter 方法都不是纯函数，那么如果非要把类的各种方法都变成纯函数，则每个方法都应该返回一个新的类，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">setBalance</span><span class="params">(<span class="keyword">int</span> newBalance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Account(newBalance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Account account = <span class="keyword">new</span> Account(<span class="number">10</span>);</span><br><span class="line">account = account.setBalance(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>这样就会造成一些效率上的问题。那么是不是使用纯函数就是一个平衡的问题。这又涉及面向对象风格与函数式风格的对比。这里不想过多讨论这种问题，但即使是面向对象的语言，也可以尽量写成纯函数。</p><h2 id="小结"><a class="header-anchor" href="#小结">#</a>小结</h2><p>函数式编程的思想包含很多内容，本文介绍了其中的“无副作用”概念，并给出一个实例，试图说明副作用的坏处，并给出一个“无副作用”的实现。最后说明了纯函数的一些弱点。</p><p>想要表达的内容其实很简单：即使在面向对象语言中，我们也应该尽量写出无副作用的函数。</p><p>希望大家在平时的工作学习中，能够应用得上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常我们说函数式编程时，提到的都是 lambda 表达式，也即函数式编程中的“函数是头等公民”的特点，然而函数式的另一个重要特点： &lt;strong&gt;无副作用&lt;/strong&gt; ，在我看来更为重要。它可以在任何语言中实际应用。今天，我们来谈一谈面向对象中的“副作用”。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="FP" scheme="http://lotabout.github.io/tags/FP/"/>
    
  </entry>
  
  <entry>
    <title>简谈 Rust 中的错误处理</title>
    <link href="http://lotabout.github.io/2017/rust-error-handling/"/>
    <id>http://lotabout.github.io/2017/rust-error-handling/</id>
    <published>2017-01-07T14:17:00.000Z</published>
    <updated>2018-01-30T13:53:38.967Z</updated>
    
    <content type="html"><![CDATA[<p>在学习 Rust 的过程中，错误处理是一个必需要迈过的坎。主要原因是所有的标准库都以统一的方式处理错误，我们就来谈一谈 Rust 中是如何处理错误的吧。</p><p><a href="https://doc.rust-lang.org/book/error-handling.html" target="_blank" rel="noopener">Rust Book</a> 对 rust 中的错误处理有详细的讲解，本文对其中一些选择背后的原因进行了思考和总结。强烈建议先看原文。</p><h2 id="返回错误与异常处理"><a class="header-anchor" href="#返回错误与异常处理">#</a>返回错误与异常处理</h2><p>名正则言顺，我们先说说什么是“错误”，什么是“异常”：</p><ul><li><strong>错误</strong>：运行时发生的不寻常的、 <strong>超出预期</strong> 的行为，这些问题只能通过修改程序来解决。例如内存不足。</li><li><strong>异常</strong> ：运行时发生的不规则的、 <strong>意料之内</strong> 的行为。例如尝试读取“读保护”的文件。</li></ul><p>可以看到，“错误”与“异常”的区别是“意料之内”还是“之外”。因此，本文中所说的“错误”其实都指的是异常（这也是 Java 中既存在异常 Exception 又存在 Error 的原因）。</p><p>在 C 语言中，错误处理的机制是十分简陋的，例如 Linux 的系统调用如果出错，会将错误记录在一个全局变量 <code>errno</code> 中，<code>errno</code> 是一个整型值，操作系统事先约定好不同值代表不同含义。</p><p>到了 C++/Java/Python 语言则采用了异常处理机制，当函数错误时，可以抛出预定义或自定义的异常，语言本身提供了捕获这个异常/错误的语法（即 <code>try ... catch ...</code>）</p><p>异常处理相比于返回错误的好处是分离了接收和处理错误的代码。如果只用 C 语言的方式，则函数的返回值需要有一部分用于表示错误。例如 <code>read</code> 函数 在出错时返回<code>-1</code>；正确时返回 <code>0</code> 或以上，而函数的调用者必须自己区分正确也错误的情形。还有一些更坏的情况，例如一个除法函数，它返回的任何值理论上都可能是“正确值”。那么当发生除 0 错误时，它应该返回什么值来表示错误呢？</p><p>在写作本文时，我也倍受困扰，“返回错误”的方式明明一无是处，为什么 Rust 还要选择这种方式呢？ <a href="https://news.ycombinator.com/item?id=9545647" target="_blank" rel="noopener">这篇文章</a> 中提出的观点是：Rust 是一门相对底层的语言，因此在某些情况下，异常处理所需要的额外性能开销是不可接受的。或许这就是 Rust 不包含异常的原因吧。</p><h2 id="option"><a class="header-anchor" href="#option">#</a>Option</h2><p>首先要注意到 Rust 中是没有 <code>null</code> 的概念的，我们无法像其它语言（如 C++/java）一样创建一个变量，并赋值为 <code>null</code> 来代表变量当前没有内容。在 Rust 中，做不到！</p><p>于是 Rust 自定义了一个结构体来表示可能为空的情形，这应该是向 Haskell 的<code>Maybe</code> 借鉴的吧。结构体长这样：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当你想表示 <code>null</code> 时就可以用 <code>None</code> 代替。而其它的赋值则可以用<code>Some(...)</code> 完成。带来的问题是：如何访问 <code>Some(...)</code> 里的内容呢？Rust 的答案是pattern matching:</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> opt &#123;</span><br><span class="line">    <span class="literal">Some</span>(value) =&gt; <span class="built_in">println!</span>(<span class="string">"value = &#123;&#125;"</span>, value),</span><br><span class="line">    <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"Got None"</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而由于 <code>match</code> 会保证我们列出了所有可能的 <code>pattern</code>，即不允许只处理 <code>Some</code> 而不处理 <code>None</code>，因此保证了程序员必定处理了值为 <code>null</code> 的情形。就说机不机智。</p><p>不过事实是程序员都懒啊，如果我明确知道不可能出现为 <code>null</code> 的情况，还需要写一堆的 <code>match</code>，着实闹心，于是 rust 又为我们开了小灶，提供了 <code>unwrap</code> 函数：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">unwrap</span></span>(<span class="keyword">self</span>) -&gt; T &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="built_in">Option</span>::<span class="literal">Some</span>(val) =&gt; val,</span><br><span class="line">            <span class="built_in">Option</span>::<span class="literal">None</span> =&gt;</span><br><span class="line">              <span class="built_in">panic!</span>(<span class="string">"called `Option::unwrap()` on a `None` value"</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的 <code>panic!</code>，它的作用是输出错误的信息并退出程序（严格地说并不一定退出程序，rust 1.9 添加了<a href="https://blog.rust-lang.org/2016/05/26/Rust-1.9.html" target="_blank" rel="noopener">catch_unwind</a> 支持）。所以可以通过调用 <code>option.unwrap()</code> 来获取 <code>option</code> 中包裹的值。言下之意就是：你说不可能出现 <code>null</code> 是吧，我且相信你，但如果出了问题我就不管了。</p><p>当然，使用 <code>Option</code> 的过程中还有其它一些问题，例如，程序员知道可能出现 <code>None</code>的情况，当出现时使用一个默认的值。这种情况 rust 提供了函数<code>unwrap_or(default)</code> 来方便书写。再例如两个函数都返回 <code>Option</code>，我们想将一个函数的输出作为另一个函数的输入，此时可以使用 <code>and_then</code> 来减少手写 <code>match</code> 的次数。</p><p>还有一些其它的情况可以参考 <a href="https://doc.rust-lang.org/book/error-handling.html#composing-optiont-values" target="_blank" rel="noopener">官方文档</a></p><h2 id="result-option-加强版"><a class="header-anchor" href="#result-option-加强版">#</a>Result: Option 加强版</h2><p><code>Option</code> 可以用来表示 <code>null</code> 的情形，这解决了前文提到的一个问题，如果除法函数发生了除 0 操作，返回什么值来表示发生错误了？有了 <code>Option</code> 我们可以返回<code>None</code>。</p><p>但如果可能发生多个错误呢？这时，<code>Option</code> 可以认为只能表示发生一个错误的情形。于是 Rust 提出了另一个结构，用于包裹真正的结果：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="literal">Ok</span>(T),</span><br><span class="line">    <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是表示了两种可能，如果没有错误，则返回 <code>Ok(..)</code>，反之返回 <code>Err(..)</code>。而由于 <code>Err</code> 可以带参数，所以即使发生了多个错误也能正常表示。甚至，我们可以将<code>Option</code> 定义为：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Option</span></span>&lt;T&gt; = <span class="built_in">Result</span>&lt;T, ()&gt;;</span><br></pre></td></tr></table></figure><p>它和上节中的 <code>Option</code> 在作用上是等价的。另一方面，我们也看到，其实rust 处理错误就是返回不同的结构体，某些表示正确，某些表示错误，我们甚至可以抛开这些结构，直接用 <code>tuple</code> 来表示：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Result</span></span>&lt;T, E&gt; = (T, E);</span><br></pre></td></tr></table></figure><p>这样的话，是不是和 Go 语言又很相似了呢？所以这里要强调的是，返回错误的重点在于“返回”，也就是说，错误也是“正常值”的一种。</p><p>我们马上又要回到了 <code>Option</code> 的老路了，但这之前，我们发现 <code>Err(E)</code> 中，<code>E</code> 可以是任意类型，也就是说我们可以将错误指定为任意类型。我们先指定为 <code>i32</code> 来模仿 C中的 <code>errno</code> ：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">read</span></span>(...) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">usize</span>, <span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> size &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">Ok</span>(size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">Err</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果调用者对发生的错误感兴趣，则可以继续用 pattern matching 来解构：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">match</span> read(...) &#123;</span><br><span class="line">    <span class="literal">Ok</span>(size) =&gt; ...</span><br><span class="line">    <span class="literal">Err</span>(<span class="number">1</span>) =&gt; ... file not found ...</span><br><span class="line">    <span class="literal">Err</span>(<span class="number">2</span>) =&gt; ... is directory ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，像 <code>Option</code> 一样，如果程序员对发生的错误不感兴趣，rust 也提供了 <code>unwrap</code>方法来避免手写 <code>match</code>。</p><p>要注意的是，无论是 <code>Option</code> 还是 <code>Result</code>，它们更像是一种约定，而不是机制。假设你是 API 的提供者，你当然也可以按你自己喜欢的方式返回错误。而关于 <code>Option</code>和 <code>Result</code>，重要的是标准库的所有函数都遵守这样的约定，也因此对它们的支持相比你自定义的类型要丰富，这也是我们最好遵守这种约定的主要原因。</p><h2 id="错误传递"><a class="header-anchor" href="#错误传递">#</a>错误传递</h2><p>上面说了半天，其实依旧没有提及如何表示“错误”本身。无论是 <code>Option</code> 还是<code>Result</code> 其实都只是“包裹”错误的容器罢了。那么什么才是“错误”呢？</p><p>上节其实提到了，在 <code>Result</code> 中，“错误”其实可以是任意类型。但下文我们会提到，rust 定义了一个 trait: <code>Error</code>。而之所以需要这个定义，是因为我们在错误传递上遇到了问题。</p><p>想像一下，当你调用某个函数时，你不在乎它们会产生什么错误，无论错误是什么，你只想把它们往外丢，就像异常处理里的 <code>throw</code> 一样。考虑 <a href="https://doc.rust-lang.org/book/error-handling.html#the-limits-of-combinators" target="_blank" rel="noopener">下面例子</a> ，</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"><span class="keyword">use</span> std::path::Path;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">file_double</span></span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = File::open(file_path).unwrap(); <span class="comment">// error 1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> contents = <span class="built_in">String</span>::new();</span><br><span class="line">    file.read_to_string(&amp;<span class="keyword">mut</span> contents).unwrap(); <span class="comment">// error 2</span></span><br><span class="line">    <span class="keyword">let</span> n: <span class="built_in">i32</span> = contents.trim().parse().unwrap(); <span class="comment">// error 3</span></span><br><span class="line">    <span class="number">2</span> * n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> doubled = file_double(<span class="string">"foobar"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, doubled);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个遇到的问题就是：调用的函数会返回不同类型的错误，如果我们要抛出错误，要将它们定义成什么类型？眉头一皱，计上心头。定义成 <code>String</code> 不就行了？于是我们将代码改写成：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">file_double</span></span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = <span class="keyword">match</span> File::open(file_path) &#123;</span><br><span class="line">        <span class="literal">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="literal">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(err.to_string()),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> contents = <span class="built_in">String</span>::new();</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(err) = file.read_to_string(&amp;<span class="keyword">mut</span> contents) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">Err</span>(err.to_string());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> n: <span class="built_in">i32</span> = <span class="keyword">match</span> contents.trim().parse() &#123;</span><br><span class="line">        <span class="literal">Ok</span>(n) =&gt; n,</span><br><span class="line">        <span class="literal">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(err.to_string()),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="literal">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们手工地将各种错误通过 <code>err.to_string()</code> 转成 <code>String</code> 类型并返回。回想一下我们的初衷，就是在 <code>file_double</code> 中我们不想处理调用子函数时产生的任何错误，我们认为应该让调用者处理，可由于返回值要统一，因此我们把它转换成<code>String</code> 类型后再返回。</p><p>第二个问题是：我们手写了许多的 <code>match</code> 语句来解构返回值，浪费时间，降低代码的可读性，这个问题可以通过写一个宏来解决。</p><h2 id="try-宏"><a class="header-anchor" href="#try-宏">#</a>try! 宏</h2><p>为了解决上节的第二个问题，我们定义了一个宏，命名为 <code>try!</code>，如下：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> try &#123;</span><br><span class="line">    ($e:expr) =&gt; (<span class="keyword">match</span> $e &#123;</span><br><span class="line">        <span class="literal">Ok</span>(val) =&gt; val,</span><br><span class="line">        <span class="literal">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(err),</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了它，上节的代码就可以写成：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">file_double</span></span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, <span class="built_in">String</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = <span class="built_in">try!</span>(File::open(file_path).map_err(|e| e.to_string()));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> contents = <span class="built_in">String</span>::new();</span><br><span class="line">    <span class="built_in">try!</span>(file.read_to_string(&amp;<span class="keyword">mut</span> contents).map_err(|e| e.to_string()));</span><br><span class="line">    <span class="keyword">let</span> n = <span class="built_in">try!</span>(contents.trim().parse::&lt;<span class="built_in">i32</span>&gt;().map_err(|e| e.to_string()));</span><br><span class="line">    <span class="literal">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 <code>.map_err(|e| e.to_string())</code> 做的是将 <code>err</code> 转成 <code>String</code> 类型。可以看到，代码一下简短了许多。然而我们写了许多 <code>.map_err(..)</code> 来转换类型也着实丑陋，下面就来解决这个问题。</p><h2 id="error-trait"><a class="header-anchor" href="#error-trait">#</a>Error Trait</h2><p>把错误转换成 <code>String</code> 返回有一个不足，就是我们失去了错误原本的类型信息，不利于函数的调用者再针对错误的类型做不同的处理。于是 Rust 为我们定了一个统一的类型来表示错误：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::&#123;<span class="built_in">Debug</span>, Display&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Error</span></span>: <span class="built_in">Debug</span> + Display &#123;</span><br><span class="line">  <span class="comment">/// A short description of the error.</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">description</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">str</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// The lower level cause of this error, if any.</span></span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">cause</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;&amp;Error&gt; &#123; <span class="literal">None</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有的错误全都实现了 <code>Error</code> trait，则我们很容易就能创建自己的错误类型，目的则是统一函数里会发生的错误，继续上节的例子，我们首先定义自己的类型：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::num;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We derive `Debug` because all types should probably derive `Debug`.</span></span><br><span class="line"><span class="comment">// This gives us a reasonable human readable description of `CliError` values.</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CliError</span></span> &#123;</span><br><span class="line">    Io(io::Error),</span><br><span class="line">    Parse(num::ParseIntError),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>File::open(file_path)</code> 会返回 <code>io::Error</code> 类型，通过 <code>CliError::Io</code> 可以转换成 <code>CliError</code></li><li><code>file.read_to_string</code> 与 <code>File::open</code> 类似，也返回 <code>io::Error</code> 的错误。</li><li><code>String::parse</code> 则返回的是 <code>num::ParseIntError</code> 类型，能通过<code>CliError::Parse</code> 转换成 <code>CliError</code> 类型。</li></ul><p>当然，为了保证与其它类型的兼容性，我们也需要为 <code>CliError</code> 实现 <code>Error</code> triat：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::error;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> fmt::Display <span class="keyword">for</span> CliError &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fmt</span></span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) -&gt; fmt::<span class="built_in">Result</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="comment">// Both underlying errors already impl `Display`, so we defer to</span></span><br><span class="line">            <span class="comment">// their implementations.</span></span><br><span class="line">            CliError::Io(<span class="keyword">ref</span> err) =&gt; <span class="built_in">write!</span>(f, <span class="string">"IO error: &#123;&#125;"</span>, err),</span><br><span class="line">            CliError::Parse(<span class="keyword">ref</span> err) =&gt; <span class="built_in">write!</span>(f, <span class="string">"Parse error: &#123;&#125;"</span>, err),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> error::Error <span class="keyword">for</span> CliError &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">description</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="comment">// Both underlying errors already impl `Error`, so we defer to their</span></span><br><span class="line">        <span class="comment">// implementations.</span></span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            CliError::Io(<span class="keyword">ref</span> err) =&gt; err.description(),</span><br><span class="line">            CliError::Parse(<span class="keyword">ref</span> err) =&gt; err.description(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">cause</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;&amp;error::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> *<span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="comment">// N.B. Both of these implicitly cast `err` from their concrete</span></span><br><span class="line">            <span class="comment">// types (either `&amp;io::Error` or `&amp;num::ParseIntError`)</span></span><br><span class="line">            <span class="comment">// to a trait object `&amp;Error`. This works because both error types</span></span><br><span class="line">            <span class="comment">// implement `Error`.</span></span><br><span class="line">            CliError::Io(<span class="keyword">ref</span> err) =&gt; <span class="literal">Some</span>(err),</span><br><span class="line">            CliError::Parse(<span class="keyword">ref</span> err) =&gt; <span class="literal">Some</span>(err),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，只要每个错误类型都实现了 <code>Error</code> trait，则很容易通过建立新的自定义类型来统一错误类型。</p><h2 id="from-trait"><a class="header-anchor" href="#from-trait">#</a>From trait</h2><p><code>Error</code> trait 虽然统一了错误类型，但我们依旧要写一堆 <code>.map_err(...)</code> 来转换类型，有没有什么更好的方法呢？rust 定义了一个通用的 triat 用于转换类型：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">From</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(T) -&gt; <span class="keyword">Self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次重申，有点类型于 Java 中的 <code>interface</code>，<code>trait</code> 只是一种“约定”，而约定之所以有用，是因为 rust 的标准库都遵守了这个约定。如 <code>From</code> 要求类型实现从其它类型的转换函数，例如你可以做下面的操作：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string: <span class="built_in">String</span> = <span class="built_in">From</span>::from(<span class="string">"foo"</span>);</span><br><span class="line"><span class="keyword">let</span> bytes: <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt; = <span class="built_in">From</span>::from(<span class="string">"foo"</span>);</span><br><span class="line"><span class="keyword">let</span> cow: ::std::borrow::Cow&lt;<span class="built_in">str</span>&gt; = <span class="built_in">From</span>::from(<span class="string">"foo"</span>);</span><br></pre></td></tr></table></figure><p>这是因为标准库中的 <code>String</code> 类型已经实现了 <code>From&lt;&amp;str&gt;</code>，另外几个也类似。</p><p>那么为什么上节中我们自定义的错误类型要实现 <code>Error</code> trait 呢？其中一个重要原因是标准库已经为 <code>Box&lt;Error&gt;</code> 实现了 <code>From</code> trait：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>, E: Error + <span class="symbol">'a</span>&gt; <span class="built_in">From</span>&lt;E&gt; <span class="keyword">for</span> <span class="built_in">Box</span>&lt;Error + <span class="symbol">'a</span>&gt;</span><br></pre></td></tr></table></figure><p>也因此我们可以用 <code>From::from</code> 来进行错误类型间的转换如下：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// We have to jump through some hoops to actually get error values.</span></span><br><span class="line"><span class="keyword">let</span> io_err: io::Error = io::Error::last_os_error();</span><br><span class="line"><span class="keyword">let</span> parse_err: num::ParseIntError = <span class="string">"not a number"</span>.parse::&lt;<span class="built_in">i32</span>&gt;().unwrap_err();</span><br><span class="line"></span><br><span class="line"><span class="comment">// OK, here are the conversions.</span></span><br><span class="line"><span class="keyword">let</span> err1: <span class="built_in">Box</span>&lt;Error&gt; = <span class="built_in">From</span>::from(io_err);</span><br><span class="line"><span class="keyword">let</span> err2: <span class="built_in">Box</span>&lt;Error&gt; = <span class="built_in">From</span>::from(parse_err);</span><br></pre></td></tr></table></figure><p>因此，有了 <code>Error</code> 和 <code>From</code> 两个 trait 及标准库对两个 trait 的实现，<code>try!</code> 宏的真正实现方式就进化了：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> try &#123;</span><br><span class="line">    ($e:expr) =&gt; (<span class="keyword">match</span> $e &#123;</span><br><span class="line">        <span class="literal">Ok</span>(val) =&gt; val,</span><br><span class="line">        <span class="literal">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(::std::convert::<span class="built_in">From</span>::from(err)),</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这两个工具，我们就可以：</p><ol><li>不定义自己的类型，而直接使用 <code>Box&lt;Error&gt;</code> 来统一错误类型。</li><li>用 <code>try!</code> 宏来传递错误。</li></ol><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">file_double</span></span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = <span class="built_in">try!</span>(File::open(file_path));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> contents = <span class="built_in">String</span>::new();</span><br><span class="line">    <span class="built_in">try!</span>(file.read_to_string(&amp;<span class="keyword">mut</span> contents));</span><br><span class="line">    <span class="keyword">let</span> n = <span class="built_in">try!</span>(contents.trim().parse::&lt;<span class="built_in">i32</span>&gt;());</span><br><span class="line">    <span class="literal">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完美！并且，在 rust 1.13 中加入了 <code>?</code> 操作符，用来替代 <code>try!</code> 因此可以这么写：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">file_double</span></span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = File::open(file_path)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> contents = <span class="built_in">String</span>::new();</span><br><span class="line">    file.read_to_string(&amp;<span class="keyword">mut</span> contents)?;</span><br><span class="line">    <span class="keyword">let</span> n = contents.trim().parse::&lt;<span class="built_in">i32</span>&gt;()?;</span><br><span class="line">    <span class="literal">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统一自定义错误类型"><a class="header-anchor" href="#统一自定义错误类型">#</a>统一自定义错误类型</h2><p>最后一个大问题是自定义错误类型。有了 <code>From</code> trait 之后，我们可以轻易地将任意实现了 <code>Error</code> trait 的错误转换成 <code>Box&lt;Error&gt;</code>，但如果我们要返回的不是<code>Box&lt;Error&gt;</code> 而是自定义错误，那要怎么办呢？答案也很简单，为可能出现的错误实现<code>From</code> trait。</p><p>上几节的例子中，可能出现的错误为 <code>io::Error</code> 和 <code>num::ParseIntError</code>，因此我们需要为 <code>CliError</code> 实现 <code>From&lt;io::Error&gt;</code> 和 <code>From&lt;num::ParseIntError&gt;</code>。如下：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">From</span>&lt;io::Error&gt; <span class="keyword">for</span> CliError &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(err: io::Error) -&gt; CliError &#123;</span><br><span class="line">        CliError::Io(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">From</span>&lt;num::ParseIntError&gt; <span class="keyword">for</span> CliError &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(err: num::ParseIntError) -&gt; CliError &#123;</span><br><span class="line">        CliError::Parse(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上述的实现，我们就可以写出如下代码：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">file_double</span></span>&lt;P: <span class="built_in">AsRef</span>&lt;Path&gt;&gt;(file_path: P) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, CliError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> file = <span class="built_in">try!</span>(File::open(file_path));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> contents = <span class="built_in">String</span>::new();</span><br><span class="line">    <span class="built_in">try!</span>(file.read_to_string(&amp;<span class="keyword">mut</span> contents));</span><br><span class="line">    <span class="keyword">let</span> n: <span class="built_in">i32</span> = <span class="built_in">try!</span>(contents.trim().parse());</span><br><span class="line">    <span class="literal">Ok</span>(<span class="number">2</span> * n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于搞定了！</p><h2 id="如何处理错误？"><a class="header-anchor" href="#如何处理错误？">#</a>如何处理错误？</h2><p>综上，在 rust 语言中，处理错误有几种方式：</p><p>对于函数的作者而言，返回值可以是：</p><ol><li>正常的值，即 <code>i32</code>, <code>String</code> 等等，表明该函数不可能发生错误。</li><li>返回 <code>Option</code> 表示函数可能会失败。</li><li>不自定义错误。返回 <code>Result&lt;..., Box&lt;Error&gt;&gt;</code> 。</li><li>返回自定义错误，如上例中的 <code>Result&lt;i32, CliError&gt;</code>。</li></ol><p>而当函数 <code>A</code> 调用的子函数 <code>B</code> 返回错误时，有几种处理的方式：</p><ol><li>不处理错误。即调用 <code>unwrap</code> 来获取返回数据。</li><li>在函数 <code>A</code> 内部处理。即通过 <code>match</code> 语句或 <code>unwrap_or</code> 等函数来处理返回值可能包含错误的情况。</li><li>当函数 <code>A</code> 返回值为 <code>Result</code> 且 <code>B</code> 的返回值也为 <code>Result</code> 时，可以通过<code>try!(B())</code> 来获得 <code>B</code> 的返回值。而若返回值为 <code>Err</code> 时，<code>try!</code> 会自动退出函数 <code>A</code> 并将错误进行处理后返回。</li></ol><p>最后，当函数的作用决定自定义错误类型（如 <code>CliError</code>）时，需要做几项操作：</p><ol><li>实现 <code>Error</code> trait。即实现 <code>description</code> 和 <code>cause</code> 函数，来提供错误的内容。</li><li>为可能发生的错误实现 <code>From</code> trait。如上文中 <code>CliError</code> 实现了<code>From&lt;io::Error&gt;</code> 和 <code>From&lt;num::ParseIntError&gt;</code>。</li></ol><p>上述两项工作完成后就可以放心地使用 <code>try!</code> 来获取子函数返回值的内容了。</p><h2 id="小结"><a class="header-anchor" href="#小结">#</a>小结</h2><p>本文首先区别介绍了“返回错误”和“异常处理”的区别。Rust 选择了“返回错误”的道路，本文也因此介绍了它面临了几个问题：</p><ol><li>如何表示返回值有错误？Rust 提供了 <code>Option</code> 与 <code>Result</code> 这两个“容器”来满足不同需求。</li><li>调用不同子函数可能返回不同错误类型，于是使用 <code>Error</code> trait 来统一类型。</li><li>解构返回值需要写大量 <code>match</code> 语句，Rust 引入宏 <code>try!</code> 来减少工作量。</li><li>不同错误类型间的转换需要写很多代码，Rust 引入 <code>From</code> trait 来减少程序员的输入。</li></ol><p>最后，若用户需要自定义错误类型，它需要同时实现 <code>Error</code> 与 <code>From</code> 两个 trait.</p><p>与其它语言对比，rust 的错误处理是相当地复杂。其中的重要原因是它更像是一种高层的约定，而非语言层面的机制，换句话说，你用其它的语言也能实现类似的功能。</p><p>由于我写过的 rust 程序都不大，并且没有写过库，因此对这套错误处理方式的优点并不是特别“感同深受”，也许它更适合大型程序的开发吧。</p><h2 id="reference"><a class="header-anchor" href="#reference">#</a>Reference</h2><ul><li><a href="http://blog.honeypot.io/errors-and-exceptions-in-rust/" target="_blank" rel="noopener">http://blog.honeypot.io/errors-and-exceptions-in-rust/</a> : Rust 处理错误异常的方式，介绍了不同语言处理异常的方式。</li><li><a href="https://news.ycombinator.com/item?id=9545647" target="_blank" rel="noopener">https://news.ycombinator.com/item?id=9545647</a> : 关于 rust 为何不采用“异常处理”的讨论。</li><li><a href="http://www.infoq.com/cn/news/2012/11/go-error-handle" target="_blank" rel="noopener">http://www.infoq.com/cn/news/2012/11/go-error-handle</a> : Go语言的错误处理机制引发争议。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习 Rust 的过程中，错误处理是一个必需要迈过的坎。主要原因是所有的标准库都以统一的方式处理错误，我们就来谈一谈 Rust 中是如何处理错误的吧。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/book/error-handlin
      
    
    </summary>
    
      <category term="Knowledge" scheme="http://lotabout.github.io/categories/Knowledge/"/>
    
    
      <category term="rust" scheme="http://lotabout.github.io/tags/rust/"/>
    
      <category term="error-handling" scheme="http://lotabout.github.io/tags/error-handling/"/>
    
  </entry>
  
  <entry>
    <title>理解 Rust 中的生命周期</title>
    <link href="http://lotabout.github.io/2016/rust-lifetime/"/>
    <id>http://lotabout.github.io/2016/rust-lifetime/</id>
    <published>2016-12-24T22:00:08.000Z</published>
    <updated>2018-01-30T13:53:38.967Z</updated>
    
    <content type="html"><![CDATA[<p>Ownership, Borrowing 与 Lifetime 共同成就了 rust 中的内存安全，也是 rust 语言中最精髓的创造，我们就来学习学习它们究竟是什么，为什么要引入这些概念。</p><h2 id="权力与风险共生"><a class="header-anchor" href="#权力与风险共生">#</a>权力与风险共生</h2><p>权力与风险往往是一同出现。如果你被授予了制作核弹的权力，那么在你制造它时其实是面临着诸多的风险。</p><p>早期的编程语言如 C/C++ 赋予了程序员极高的权力，它们能自由地操作计算机的内存（虚拟内存），程序员们因此可以尽情地挥洒着自己的创造力来达到更强大的性能。</p><p>然而这份权力也带来了许多风险，例如一个常见的问题是内存泄漏，即忘记 <code>free</code> 自己<code>malloc</code> 出来的内存，程序不断运行最终导致内存耗尽，C++ 通过引入析构函数防止程序员忘记释放内存。但另一个常见问题依旧无法避免，即访问已经释放的内存，或者尝试释放已经释放的内存。</p><p>人们认识到，内存管理存在的风险已经远远大于它所赋予的权力带来的好处，Java 语言的便通过引入 GC （垃圾回收器）替程序员管理内存。程序员不再需要关心什么时候释放内存，因为 JVM 会自动处理；也不必害怕会访问已经释放的内存，因为只要内存还有变量使用，JVM 就不会去释放它。而对应的，GC 剥夺了程序员自由操作内存的权力，付出的代价便是额外的性能开销。</p><h2 id="什么是内存安全"><a class="header-anchor" href="#什么是内存安全">#</a>什么是内存安全</h2><p>让我们举个例子：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">vector</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; elem = <span class="built_in">vector</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">vector</span>.push_back(some_string);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，<code>vector</code> 内部保存着一个数组，当 <code>push_back</code> 被调用时，它会查看该数组还有多少剩余空间，若空间不足，则会开辟新的空间，并将原数组的内容拷贝，如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this code might not compile, but you got the idea.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="built_in">string</span> elem)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size == <span class="keyword">this</span>.capacity) &#123;</span><br><span class="line">        <span class="built_in">string</span>* new_data = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="keyword">this</span>.capacity * <span class="number">2</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(new_data, <span class="keyword">this</span>.data, <span class="keyword">this</span>.size * <span class="keyword">sizeof</span>(<span class="built_in">string</span>*));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] <span class="keyword">this</span>.data;  <span class="comment">// the old array is free</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.data[<span class="keyword">this</span>.size++] = elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即在执行 <code>vector.push_back</code> 时，<code>elem</code> 指向的内存已经被释放了，造成了“访问已释放内存”的问题。也许程序不会直接崩溃，但极可能得到的错误的结果。</p><p>上面的例子中，产生“内存安全”的原因是同时达成了两个因素：</p><ol><li>存在别名。即不同的变量（<code>elem</code> 和 <code>vector</code>）指向了同一块内存区域。</li><li>存在修改。即 <code>push_back</code> 过程中 <code>delete</code> 了该内存。</li></ol><h2 id="ownership-及-borrowing"><a class="header-anchor" href="#ownership-及-borrowing">#</a>Ownership 及 Borrowing</h2><p>Rust 提出了 Ownership（所有权）及 Borrowing（租借）的概念，做了如下限制：</p><ol><li>所有的资源只能有一个主人（owner）。</li><li>其它人可以租借这个资源。</li><li>但当这个资源被借走时，主人不允许释放或修改该资源。</li></ol><p>可以看到，这 3 条规则的目的是防止“存在别名”和“存在修改”同时发生。一个资源如果被共享了，则不允许修改；如果想修改资源，则不允许共享。</p><p>想象有一本书（资源），则依照上述 3 个准则，有：</p><p><em>1</em>. 它只有一个主人。当然你可以把书“给”其它人，所有权就归其它人。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"book"</span>); <span class="comment">// "book" 归 a 所有</span></span><br><span class="line">    <span class="keyword">let</span> b = a;                    <span class="comment">// a 将 "book" 转让给 b</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a = &#123;&#125;"</span>, a);        <span class="comment">// 出错，a 已经无权使用资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>2</em>. 允许租借。你可以先把书“给”别人，别人用完后再“给”你。但 rust 中的“借”，则保证了对方不会不把书还你。例如：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"book"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> b = a;            <span class="comment">// a 将 "book" 转让给 b</span></span><br><span class="line">    &#125;                         <span class="comment">// b 死了，却没有将 "book" 还给 a</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a = '&#123;&#125;'"</span>, a);  <span class="comment">// 出错，"book" 不在 a 手上。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以将书借给多个人（想象几个人一起看书），前提是它们只想“读”这本书，即 rust允许有多个不可变的引用 (&amp;T)：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="built_in">String</span>::from(<span class="string">"book"</span>);</span><br><span class="line">    <span class="keyword">let</span> b = &amp;a;       <span class="comment">// "book" 借给 b 只读</span></span><br><span class="line">    <span class="keyword">let</span> c = &amp;a;       <span class="comment">// "book" 同时 借给 c 只读</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a = '&#123;&#125;'"</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b = '&#123;&#125;'"</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b = '&#123;&#125;'"</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有一个人将书借去“写”，则不允许其它人同时“读”，即 rust 只允许有一个可变的引用(&amp;mut T)：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="built_in">String</span>::from(<span class="string">"book"</span>);</span><br><span class="line">    <span class="keyword">let</span> b = &amp;<span class="keyword">mut</span> a;       <span class="comment">// "book" 借给 b 写</span></span><br><span class="line">    <span class="keyword">let</span> c = &amp;a;           <span class="comment">// 错误，有人借书“写”时，不允许借来“读”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>3</em>. 如果有人还借着书（无论读写），不允许主人修改或销毁书。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> b;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"book"</span>);</span><br><span class="line">        b = &amp;a;         <span class="comment">// "book" 借给 b</span></span><br><span class="line">    &#125;                   <span class="comment">// 错误，a 死亡，需要销毁书，但 b 还借着书</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，当拥有者死亡时，rust 会销毁它拥有的资源，由于一份资源只有一个拥有者，因此并不会造成销毁多次的情况。</p><p>这三条规则一起，保证了“存在别名”和“存在修改”不会同时发生，最终保证了内存安全，同时防止了多线程的数据竞争。</p><h2 id="lifetime"><a class="header-anchor" href="#lifetime">#</a>Lifetime</h2><p>我们再回顾上节关于 Ownership 的三条规则，以便分析：</p><ol><li>所有的资源只能有一个主人（owner）。</li><li>其它人可以租借这个资源。<ol><li>同时可以有多个不可变引用(&amp;T)。</li><li>同时只可以有一个可变引用(&amp;mut T)。</li></ol></li><li>但当这个资源被借走时，主人不允许释放或修改该资源。</li></ol><p>rust 需要在编译期间就要保证我们的代码不会违反上面三条限制，这样做最大的优点就是不需要 runtime ，也就是不会增加额外的运行时开销。那么编译器又是如何通过静态分析来保证上述限制呢？</p><p>一个很直接的想法（不代表实际实现）是：为每个变量维护一个集合，集合里记录该变量的引用（Reference，也就是租借），那么编译器在分析时就能确保规则 #1, #2.1, #2.2。而为了确保规则 #3，rust 编译器需要确保一个资源的 reference 的存在时间小于比资源的 Owner 的存在时间。</p><p>Lifetime （生命周期）是 rust 编译器用于对比资源 owner 的存在时间与资源reference 的存在时间的工具。Lifetime 可以理解为变量的作用域，例如：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="built_in">String</span>::from(<span class="string">"book"</span>);</span><br><span class="line">    <span class="keyword">let</span> x = &amp;a;</span><br><span class="line">    a.push(<span class="string">'A'</span>);    <span class="comment">// 违反 #3 存在 a 的引用，不允许修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            &#123;    a    x    *    &#125;</span><br><span class="line">所有者 a:        |______________|</span><br><span class="line">借用者 x:             |_________|   x = &amp;a</span><br><span class="line">  修改 a:                  |        失败：存在 a 的引用 x 违反 #3</span><br></pre></td></tr></table></figure><p>而下例中</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="built_in">String</span>::from(<span class="string">"book"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> x = &amp;a;</span><br><span class="line">    &#125;                <span class="comment">// x 作用域结束</span></span><br><span class="line">    a.push(<span class="string">'A'</span>);     <span class="comment">// 成功：所有对 a  的引用已经结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应是作用域为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            &#123;    a    &#123;    x    &#125;    *    &#125;</span><br><span class="line">所有者 a:        |________________________|</span><br><span class="line">借用者 x:                  |____|            x = &amp;a</span><br><span class="line">  修改 a:                            |       成功：对 a 的引用已经结束</span><br></pre></td></tr></table></figure><p>可以看到，通过对作用域的分析，rust 编译器就能够保证资源的 owner 存活时间比资源的引用更长。</p><h3 id="人为标注生命周期"><a class="header-anchor" href="#人为标注生命周期">#</a>人为标注生命周期</h3><p>上面的例子较为简单，编译器可以做一些自动的分析来判断代码是否佥，但还有一些情况下，编译器并没有办法知道生命周期的是否合法，如：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(x: &amp;<span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> random() % <span class="number">2</span> == <span class="number">0</span> &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">String</span>::from(<span class="string">"X"</span>);</span><br><span class="line">    <span class="keyword">let</span> z;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> y = <span class="built_in">String</span>::from(<span class="string">"Y"</span>);</span><br><span class="line">        z = foo(&amp;x, &amp;y);</span><br><span class="line">    &#125;                       <span class="comment">// ①</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"z = &#123;&#125;"</span>, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中，如果 <code>foo</code> 返回了 <code>x</code> 的值，由于变量 <code>z</code> 生命周期小于 <code>x</code> 因此不会产生内存安全问题；但当 <code>foo</code> 返回 <code>y</code> 时，①处 <code>y</code> 作用域结束，但 <code>z</code> 依旧持有<code>y</code> 的引用，因此存在内存安全问题。</p><p>这里的问题是单凭静态分析本身并没有办法确定所有的生命周期，因此需要一定的人工介入，人为地给编译器一些提示：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> random() % <span class="number">2</span> == <span class="number">0</span> &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述标识的含义是，函数 <code>foo</code> 的返回值的生命周期，要小于任意参数的生命周期。有了这个提示，编译器就很容易知道下例中的代码违反了这个约定。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">String</span>::from(<span class="string">"X"</span>);</span><br><span class="line">    <span class="keyword">let</span> z;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">String</span>::from(<span class="string">"Y"</span>);</span><br><span class="line">    z = foo(&amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"z = &#123;&#125;"</span>, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给出作用域如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     &#123;    x    z    y     *    &#125;</span><br><span class="line">x:        |____________________|</span><br><span class="line">z:             |_______________|</span><br><span class="line">y:                  |__________|</span><br><span class="line">foo 的要求： Lifetime(z) &lt;= Lifetime(x) &amp; Lifetime(y) // 不成立</span><br></pre></td></tr></table></figure><h3 id="作用域作为生命周期的不足"><a class="header-anchor" href="#作用域作为生命周期的不足">#</a>作用域作为生命周期的不足</h3><p>上小节的例子说明了为什么 rust 需要引入 Lifetime 的概念，以及为什么在一些情况下需要人为指定 Lifetime。只是使用变量的作用域作为生命周期会有“误判”，即某些并没有违反规则 #3 的情形也会被 rust 认为是非法的。例如：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="built_in">String</span>::from(<span class="string">"book1"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> b = <span class="built_in">String</span>::from(<span class="string">"book2"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> c = &amp;<span class="keyword">mut</span> a;</span><br><span class="line">    c = &amp;<span class="keyword">mut</span> b;</span><br><span class="line">    a.push(<span class="string">'C'</span>);  <span class="comment">// ① rust 报错：已存在对 a 的可变引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，rust 认为①处存在对变量 <code>a</code> 的引用，原因是变量 <code>c</code> 是对 <code>a</code> 的引用，并且在①处 <code>c</code> 的作用域还未结束，因此认为依旧存在对 <code>a</code> 的引用。但实际上 <code>c</code> 对 <code>a</code>的引用已经结束。这也是直接用作用域作为生命周期的不足，在 rust 中可以通过如下方案绕过：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="built_in">String</span>::from(<span class="string">"book1"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> b = <span class="built_in">String</span>::from(<span class="string">"book2"</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> c = &amp;<span class="keyword">mut</span> a;</span><br><span class="line">        c = &amp;<span class="keyword">mut</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    a.push(<span class="string">'C'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何指定-lifetime"><a class="header-anchor" href="#如何指定-lifetime">#</a>如何指定 Lifetime</h2><p>虽然理论上，我们可以指定各种复杂的 Lifetime 规则，但由于我们指定的规则是作用在编译期的静态分析，所以我们指定的规则有一定的要求，具体如下：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>&lt;<span class="symbol">'X</span>, <span class="symbol">'Y</span>, <span class="symbol">'Z</span>&gt;(x: &amp;<span class="symbol">'X</span> <span class="built_in">str</span>, x: &amp;<span class="symbol">'Y</span> <span class="built_in">str</span>, x: &amp;<span class="symbol">'Z</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'R</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Lifetime 推导公式</em> ： 当输出值 <code>R</code> 依赖输入值 <code>X</code> <code>Y</code> <code>Z</code> …，当且仅当输出值的 Lifetime 为所有输入值的 Lifetime 交集的子集时，生命周期合法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lifetime(R) ⊆ ( Lifetime(X) ∩ Lifetime(Y) ∩ Lifetime(Z) ∩ Lifetime(...) )</span><br></pre></td></tr></table></figure><p>因此，下例中指定的 Lifetime 是非法的。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>&lt;<span class="symbol">'a</span>, <span class="symbol">'b</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'b</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">true</span> &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lifetime(返回值) ⊆ ( Lifetime(x) ∩ Lifetime(y) )</span><br><span class="line"></span><br><span class="line">即：</span><br><span class="line"></span><br><span class="line">&apos;a ⊆ (&apos;a ∩ &apos;b)  // &apos;b 可能小于 &apos;a ，因此不总是成立</span><br></pre></td></tr></table></figure><p>上面的规则本质上就是要求函数返回值的 Lifetime 要小于任意一个参数的 Lifetime。为什么需要这样的规则呢？我们重用上节用到的一个例子，如下：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>&lt;<span class="symbol">'a</span>, <span class="symbol">'b</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'b</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> random() % <span class="number">2</span> == <span class="number">0</span> &#123; x &#125; <span class="keyword">else</span> &#123; y &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">String</span>::from(<span class="string">"X"</span>);</span><br><span class="line">    <span class="keyword">let</span> z;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> y = <span class="built_in">String</span>::from(<span class="string">"Y"</span>);</span><br><span class="line">        z = foo(&amp;x, &amp;y);  <span class="comment">// ①</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"z = &#123;&#125;"</span>, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 rust 做的是静态分析，因此在 ① 处分析时，<code>z</code> 的 Lifetime 为函数 <code>foo</code> 返回值的 Lifetime <code>'a</code>，它小于变量 <code>x</code> 的生命周期，因此如果 rust 不强制执行Lifetime 的推导规则，则上述代码能通过静态分析，但若运行时函数 <code>foo</code> 返回了<code>y</code>，则又产生了内存安全的问题。上例可以用这种方式解决：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>&lt;<span class="symbol">'a</span>, <span class="symbol">'b</span>: <span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'b</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span></span><br></pre></td></tr></table></figure><p><code>'b: 'a</code> 表示 Lifetime <code>'b</code> 比 <code>'a</code> 活得长 (outlive)。因此可以通过 Lifetime规则。</p><p>如上，即使 rust 需要我们人工指定一些生命周期，它对指定的内容也是有要求的，要求就是函数返回值的生命周期要小于任意一个参数的生命周期，这样静态分析的结果才能保证运行时的正确性。</p><h2 id="小结"><a class="header-anchor" href="#小结">#</a>小结</h2><p>内存安全、数据竞争等问题的根源是“共享可变数据”，C/C++ 语言将这些问题完全交结程序员，由程序员保证不出错；Java 采用 GC 解决内存回收问题，但依旧面临着数据竞争等问题，需要程序员处理；一些函数式语言，诸如 Haskell, Clojure 针对“共享可变数据”中的“可变”，强制要求数据是“不可变”的，以解决上述问题；而 rust 另辟蹊径处理了“共享”的问题，来达到同样的效果。</p><p>当然，在编程语言降低我们出错风险的同时，也剥夺了我们的“自由”与“权力”。有些语言让我们付出的代价是性能，而 rust 需要的则是程序员付出更多的学习时间。</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料">#</a>参考资料</h2><ul><li><a href="https://www.youtube.com/watch?v=O5vzLKg7y-k" target="_blank" rel="noopener">Stanford Seminar - The Rust ProgrammingLanguage</a> Aaron Turon 的演讲，对理解 rust 的共享模型很有帮助。</li><li><a href="https://wayslog.gitbooks.io/rustprimer/content/ownership-system/lifetime.html" target="_blank" rel="noopener">rustprimerlifetime</a>通俗易懂的 Lifetime 讲解，文中多个例子来源于此。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ownership, Borrowing 与 Lifetime 共同成就了 rust 中的内存安全，也是 rust 语言中最精髓的创造，我们就来学习学习它们究竟是什么，为什么要引入这些概念。&lt;/p&gt;
&lt;h2 id=&quot;权力与风险共生&quot;&gt;&lt;a class=&quot;header-anc
      
    
    </summary>
    
      <category term="Knowledge" scheme="http://lotabout.github.io/categories/Knowledge/"/>
    
    
      <category term="rust" scheme="http://lotabout.github.io/tags/rust/"/>
    
      <category term="lifetime" scheme="http://lotabout.github.io/tags/lifetime/"/>
    
      <category term="ownership" scheme="http://lotabout.github.io/tags/ownership/"/>
    
      <category term="borrowing" scheme="http://lotabout.github.io/tags/borrowing/"/>
    
  </entry>
  
  <entry>
    <title>《慢思考》大脑超载时代的思考学</title>
    <link href="http://lotabout.github.io/2016/brain-chains/"/>
    <id>http://lotabout.github.io/2016/brain-chains/</id>
    <published>2016-12-21T22:12:16.000Z</published>
    <updated>2018-01-30T13:53:38.951Z</updated>
    
    <content type="html"><![CDATA[<p>会有这样的感觉吗？忙碌了一整天，却不知道忙了些什么。《慢思考》这本书正是以科学的角度告诉了我们原因：我们无法一心二用，却分明又想一心多用！</p><p>关于时间管理的知识，最早接触的是《把时间当朋友》，之后学习了 GTD，后来又知道了“番茄工作法”，试着实践几次，总是半途而废。引用大家常说的一句话就是“即使知道这么多的道理，依旧过不好这一生”。方法好是好，奈何用不了啊。</p><p>那么这本《慢思考》又能带来什么不一样的启发呢？</p><h2 id="大脑是有分工的"><a class="header-anchor" href="#大脑是有分工的">#</a>大脑是有分工的</h2><p>特奥康普诺利教授告诉我们，人的大脑有三套负责认知、决策的系统：反射脑，思考脑，存储脑。反射脑快但原始；思考脑慢但成熟，且能耗巨大，容易疲劳；存储脑需要空闲才能良好工作。</p><p>我们的目标是最大化我们的效率，因此希望充分利用我们的思考脑和存储脑，而希望克服反射脑带来的一些问题。</p><p>反射脑的问题在于它是自发的，无意识的。例如突然看见一只狮子，你不需要任何思考就知道拔腿就跑，这种反应是十分迅速的，也因此让人类的祖先能从恶劣的环境下生存下来。但在21世纪，我们的绝大部分直接直觉反应是不利的，这点书中给出了许多例子。</p><p>在21世纪，我们更需要的是成熟的思考。但可惜的是，我们的思考脑能力有限，它最大的限制就是“一次只能专注于一项任务”。这也说明了为什么边玩游戏边和女友打电话是不可能的。思考脑在不同的任务间进行切换时需要花费巨大的。</p><p>TED 演讲： <a href="https://www.ted.com/talks/apollo_robbins_the_art_of_misdirection" target="_blank" rel="noopener">错误引导的艺术</a>（搜索“世界上最伟大扒手的演讲”）说的就是这个特性。主讲人通过分散嘉宾的注意力，成功“偷”到了嘉宾身上的各种东西，诸如手表、钱包。问题就在于，人们无法迅速地在各项任务间进行切换。</p><p>最后是存储脑，它的作用是将我们接收到的信息进行分类和存储，以备后用。现代的研究发现，思考脑与存储脑之间存在平稳，其中一个激活时另一个就进入休息状态，反之亦然。所以等到思考脑进入休息之时，存储脑就抓紧时间，进行存储。</p><h2 id="不要逆天行事"><a class="header-anchor" href="#不要逆天行事">#</a>不要逆天行事</h2><p>学习科学的重要之处在于：理解并尊重事物的发展规律。</p><p>不知道你学过游泳没有，我认为它特别能区分一个人是否有“科学”的理念。学习得快的人往往能较快的调整自我的认知，学习并尊重人在水中的客观规律，而不是只是幻想着游泳动作。</p><p>在提高效率这个战场上，我们也需要认识到 4 种“普通”的场景其实特别危险。它们是随时在线、多任务并行、负面压力和睡眠不足。</p><p>什么是“随时在线”？你会不会时不时地去查看手机或是邮件，哪怕根本没有新的消息？“随时在线”的问题在于，它们中断我们的思考脑，强行让我们进入多任务并行的状态。另外，随时在线常常会占用存储脑的工作时间，存储脑等待着空闲，但现在这些时间却被我们用来刷手机了。所以“随时在线”会影响你的记忆力，降低你的创造力。</p><p>多任务并行是思考脑的大忌。一方面，在任务之间进行切换是有开销的，这会降低你的效率。另一方面，在你试图一心二用的时候，其实两个任务都没有做好。你可以尝试一边打电话一边玩游戏，你会发现不可能同时进行，要么不记得对方说什么，要么忽略了游戏里的小地图。</p><p>有时候我们会说，“边打电话边洗碗”不就成功的例子嘛。是的，这是因为“洗碗”是由反射脑控制的。这里的反对的并行任务指的是思考脑的工作。那什么任务归思考脑，什么任务归反射脑呢？一般来说，一项任务经过不断训练，是可以逐渐地交给反射脑的。</p><p>关于压力，有一种说法是“要尝试跳起来够得着的事”。这一方面意味着压力有益于我们提高，另一方面意味着过大的压力会有反效果。在压力的持续时间上也有类似的作用：人能够忍受短期压力，但难以忍受长期压力。书里说了很多长期负面压力的坏处，这里不再赘述。</p><p>最后关于睡眠不足，主要损害的是存储脑的利益，当然它影响的不只是记忆力，你的专注力、创造力和判断力也会受到影响。</p><p>上面的这四个要素并不是单一的，它们会相互影响。例如随时在线很自然地会让我们进行多任务状态，同时也会给我们带来负面压力，而信息过载和负面压力也会让我们睡眠不足。</p><p>书里说的很多，我认为总结起来就是：不要逆天行事。要顺应身体的需求。</p><h2 id="保持专注"><a class="header-anchor" href="#保持专注">#</a>保持专注</h2><p>保持专注既是目的也是方法。</p><p>《慢思考》的英文原名其实是“大脑的锁链”，旨在教会我们如何避免“逆天行事”。包括“离线思考”来保持专注；“批量处理”来防止过多的任务切换；恢复正常的睡眠模式来保证充足的睡眠；科学地应对负面压力；以及如何将上面的这些方法培养成自己的习惯。</p><p>回到开头所说，难道书里的方法就能比其它的方法好吗？并不见得。对于我而言，更为重要的是更清晰地明白了这些方法背后的原理和逻辑。例如，我们知道番茄工作法是以25 分钟为一个单位，那它和一般的计时有什么区别？看了这本书后恍然大悟，重要的并不是一个番茄有多长的时间，而是在这段时间内只能专注做一件事。如果在这段时间内做做工作，刷刷手机，查查邮件，那恐怕番茄工作法也毫无帮助吧。</p><p>最后，我给自己的答案是：远离无用的信息，保持专注，劳逸结合。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;会有这样的感觉吗？忙碌了一整天，却不知道忙了些什么。《慢思考》这本书正是以科学的角度告诉了我们原因：我们无法一心二用，却分明又想一心多用！&lt;/p&gt;
&lt;p&gt;关于时间管理的知识，最早接触的是《把时间当朋友》，之后学习了 GTD，后来又知道了“番茄工作法”，试着实践几次，总是半途
      
    
    </summary>
    
      <category term="Reading" scheme="http://lotabout.github.io/categories/Reading/"/>
    
    
      <category term="Book" scheme="http://lotabout.github.io/tags/Book/"/>
    
      <category term="brainchain" scheme="http://lotabout.github.io/tags/brainchain/"/>
    
  </entry>
  
  <entry>
    <title>再谈闭包</title>
    <link href="http://lotabout.github.io/2016/thoughts-of-closure/"/>
    <id>http://lotabout.github.io/2016/thoughts-of-closure/</id>
    <published>2016-08-27T14:20:38.000Z</published>
    <updated>2018-01-30T13:53:38.971Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 Algol/Fortran 世界生活的人们总是不相信在未来的编程中，函数闭包对编程的效率能有多大的帮助。之后就发生了“面向对象编程”的革命，现在几乎人人都用函数闭包进行编程，只是他们依旧不把它叫作“函数闭包”。</p></blockquote><p><a href="http://lotabout.me/2015/Closure-%E5%86%85%E6%B6%B5%E7%90%86%E8%A7%A3/" target="_blank" rel="noopener">之前的文章</a>里，我们试图说服大家：闭包与面向对象在本质上是一样的。这篇文章中，我们要仔细看看什么是闭包；闭包与 <code>lambda</code> 的区别；将函数作为数据的优缺点；以及其它一些你可能想了解的概念。</p><a id="more"></a><h2 id="什么是闭包"><a class="header-anchor" href="#什么是闭包">#</a>什么是闭包</h2><p>闭包 (Closure) 有两种函义，一个是数学意义上的，一种是编程意义上的。这里我们先讨论编程这个语境下的函义。<a href="https://en.wikipedia.org/wiki/Closure_%28computer_programming%29" target="_blank" rel="noopener">维基百科</a>中如是说到：</p><blockquote><p>In programming languages, closures (also lexical closures or function closures) aretechniques for implementing <em>lexically scoped name binding</em> in languages with<em>first-class functions</em>. Operationally, a closure is a record storing afunction together with an environment.</p></blockquote><p>中文维基则是这么说的：</p><blockquote><p>在计算机科学中，闭包，又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。</p></blockquote><p>看了这两种定义，这里出现了两个概念：什么是 <strong>自由变量</strong> ，为什么称为 <strong>词法</strong>闭包？</p><h2 id="自由变量与闭包"><a class="header-anchor" href="#自由变量与闭包">#</a>自由变量与闭包</h2><p>既然叫自由变量 (free variable)，那还有不自由的变量？还真有，它们称为 ”约束变量“ (bound variable)。这么理解，一个函数中出现的变量中，函数的参数及函数中定义的局部变量称为“约束变量”，而其它的则是自由 变量。用 C 语言举例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tripple = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> global = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tripple = <span class="number">0</span>;       <span class="comment">// tripple is bound because it is local</span></span><br><span class="line">    tripple = global * <span class="number">3</span>;  <span class="comment">// global is free</span></span><br><span class="line">    <span class="keyword">return</span> x + tripple;    <span class="comment">// x is bound</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数 <code>function</code> 中，<code>x</code> 是参数，<code>tripple</code> 是局部变量，因此称为约束变量；而<code>global</code> 不在此类， 所以称为自由变量。称为约束是因为它们的值是函数 <code>function</code>可以掌管和控制的，而 <code>global</code> 是自由的 是因为它的值并不由函数 <code>function</code> 控制。</p><p>那么自由变量就是全局变量？</p><p>在 C 语言中是这样的，因为 C 不允许我们在函数中定义函数，没有了函数嵌套，函数内的自由变量当然只能 指向全局了。但在其它支持嵌套定义函数的语言中就不是这样了，如下面的 Python 代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shadowed_var = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(x)</span>:</span></span><br><span class="line">    shadowed_var = <span class="number">20</span>              <span class="comment">#  &lt;--+</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(y)</span>:</span>                  <span class="comment">#     |</span></span><br><span class="line">        tripple = <span class="number">0</span>                <span class="comment">#     |</span></span><br><span class="line">        tripple = shadowed_var * <span class="number">3</span> <span class="comment">#-----+</span></span><br><span class="line">        <span class="keyword">return</span> x + y + tripple</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">fun = outer(<span class="number">10</span>)</span><br><span class="line">fun(<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>函数 <code>inner</code> 中的变量 <code>shadowed_var</code> 就是一个自由变量，但在运行时，它指向的是<code>outer</code> 函数中的 <code>shadowed_var</code>， 而不是全局的。这里，我们也不经意间涉及了“环境 (environment)”的概念。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+==================================</span><br><span class="line">| Global envirnment</span><br><span class="line">+==================================</span><br><span class="line">| shadowed_var: 10</span><br><span class="line">|</span><br><span class="line">| &gt; fun = outer(10)</span><br><span class="line">| +============================</span><br><span class="line">| | Outer environment</span><br><span class="line">| +============================</span><br><span class="line">| | x: 10</span><br><span class="line">| | shadowed_var: 20             &lt;-----\</span><br><span class="line">| |                                    |</span><br><span class="line">| | +===========================       | shadowed_var refers</span><br><span class="line">| | | Inner                            | to the outer environment</span><br><span class="line">| | +===========================       |</span><br><span class="line">| | | y: argument                      |</span><br><span class="line">| | | tripple = shadowed_var * 3  -----/ </span><br><span class="line">| | | return x + y + tripple</span><br><span class="line">|</span><br><span class="line">| fun(20)</span><br></pre></td></tr></table></figure><p>当一个函数运行时，系统（也可能是语言的解释器）就会为它创建一个运行时的环境，函数会把自己能“约束”的变量放到其中。例如上图中全局环境与 <code>outer</code> 函数的环境各有一个 <code>shadowed_var</code> 变量。</p><p>而闭包的概念要求我们，如果一个函数创建时，其中的自由变量指向某个环境（<code>inner</code>函数中的 <code>shadowed-var</code> 指向 <code>outter</code> 环境，那么即使该函数已经离开了这个环境（即调用 <code>fun(20)</code> 时已经离开了 <code>outer</code> 环境），那么该函数中 的自由变量依旧要指向创建时指向的环境（即调用 <code>fun(20)</code> 时，函数 <code>inner</code> 中的 <code>shadowed_var</code> 依旧指向 <code>outter</code> 环境而不是全局的环境）。</p><p>所以，自由变量与环境的结合就是闭包技术的关键，有时也把函数本身和指向的环境共同称为闭包。</p><h2 id="作用域：静态-vs-动态"><a class="header-anchor" href="#作用域：静态-vs-动态">#</a>作用域：静态 vs 动态</h2><p>作用域是指一个变量的名与值的绑定的有效范围。例如上节中的例子中，<code>shadowed_var</code>是个名字，它的值可以是 <code>10</code>（全局 环境中），也可以是 <code>20</code>（在 <code>outter</code> 环境中），这个对应关系起作用的范围就是作用域。</p><p>静态作用域也称作“词法作用域 (lexical scope)“。想想闭包也被称为“词法闭包”，它们之间有什么关系呢？其实在上节介绍自由 变量时介绍的数据绑定方法就是静态作用域。</p><p>在静态作用域下，变量绑定是由源代码的位置结构（词法结构）决定的，即在查找变量时，依据的是函数定义/生成时所在的环境。如上节的 Python 代码中，函数 <code>fun</code> 在生成时处在<code>outer</code> 环境，因此函数 <code>fun</code> 在运行时，仍旧需要在 <code>outer</code> 环境中去查找变量 <code>x</code> 和变量 <code>shadowed_var</code> 的值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      Lexical Scope                                    Dynamical Scope</span><br><span class="line">+==================================            +==================================</span><br><span class="line">| Global envirnment                            | Global envirnment</span><br><span class="line">+==================================            +==================================</span><br><span class="line">| shadowed_var: 10                             | shadowed_var: 10           &lt;-----\</span><br><span class="line">|                                              |                                  |</span><br><span class="line">| &gt; fun = outer(10)                            | &gt; fun = outer(10)                |</span><br><span class="line">| +============================                | +============================    |</span><br><span class="line">| | Outer environment                          | | Outer environment              |</span><br><span class="line">| +============================                | +============================    |</span><br><span class="line">| | x: 10                     &lt;---------\      | | x: 10                          |</span><br><span class="line">| | shadowed_var: 20             &lt;---\  |      | | shadowed_var: 20               |     </span><br><span class="line">|                                    |  |      |                                  |     </span><br><span class="line">| &gt; fun(20)                          |  |      | &gt; fun(20)                        |     </span><br><span class="line">| +===========================       |  |      | +===========================     |     </span><br><span class="line">| | Inner                            |  |      | | Inner                          |     </span><br><span class="line">| +===========================       |  |      | +===========================     |     </span><br><span class="line">| | y: 20                            |  |      | | y: 20                          |     </span><br><span class="line">| | tripple = shadowed_var * 3   ----/  |      | | tripple = shadowed_var * 3   --/     </span><br><span class="line">| | return x + y + tripple      --------/      | | return x + y + tripple    # x is undefined</span><br></pre></td></tr></table></figure><p>相比之下，动态作用域则不论源代码的结构，所有的自由变量的值均在运行时的环境中查找。如上右图，运行 <code>fun(20)</code> 时，<code>shadowed_var</code> 取值为 <code>10</code>，而变量 <code>x</code> 则由于未定义而出错，因为全局的环境中并未定义 <code>x</code> 变量。</p><p>可以看到，动态作用域下无法实现闭包，因为它与闭包的定义相违背。闭包要求自由变量与环境绑定，而动态作用域则不允许这种绑定。所以闭包也称为“词法闭包”。</p><h3 id="动态作用域有什么用？"><a class="header-anchor" href="#动态作用域有什么用？">#</a>动态作用域有什么用？</h3><p>在现代的主流语方中，你几乎看不到动态作用域的身影（Emacs Lisp 用的是动态作用域），我们不禁怀疑，这是不是一项被淘汰了的技术？</p><p>一项技术的出现一定是为了解决某个/些问题，而如果被淘汰了，则说明这个问题被其它的方案解决了。那么动态作用域能解决什么问题呢？</p><p>现在我们要写一个函数，判断两个浮点数是否相等，因为计算机对浮点数的表示是不精确的，因此，我们在判断时要指定好精度。用 Scheme 实现如下：</p><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> TOLERANCE <span class="number">0.001</span>)</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">float-equal?</span> a b) (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> a b)) TOLERANCE))</span><br><span class="line">(<span class="name">float-equal?</span> <span class="number">0.5011</span> <span class="number">0.5012</span>)     <span class="comment">;=&gt; #t</span></span><br></pre></td></tr></table></figure><p>完美解决了问题，但现在我们需要判断两个极为重要的数据是否相等，我们需要更高的精度。那么现在只需要改变 <code>TOLERANCE</code> 的值即可。由于 <code>float-equal?</code> 中<code>TOLERANCE</code> 是与全局环境绑定的，因此这个修改可以改变 <code>float-equal?</code> 的行为：</p><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> TOLERANCE <span class="number">1</span>e-6)</span><br><span class="line">(<span class="name">float-equal?</span> <span class="number">0.50001</span> <span class="number">0.50002</span>)   <span class="comment">;=&gt; #f</span></span><br></pre></td></tr></table></figure><p>Nice! 又一次体现了我们惊人的智慧！只是，这时，原先的代码的行为也发生了变化：</p><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name">float-equal?</span> <span class="number">0.5011</span> <span class="number">0.5012</span>)     <span class="comment">;=&gt; #f</span></span><br></pre></td></tr></table></figure><p>当然，我们使用完高精度后再把 TOLERANCE 改回原来的值，但本着代码强迫症的原则，老板不允许如此难看的写法。于是我们灵机一动，想到可以把 TOLERANCE 作为参数传给<code>float-equal?</code>，再生成一些临时的函数：</p><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">float-equal?</span> a b TOLERANCE) (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> a b)) TOLERANCE))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">float-equal-normal?</span> a b) (<span class="name">float-equal?</span> a b <span class="number">0.001</span>))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">float-equal-high?</span> a b) (<span class="name">float-equal?</span> a b <span class="number">1</span>e-6))</span><br></pre></td></tr></table></figure><p>这下分别用高精度和低精度的函数就可以了！只是这样做依旧会有一些问题：</p><ol><li>如果这个函数是库函数，而我们并不能修改它，则这招失败。</li><li>如果变量 <code>TOLERANCE</code> 的调用关系特别深，则传递参数极其复杂、麻烦。</li></ol><p>而这个问题在支持动态作用域的语言中根本不成问题：</p><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name">float-equal?</span> <span class="number">0.5011</span> <span class="number">0.5012</span>)     <span class="comment">;=&gt; #t</span></span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">let</span></span> ((<span class="name">TOLERANCE</span> <span class="number">1</span>e-6))</span><br><span class="line">  (<span class="name">float-equal?</span> <span class="number">0.50001</span> <span class="number">0.50002</span>))   <span class="comment">;=&gt; #f</span></span><br><span class="line"></span><br><span class="line">(<span class="name">float-equal?</span> <span class="number">0.5011</span> <span class="number">0.5012</span>)     <span class="comment">;=&gt; #t</span></span><br></pre></td></tr></table></figure><p>那这个问题被解决了吗？遗憾的是依旧没有，这意味着如果一个很低层的函数想提供一些可以配置的选项给高层的函数，中间层的包裹函数也必须提供相应的接口。例如现在我们想基于 <code>float-equal?</code> 提供一个比较函数，得到两个浮点数的大小关系，如下：</p><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cmp</span> a b)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name">float-equal?</span> a b)</span><br><span class="line">         <span class="symbol">'EQ</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">&lt;</span></span> a b)</span><br><span class="line">         <span class="symbol">'LE</span>)</span><br><span class="line">        ((<span class="name"><span class="builtin-name">&gt;</span></span> a b)</span><br><span class="line">         <span class="symbol">'GE</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">cmp</span> a b tolerance-of-equal)</span><br><span class="line">  (<span class="name"><span class="builtin-name">cond</span></span> ((<span class="name">float-equal?</span> a b tolerance-of-equal)</span><br><span class="line">         <span class="symbol">'EQ</span>)</span><br><span class="line">        ((<span class="name">less?</span> a b)</span><br><span class="line">         <span class="symbol">'LE</span>)</span><br><span class="line">        ((<span class="name">greater?</span> a b)</span><br><span class="line">         <span class="symbol">'GE</span>)))</span><br></pre></td></tr></table></figure><p>为了能控制精度，我们必须改写 <code>cmp</code> 为它添加一个参数，用以控制 <code>float-equal?</code>的精度。可想而知，这是很不好的写法，而且，如果 <code>less?</code> 也支持这样的配置，那么<code>cmp</code> 就需要增加多个参数用于子函数的配置。这个问题依旧存在于几乎所有静态作用域的语言中。顺代一提，racket 语言中的 <a href="https://docs.racket-lang.org/reference/parameters.html" target="_blank" rel="noopener">parameters</a>就是解决这个问题的一种方法。racket 是 scheme 的一种方言。</p><p>因此动态作用域并没有被淘汰，但却是鱼和熊掌不可兼得。</p><h2 id="闭包不是-lambda"><a class="header-anchor" href="#闭包不是-lambda">#</a>闭包不是 lambda</h2><p>lambda 函数，一般也称为匿名函数，它允许我们定义一个函数，同时不为它命名。相信用过 Javascipt 的同学们已经很熟悉了，因为它经常出现在回调函数里。</p><p>由于现今的主流语言中，lambda 与闭包经常同时出现，使得许多人将二者等同对待，但实际情况并非如此，它们本是两个独立的概念，但现在密不可分又是情有可原。</p><ol><li>创建闭包并不需要 lambda 函数。</li><li>创建了 lambda 函数并不一定生成闭包。</li></ol><p>我们知道，闭包的生成通常需要我们能够嵌套定义函数，并且要求语言采用静态作用域。那么在下面的 Python 代码里，我们没有用到 lambda ，却生成了闭包。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_adder</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adder</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> n + x</span><br><span class="line">    <span class="keyword">return</span> adder</span><br><span class="line"></span><br><span class="line">add_10 = gen_adder(<span class="number">10</span>)</span><br><span class="line">add_10(<span class="number">20</span>) <span class="comment"># =&gt; 30</span></span><br></pre></td></tr></table></figure><p>调用 <code>gen_adder</code> 时生成了一个环境，而返回的 <code>adder</code> 函数中的自由变量 <code>n</code> 则与这个环境绑定，构成了一个闭包。整个过程不没有用到匿名函数。</p><p>而创建 lambda 函数时也不一定生成闭包，例如如前一节所说，如果一门语言采用了动态作用域，那么它根本不可能产生闭包。例如下面的 Emacs Lisp 代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(defun gen-adder (n)</span><br><span class="line">  (lambda (x) (+ n x)))</span><br><span class="line"></span><br><span class="line">(defvar adder (gen-adder 10))</span><br><span class="line"></span><br><span class="line">(let ((n 5))                   ; otherwise `n` is undefined</span><br><span class="line">  (funcall adder 20))          ; =&gt; 25</span><br></pre></td></tr></table></figure><p>由于 Emacs Lisp 是动态作用域语言，在调用 <code>adder</code> 时，自由变量 <code>n</code> 指向的是运行时环境中的 <code>n = 5</code> 而不是定义时环境 <code>n = 10</code>。由此可见它并没有生成闭包。</p><p>那么 lambda 有何好处呢？我个人认为最大的好处就是方便书写，方便修改。例如回调函数使用了 lambda 函数，就相当于直接将回调的逻辑写在了需要使用它的地方，这样当逻辑需要修改时，就不需要首先找到函数定义的位置再去修改，更加方便。还有就是不要想方设法命名了啊！</p><h2 id="函数-数据-对象"><a class="header-anchor" href="#函数-数据-对象">#</a>函数、数据、对象</h2><p>现代的许多语言者喜欢鼓吹“函数是头等公民 (first-class function)”，以及配套的“将函数作用数据 (function as data)”。最近在看 SICP 等二章的时候就在思考这样做的优势在哪？</p><p>将 SICP 第二章的图像语言做一个简化。考虑我们要写一个画图的程序，首先我们定义一个画家，画家的能力是画图，而图是由一些线段构成的，这些线段是事先给定的。一个画家只会画这个事先定义好的图，但他可以把图画在不同的画板上，自行地进行缩放：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------+             +------------------+</span><br><span class="line">|    /\     |             |        /\        |</span><br><span class="line">|   /  \    |             |      /    \      |</span><br><span class="line">|  /----\   |             |    /--------\    |</span><br><span class="line">| /      \  |             |  /            \  |</span><br><span class="line">|/        \ |             |/                \|</span><br><span class="line">+-----------+             +------------------+</span><br></pre></td></tr></table></figure><p>根据上面的需求，SICP 中使用与下文类似的代码：</p><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-frame</span> ...) ...)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">make-painter</span> line-segments)</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (frame)                     <span class="comment">; define a painter as lambda</span></span><br><span class="line">    ... ))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> painter-A (<span class="name">make-painter</span> ...))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> small-frame (<span class="name">make-frame</span> ...))</span><br><span class="line"></span><br><span class="line"><span class="comment">; Draw</span></span><br><span class="line">(<span class="name">painter-A</span> small-frame)</span><br></pre></td></tr></table></figure><p>上述代码中，画家 A (painter-A) 由调用 <code>(make-painter ...)</code> 生成，而<code>make-painter</code> 是返回的是一个函数，之后我们再生成一个画板 <code>small-frame</code> 就可以直接通过调用画家函数来进行绘画：<code>(painter-A small-frame)</code>。</p><p>如果你习惯了 Scheme(Lisp) 的思维习惯，会觉得这种用函数来表示数据的方法特别地自然，当然也特别地神奇。而这么做的好处，<a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/3a-henderson-escher-example" target="_blank" rel="noopener">SICP 视频</a>里是这么说的：</p><blockquote><p>the crucial thing that’s going on here is you’re using the representation ofpictures as procedures to automatically get the closure property.</p></blockquote><p>Closure Property 指的是一个函数的返回值还可以做为这个函数的参数进行处理，我们会在下小节中进行介绍。在当前语境下，可以这么理解，如果我们实现一个新的函数，它以一个 painter 作为参数，返回一个新的 painter，那么我们还可以继续用这个函数去处理返回的 painter。例如我们定义一个新的函数，可以将画家的画并排地放在一起。</p><figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">beside</span> painter1 painter2)</span><br><span class="line">  ...)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> painter3 (<span class="name">beside</span> painter1 painter2))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> painter4 (<span class="name">beside</span> painter3 painter2))</span><br></pre></td></tr></table></figure><p>可以看到 painter3 是函数 <code>beside</code> 的返回值，却可以继续作为它的参数处理。然而，对于现代的程序员而言，用面向对象的思想完全可以实现这些性质：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Painter</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, line_segments)</span>:</span></span><br><span class="line">        self.line_segments = line_segments</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">paint</span><span class="params">(self, frame)</span>:</span></span><br><span class="line">        <span class="comment"># ... some painter logic</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">beside</span><span class="params">(painter1, painter2)</span>:</span></span><br><span class="line">    ... painter1.paint(...) ...</span><br><span class="line">    ... painter2.paint(...) ...</span><br><span class="line"></span><br><span class="line">painter3 = beside(painter1, painter2)</span><br><span class="line">painter4 = beside(ainter3, painter2)</span><br></pre></td></tr></table></figure><p>所以视频里说的这个特性并不能说服我，经过一番思考，得出的结论是：用函数来表示数据的优点，是可以无缝地表示一个动作。</p><p>例如画家最主要的特性是“画”这个动作，而园丁的主要动作是“浇水”，等等。当我们使用函数来表示这些对象时，我们不在乎它们具体是什么动作，只需要知道可以直接把它们当作函数来调用，这里它们就会执行它们的默认动作。</p><p>然而……现代的面向对象语言仍旧可以做到这点……：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Painter</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, line_segments)</span>:</span></span><br><span class="line">        self.line_segments = line_segments</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">paint</span><span class="params">(self, frame)</span>:</span></span><br><span class="line">        <span class="comment"># ... some painter logic</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, frame)</span>:</span>   <span class="comment"># default action </span></span><br><span class="line">        self.paint(frame)</span><br><span class="line"></span><br><span class="line">painter = Painter()</span><br><span class="line">painter(frame)          <span class="comment"># use it as a function</span></span><br></pre></td></tr></table></figure><p>在 Python 中为一个类实现 <code>__call__</code> 函数，就可以将生成的对象作为函数进行调用。这样就可以将它作为这个类的默认“动作”。</p><p>因此也可以看到，即使形式差异很大，这些语言解决问题的本质思想依旧是极其的相似，甚至可以说是相同的。</p><h2 id="closure-property"><a class="header-anchor" href="#closure-property">#</a>Closure Property</h2><p>最后说一说 Closure Property，它其实是一个数学上的概念，我们举一个例子：考虑自然数的集合，任意两个自然数相加，结果依旧属于自然数的集合，我们就称自然数集对加法操作是闭合的，这就是 Closure property。而对于减法则不是如此，<code>1-2 = -1</code> 而<code>-1</code> 不是自然数，因此自然数对减法不闭合。</p><p>在程序设计里，闭包属性则为如下定义（SICP）：</p><blockquote><p>In general, an operation for combining data objects satisfies the closureproperty if the results of combining things with that operation canthemselves be combined using the same operation.</p></blockquote><p>用通俗的话说就是上节提到的，一个函数的返回值可以作为这个函数的参数。我们可以将闭包属性理解成一个递归属性，例如我们熟悉的树结构，如果一个操作以一棵树为参数，返回一棵新的树，那么如果这棵新的树能继续作为这个操作的参数，生成另一棵新的树，则这个操作对树结构是闭合的。</p><p>这种概念上的描述相当绕口，但概念本身还是相当有效且重要的。</p><p>如果一些操作对某些数据能够闭合，那么我们就能以各种各样的方式来组合这些操作，来构建极其复杂的结构。例如 Lisp 中的 <code>cons</code>，也可以称为 <code>pair</code>。基本的结构就是两个 <code>cell</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+----+</span><br><span class="line">|    |    |</span><br><span class="line">|    |    |</span><br><span class="line">+----+----+</span><br></pre></td></tr></table></figure><p>而由于 <code>cons</code> 返回的值依旧可以作为 cons 的参数，所以我们就能用这么简单的结构构建成极为复杂的结构，如列表，树，森林等。</p><p>因此在程序设计里，闭合的操作能够用极少的代价提供极为复杂的抽象。只是现实生活中的许多问题，没有办法分解成一个基本的结构，因此想要将操作设计成闭合的也是十分困难的，但可能的话收益是很高的。</p><h2 id="小结"><a class="header-anchor" href="#小结">#</a>小结</h2><p>文章中通过介绍自由变量与作用域试图让读者了解闭包的概念和原理；同时对一些容易与闭包混淆的概念作了区分；再对“函数即数据”的实际意义进行分析；最后介绍了一个与闭包名字很像的数学概念。</p><p>本文的目的是让读者对闭包能有一个更清晰的认识，同时注意到它与面向对象间的异同点，借此能在日常的编码中应用其中的一些思想。</p><p>最后说明一下，闭包的出现早于面向对象（根据维基的信息），所以也不必迷信优劣，理解它们要解决的问题和解决问题的方法才是最重要的。本人水平有限，如有错误，敬请指出，谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 Algol/Fortran 世界生活的人们总是不相信在未来的编程中，函数闭包对编程的效率
能有多大的帮助。之后就发生了“面向对象编程”的革命，现在几乎人人都用函数闭包进行编程，
只是他们依旧不把它叫作“函数闭包”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://lotabout.me/2015/Closure-%E5%86%85%E6%B6%B5%E7%90%86%E8%A7%A3/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;之前的文章&lt;/a&gt;里，
我们试图说服大家：闭包与面向对象在本质上是一样的。这篇文章中，我们要仔细看看什么是闭
包；闭包与 &lt;code&gt;lambda&lt;/code&gt; 的区别；将函数作为数据的优缺点；以及其它一些你可能想了解的概念。&lt;/p&gt;
    
    </summary>
    
      <category term="Knowledge" scheme="http://lotabout.github.io/categories/Knowledge/"/>
    
    
      <category term="closure" scheme="http://lotabout.github.io/tags/closure/"/>
    
  </entry>
  
</feed>

title: 二叉索引树
date: 2018-01-29 18:08:18
tags: [Data Structure]
categories: [Knowledge]
math: true
toc:
---

二叉索引树(Binary Indexed Tree) 也称为 [Fenwick
tree](https://en.wikipedia.org/wiki/Fenwick_tree)，中文也称树状数组。它可以在
O(log n) 的时间内得到数组的前缀和(A[1] + A[2] + ... + A[i])，且在 O(log n) 时
间内支持动态修改数组的值。

## 使用场景

首先我们考虑一个数组 A，想求 $A_i, A_{i+1}, ..., A_j$ 的和，如果只求一次，
很自然地把这些数相加即可，时间复杂度为 $O(n)$。但现在如果我们经常要求 A 中第
`i` 到第 `j` 个元素的和，则最好事先做个索引。

做法也简单，我们新建一个数组 C，数组 C 中的元素 $C_i = A_0 + A_1 + ... +
A_i$。于是如果我们要求 $A_i$ 到 $A_j$ 的和，则有 $Q(i, j) = A_i + ... + A_j =
C_j - C_{i-1}$。即通过访问数组 C，我们只需要 $O(1)$ 的时间即可。

但如果 A 中的元素 $A_i$ 的值有变化呢？这时，我们需要更新 $C_i$ 之后的所有
数据，需要 $O(n)$ 的时间。

于是索引 C 需要空间 $O(n)$，访问 $O(1)$，修改 $O(n)$。

## 二叉索引树

有时我们需要平衡索引的访问和修改时间，二叉索引数 (binary indexed tree) 可以
让我们用 $O(n \log(n))$ 的时间复杂度进行访问，同时用 $O(n \log(n))$ 即可完成修
改。虽然称为"树"，但其实我们是用数组实现的。

### Lowbit

首先，我们来看一个完全二叉树：

```
                                   lowbit

                o                ├ 1000 = 8
        ┌───────┴───────┐        │
        o               o        ├ 100  = 4
    ┌───┴───┐       ┌───┴───┐    │
    o       o       o       o    ├ 10   = 2
  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐  │
  o   o   o   o   o   o   o   o  ├ 1    = 1
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5  │
```

我们看到二叉树不同层数二叉结尾是有规律的。例如第一层：1, 3, 5, 7, ...，这些
数的二进制分别是 `1`, `11`, `101`, `111`, ...，最后一位都是 `1`。同理，第二层
的数都以 `10` 结尾。现在我们定义一个新的函数 `lowbit(n)`，它的作用是在 `n` 的
二进制上从右往左数，数到第一个 1 为止。例如数字 6 的二进制是 `110`，向右
数到第一个 1，得到 `10`，得到 `lowbit(6) = 2`，同理 `lowbit(12) = 4`。

那么 `lowbit` 有什么用呢？如果当前节点是父节点的右子树，则 `n - lowbit(n)`
正好是父节点。例如还是 `12`，`12 - lowbit(12) = 12 - 4 = 8` 正好是 `12`
的父节点 `8`。而如果当前节点是父节点的左子树，则 `n - lowbit(n)`
代表了它的第一个"左祖父节点"，例如节点 `10`，`10 - lowbit(10) = 10 - 2 =
8`，是 10 的左祖父节点。同理， `n + lowbit(n)` 是“右”祖父节点。

而同时可以看到 `n - lowbit(n) + 1` 在完全二叉数上对应的节点，就是从数字 n
对应的节点开始，不断取节点的左子节点直到第一层的那个节点。例如 `12`
所在的结点，不断向取左子节点，最终得到的是 `9`，而 `9 = 12 - 4 + 1 = 12 -
lowbit(12) + 1`。


有了 `lowbit`，我们就能在完全二叉树里快速地定位：

- `n - lowbit(bit)` 为左祖父/父节点
- `n + lowbit(bit)` 为右祖父/父节点
- `n - lowbit(bit) + 1` 为左子树的底层节点


从编程的角度上， `lowbit` 可以由位运算完成 (C++)：

```c
int lowbit(int x)
{
    return x&(-x);
}
```

### 建立索引

我们知道，索引的本质就是预先存储一些信息，现在我们来看如何从原数组 A 来构建我
们的二叉索引数 BIT 。我们定义：

$$
BIT_i = \sum_{j = i - lowbit(i) + 1}^{i} A_j
$$

看公式好像很复杂，我们拆解一下。看到下标 `i - lowbit(i) + 1`，我们知道代表了
`i` 所在节点左子树的底层节点。我们用图来说明如何计算 `BIT[12]` (图中标 `x`)

```
                o
        ┌───────┴───────┐
        o               x
    ┌───┴───┐       ┌───┴───┐
    o       o       x       o
  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐
  o   o   o   o   x   x   o   o
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
A                 2 1 3 1
BIT:                   (7)
```

可以看到 `BIT[12] = A[9] + A[10] + A[11] + A[12]`。同理，如果要计算 `BIT[18]`：

```
                x
        ┌───────┴───────┐
        x               o
    ┌───┴───┐       ┌───┴───┐
    x       x       o       o
  ┌─┴─┐   ┌─┴─┐   ┌─┴─┐   ┌─┴─┐
  x   x   x   x   o   o   o   o
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
```

具体如何构建二叉索引树我们下面再说。

### Sum

这里，我们定义的查找操作是 `sum(k) = A[1] + ... + A[k]`，有了 BIT 之后，就可以
这么求：

```c
int sum(int k)
{
    int ans = 0;
    for (int i = k; i > 0; i -= lowbit(i))
        ans += BIT[i];
    return ans;
}
```

还记得 `n - lowbit(n)` 代表什么吗？代表的是 n 节点的左祖父/父节点。因此为了求
`sum(k)` 我们只需要将 `k` 及 `k` 的所有左祖父/父节点相加即可。因此复杂度是
$O(\log n)$。

我们以 `6` 为例，`BIT[6]` 相当于 `A[5] + A[6]`，但我们要计算 `A[1] + ... +
A[6]`，因此还要计算 `A[1] + ... + A[4]`，而在 BIT 中，这正好对应于 `BIT[4]`。再
以 `10` 为例，`BIT[10] = A[9] + a[10]`，还差 `A[1] + ... + A[8]`，正好对应于
`BIT[8]`。


### 更新节点

如果 `A[k]` 的值发生变化了怎么办？从 BIT 的定义可知，`A[k]` 的值会影响 `k` 的
所有右祖父/父节点。这可以通过 `k + lowbit(k)` 来得到。因此：

```c
void edit(int i, int delta)
{
    for (int j = i; j <= MAX_N; j += lowbit(j))
        BIT[j] += delta;
}
```

可以看到，和 `sum` 类似，也是不断寻找祖父/父节点的过程，因此也是 $O(\log n)$。

### 初始化

可以有多种方式初始化，每种的复杂度不同。

先假设初始数组 A 全为 0，之后调用 `edit` 来更新数组中的每个元素，复杂度为 $O(n
\log n)$。考虑完全二叉树，则需要的操作数为 $(n+1)lg(n+1)/2$ (n 为节点数)。

```c
void build()
{
    for (int i=1;i<=MAX_N;i++)
    {
        edit(i, A[i])
    }
}
```

当然这个操作是可以达到 $O(n)$ 的。方法是像开头说的，先创建一个累加数组，于是只
需要用 $O(1)$ 时间即可求得 `A[j] - A[i]`。但这么做意义不是特别大。因为采用 BIT
本身是为了处理更新操作，所以一般可以认为会有 $O(n)$ 个操作，于是整体的算法复杂
度不太可能小于 $O(n \log n)$，那么强行用 $O(n)$ 来初始化 BIT 也没有太大的意
义。

## 参考文章

- https://zh.wikipedia.org/wiki/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84
- http://www.cnblogs.com/pengzhen/p/4373491.html
- http://novoland.github.io/%E7%AE%97%E6%B3%95/2014/07/26/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B4%A2%E5%BC%95%E6%A0%91(%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84).html
